"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.header_pb2
import bosdyn.api.lease_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _DockType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _DockTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DockType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    DOCK_TYPE_UNKNOWN: _DockType.ValueType  # 0
    """Unknown type of dock"""

    DOCK_TYPE_CONTACT_PROTOTYPE: _DockType.ValueType  # 2
    """Prototype version SpotDock"""

    DOCK_TYPE_SPOT_DOCK: _DockType.ValueType  # 3
    """Production version SpotDock"""

class DockType(_DockType, metaclass=_DockTypeEnumTypeWrapper):
    """Type of dock"""
    pass

DOCK_TYPE_UNKNOWN: DockType.ValueType  # 0
"""Unknown type of dock"""

DOCK_TYPE_CONTACT_PROTOTYPE: DockType.ValueType  # 2
"""Prototype version SpotDock"""

DOCK_TYPE_SPOT_DOCK: DockType.ValueType  # 3
"""Production version SpotDock"""

global___DockType = DockType


class _PrepPoseBehavior:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _PrepPoseBehaviorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PrepPoseBehavior.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PREP_POSE_UNKNOWN: _PrepPoseBehavior.ValueType  # 0
    """Default behavior, equivalent to PREP_POSE_USE_POSE."""

    PREP_POSE_USE_POSE: _PrepPoseBehavior.ValueType  # 1
    """Goes to the pre-docking pose before docking."""

    PREP_POSE_SKIP_POSE: _PrepPoseBehavior.ValueType  # 2
    """Docks before going to the pre-docking pose."""

    PREP_POSE_ONLY_POSE: _PrepPoseBehavior.ValueType  # 3
    """Goes to the pre-docking pose, and then returns SUCCESS without docking."""

    PREP_POSE_UNDOCK: _PrepPoseBehavior.ValueType  # 4
    """Use this enum to undock a currently docked robot."""

class PrepPoseBehavior(_PrepPoseBehavior, metaclass=_PrepPoseBehaviorEnumTypeWrapper):
    """Defines how and whether we use the "pre-docking" pose."""
    pass

PREP_POSE_UNKNOWN: PrepPoseBehavior.ValueType  # 0
"""Default behavior, equivalent to PREP_POSE_USE_POSE."""

PREP_POSE_USE_POSE: PrepPoseBehavior.ValueType  # 1
"""Goes to the pre-docking pose before docking."""

PREP_POSE_SKIP_POSE: PrepPoseBehavior.ValueType  # 2
"""Docks before going to the pre-docking pose."""

PREP_POSE_ONLY_POSE: PrepPoseBehavior.ValueType  # 3
"""Goes to the pre-docking pose, and then returns SUCCESS without docking."""

PREP_POSE_UNDOCK: PrepPoseBehavior.ValueType  # 4
"""Use this enum to undock a currently docked robot."""

global___PrepPoseBehavior = PrepPoseBehavior


class DockingCommandRequest(google.protobuf.message.Message):
    """Message to command the robot to dock. \\
    Note: If the robot is docked, you can undock the robot by issuing a command with
    `prep_pose_behavior=PREP_POSE_UNDOCK`. If undocking, `docking_station_id` is not required.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    DOCKING_STATION_ID_FIELD_NUMBER: builtins.int
    CLOCK_IDENTIFIER_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    PREP_POSE_BEHAVIOR_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The Lease to show ownership of the robot."""
        pass
    docking_station_id: builtins.int
    """ID of docking station to dock at.
    This is ignored if undocking the robot, the current dock is used.
    """

    clock_identifier: typing.Text
    """Identifier provided by the time sync service to verify time sync between robot and client."""

    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The timestamp (in robot time) by which a command must finish executing.
        This is a required field and used to prevent runaway commands.
        """
        pass
    prep_pose_behavior: global___PrepPoseBehavior.ValueType
    """[Optional] Specify the prep pose behavior"""

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        docking_station_id: builtins.int = ...,
        clock_identifier: typing.Text = ...,
        end_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        prep_pose_behavior: global___PrepPoseBehavior.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","header",b"header","lease",b"lease"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["clock_identifier",b"clock_identifier","docking_station_id",b"docking_station_id","end_time",b"end_time","header",b"header","lease",b"lease","prep_pose_behavior",b"prep_pose_behavior"]) -> None: ...
global___DockingCommandRequest = DockingCommandRequest

class DockingCommandResponse(google.protobuf.message.Message):
    """Response to a DockingCommandRequest"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DockingCommandResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: DockingCommandResponse._Status.ValueType  # 0
        """Status is not specified."""

        STATUS_OK: DockingCommandResponse._Status.ValueType  # 1
        """Docking command accepted"""

        STATUS_ERROR_LEASE: DockingCommandResponse._Status.ValueType  # 4
        """ERROR: Lease rejected"""

        STATUS_ERROR_DOCK_NOT_FOUND: DockingCommandResponse._Status.ValueType  # 5
        """ERROR: Dock fiducial not found."""

        STATUS_ERROR_NOT_DOCKED: DockingCommandResponse._Status.ValueType  # 6
        """ERROR: Trying to undock while not docked"""

        STATUS_ERROR_GRIPPER_HOLDING_ITEM: DockingCommandResponse._Status.ValueType  # 8
        """ERROR: Trying to dock when the arm is holding an object."""

        STATUS_ERROR_NOT_AVAILABLE: DockingCommandResponse._Status.ValueType  # 9
        """ERROR: The dock is not available for docking."""

        STATUS_ERROR_SYSTEM: DockingCommandResponse._Status.ValueType  # 7
        """ERROR: Internal system error during execution
        This error cannot be resolved by issuing a new DockingCommand
        Check the returned message for details
        """

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: DockingCommandResponse.Status.ValueType  # 0
    """Status is not specified."""

    STATUS_OK: DockingCommandResponse.Status.ValueType  # 1
    """Docking command accepted"""

    STATUS_ERROR_LEASE: DockingCommandResponse.Status.ValueType  # 4
    """ERROR: Lease rejected"""

    STATUS_ERROR_DOCK_NOT_FOUND: DockingCommandResponse.Status.ValueType  # 5
    """ERROR: Dock fiducial not found."""

    STATUS_ERROR_NOT_DOCKED: DockingCommandResponse.Status.ValueType  # 6
    """ERROR: Trying to undock while not docked"""

    STATUS_ERROR_GRIPPER_HOLDING_ITEM: DockingCommandResponse.Status.ValueType  # 8
    """ERROR: Trying to dock when the arm is holding an object."""

    STATUS_ERROR_NOT_AVAILABLE: DockingCommandResponse.Status.ValueType  # 9
    """ERROR: The dock is not available for docking."""

    STATUS_ERROR_SYSTEM: DockingCommandResponse.Status.ValueType  # 7
    """ERROR: Internal system error during execution
    This error cannot be resolved by issuing a new DockingCommand
    Check the returned message for details
    """


    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    DOCKING_COMMAND_ID_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """Details about how the lease was used."""
        pass
    status: global___DockingCommandResponse.Status.ValueType
    """Result of issued command."""

    docking_command_id: builtins.int
    """Unique identifier for the command (if accepted, `status=STATUS_OK`)."""

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        status: global___DockingCommandResponse.Status.ValueType = ...,
        docking_command_id: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["docking_command_id",b"docking_command_id","header",b"header","lease_use_result",b"lease_use_result","status",b"status"]) -> None: ...
global___DockingCommandResponse = DockingCommandResponse

class DockingCommandFeedbackRequest(google.protobuf.message.Message):
    """Message to get the status of a previously issued DockingCommand"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    DOCKING_COMMAND_ID_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    docking_command_id: builtins.int
    """Unique identifier of the command to get feedback for."""

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        docking_command_id: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["docking_command_id",b"docking_command_id","header",b"header"]) -> None: ...
global___DockingCommandFeedbackRequest = DockingCommandFeedbackRequest

class DockingCommandFeedbackResponse(google.protobuf.message.Message):
    """Response to a DockingCommandFeedbackRequest for a particualar docking command ID"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DockingCommandFeedbackResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: DockingCommandFeedbackResponse._Status.ValueType  # 0
        """Status is not specified."""

        STATUS_IN_PROGRESS: DockingCommandFeedbackResponse._Status.ValueType  # 1
        """Docking command is executing."""

        STATUS_DOCKED: DockingCommandFeedbackResponse._Status.ValueType  # 2
        """Docking command succeeded, the robot is docked."""

        STATUS_AT_PREP_POSE: DockingCommandFeedbackResponse._Status.ValueType  # 11
        """Final success state for `PREP_POSE_ONLY_POSE` or `PREP_POSE_UNDOCK`."""

        STATUS_MISALIGNED: DockingCommandFeedbackResponse._Status.ValueType  # 10
        """Misaligned was detected between the robot and the dock.
        The docking command was aborted to save an ending up in an unrecoverable state, please try again.
        """

        STATUS_OLD_DOCKING_COMMAND: DockingCommandFeedbackResponse._Status.ValueType  # 3
        """This DockingCommand overridden by new docking command."""

        STATUS_ERROR_DOCK_LOST: DockingCommandFeedbackResponse._Status.ValueType  # 4
        """ERROR: The sensed dock has been lost and is no longer found."""

        STATUS_ERROR_LEASE: DockingCommandFeedbackResponse._Status.ValueType  # 5
        """ERROR: Lease rejected."""

        STATUS_ERROR_COMMAND_TIMED_OUT: DockingCommandFeedbackResponse._Status.ValueType  # 6
        """ERROR: End time has been reached."""

        STATUS_ERROR_NO_TIMESYNC: DockingCommandFeedbackResponse._Status.ValueType  # 7
        """ERROR: No Timesync with system."""

        STATUS_ERROR_TOO_DISTANT: DockingCommandFeedbackResponse._Status.ValueType  # 8
        """ERROR: Provided end time too far in the future."""

        STATUS_ERROR_NOT_AVAILABLE: DockingCommandFeedbackResponse._Status.ValueType  # 12
        """ERROR: The dock is not available for docking."""

        STATUS_ERROR_SYSTEM: DockingCommandFeedbackResponse._Status.ValueType  # 9
        """ERROR: Internal system error during execution
        This error cannot be resolved by issuing a new DockingCommand
        Check the returned message for details
        """

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: DockingCommandFeedbackResponse.Status.ValueType  # 0
    """Status is not specified."""

    STATUS_IN_PROGRESS: DockingCommandFeedbackResponse.Status.ValueType  # 1
    """Docking command is executing."""

    STATUS_DOCKED: DockingCommandFeedbackResponse.Status.ValueType  # 2
    """Docking command succeeded, the robot is docked."""

    STATUS_AT_PREP_POSE: DockingCommandFeedbackResponse.Status.ValueType  # 11
    """Final success state for `PREP_POSE_ONLY_POSE` or `PREP_POSE_UNDOCK`."""

    STATUS_MISALIGNED: DockingCommandFeedbackResponse.Status.ValueType  # 10
    """Misaligned was detected between the robot and the dock.
    The docking command was aborted to save an ending up in an unrecoverable state, please try again.
    """

    STATUS_OLD_DOCKING_COMMAND: DockingCommandFeedbackResponse.Status.ValueType  # 3
    """This DockingCommand overridden by new docking command."""

    STATUS_ERROR_DOCK_LOST: DockingCommandFeedbackResponse.Status.ValueType  # 4
    """ERROR: The sensed dock has been lost and is no longer found."""

    STATUS_ERROR_LEASE: DockingCommandFeedbackResponse.Status.ValueType  # 5
    """ERROR: Lease rejected."""

    STATUS_ERROR_COMMAND_TIMED_OUT: DockingCommandFeedbackResponse.Status.ValueType  # 6
    """ERROR: End time has been reached."""

    STATUS_ERROR_NO_TIMESYNC: DockingCommandFeedbackResponse.Status.ValueType  # 7
    """ERROR: No Timesync with system."""

    STATUS_ERROR_TOO_DISTANT: DockingCommandFeedbackResponse.Status.ValueType  # 8
    """ERROR: Provided end time too far in the future."""

    STATUS_ERROR_NOT_AVAILABLE: DockingCommandFeedbackResponse.Status.ValueType  # 12
    """ERROR: The dock is not available for docking."""

    STATUS_ERROR_SYSTEM: DockingCommandFeedbackResponse.Status.ValueType  # 9
    """ERROR: Internal system error during execution
    This error cannot be resolved by issuing a new DockingCommand
    Check the returned message for details
    """


    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """Details about how the lease was used (unset if unknown)."""
        pass
    status: global___DockingCommandFeedbackResponse.Status.ValueType
    """Current feedback of specified command ID."""

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        status: global___DockingCommandFeedbackResponse.Status.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result","status",b"status"]) -> None: ...
global___DockingCommandFeedbackResponse = DockingCommandFeedbackResponse

class ConfigRange(google.protobuf.message.Message):
    """The configuration of a range of dock ID's"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ID_START_FIELD_NUMBER: builtins.int
    ID_END_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    id_start: builtins.int
    """Starting ID"""

    id_end: builtins.int
    """Ending ID"""

    type: global___DockType.ValueType
    """Type of dock for this range"""

    def __init__(self,
        *,
        id_start: builtins.int = ...,
        id_end: builtins.int = ...,
        type: global___DockType.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["id_end",b"id_end","id_start",b"id_start","type",b"type"]) -> None: ...
global___ConfigRange = ConfigRange

class GetDockingConfigRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header"]) -> None: ...
global___GetDockingConfigRequest = GetDockingConfigRequest

class GetDockingConfigResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    DOCK_CONFIGS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def dock_configs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ConfigRange]:
        """A series of `ConfigRange` specifying details for dock ID numbers."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        dock_configs: typing.Optional[typing.Iterable[global___ConfigRange]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dock_configs",b"dock_configs","header",b"header"]) -> None: ...
global___GetDockingConfigResponse = GetDockingConfigResponse

class DockState(google.protobuf.message.Message):
    """Message describing the overall dock state of the robot, including power & comms connections.  \\
    Not tied to any particular DockingCommand ID.  \\
    Note: [*] indicates fields which are only valid if the status is DOCK_STATUS_DOCKED or DOCK_STATUS_DOCKING  \\
    or DOCK_STATUS_UNDOCKING. \\
    Note: [^] indicates fields which are only valid if the status is DOCK_STATUS_DOCKED.  \\
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _DockedStatus:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _DockedStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DockState._DockedStatus.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        DOCK_STATUS_UNKNOWN: DockState._DockedStatus.ValueType  # 0
        """Unknown"""

        DOCK_STATUS_DOCKED: DockState._DockedStatus.ValueType  # 1
        """Robot is detected as on a dock"""

        DOCK_STATUS_DOCKING: DockState._DockedStatus.ValueType  # 2
        """Robot is currently running a docking command"""

        DOCK_STATUS_UNDOCKED: DockState._DockedStatus.ValueType  # 3
        """Robot is not detected as on dock"""

        DOCK_STATUS_UNDOCKING: DockState._DockedStatus.ValueType  # 4
        """Robot is currently running an undocking command"""

    class DockedStatus(_DockedStatus, metaclass=_DockedStatusEnumTypeWrapper):
        pass

    DOCK_STATUS_UNKNOWN: DockState.DockedStatus.ValueType  # 0
    """Unknown"""

    DOCK_STATUS_DOCKED: DockState.DockedStatus.ValueType  # 1
    """Robot is detected as on a dock"""

    DOCK_STATUS_DOCKING: DockState.DockedStatus.ValueType  # 2
    """Robot is currently running a docking command"""

    DOCK_STATUS_UNDOCKED: DockState.DockedStatus.ValueType  # 3
    """Robot is not detected as on dock"""

    DOCK_STATUS_UNDOCKING: DockState.DockedStatus.ValueType  # 4
    """Robot is currently running an undocking command"""


    class _LinkStatus:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _LinkStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DockState._LinkStatus.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        LINK_STATUS_UNKNOWN: DockState._LinkStatus.ValueType  # 0
        """Unknown or Not applicable"""

        LINK_STATUS_DETECTING: DockState._LinkStatus.ValueType  # 3
        """The link status is being detected"""

        LINK_STATUS_CONNECTED: DockState._LinkStatus.ValueType  # 1
        """The link is detected as connected"""

        LINK_STATUS_ERROR: DockState._LinkStatus.ValueType  # 2
        """The link could not be detected"""

    class LinkStatus(_LinkStatus, metaclass=_LinkStatusEnumTypeWrapper):
        pass

    LINK_STATUS_UNKNOWN: DockState.LinkStatus.ValueType  # 0
    """Unknown or Not applicable"""

    LINK_STATUS_DETECTING: DockState.LinkStatus.ValueType  # 3
    """The link status is being detected"""

    LINK_STATUS_CONNECTED: DockState.LinkStatus.ValueType  # 1
    """The link is detected as connected"""

    LINK_STATUS_ERROR: DockState.LinkStatus.ValueType  # 2
    """The link could not be detected"""


    STATUS_FIELD_NUMBER: builtins.int
    DOCK_TYPE_FIELD_NUMBER: builtins.int
    DOCK_ID_FIELD_NUMBER: builtins.int
    POWER_STATUS_FIELD_NUMBER: builtins.int
    status: global___DockState.DockedStatus.ValueType
    """Status of if the robot is on dock"""

    dock_type: global___DockType.ValueType
    """[*] Type of the dock"""

    dock_id: builtins.int
    """[*] ID of the dock"""

    power_status: global___DockState.LinkStatus.ValueType
    """[^] Status of power detection from the dock"""

    def __init__(self,
        *,
        status: global___DockState.DockedStatus.ValueType = ...,
        dock_type: global___DockType.ValueType = ...,
        dock_id: builtins.int = ...,
        power_status: global___DockState.LinkStatus.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["dock_id",b"dock_id","dock_type",b"dock_type","power_status",b"power_status","status",b"status"]) -> None: ...
global___DockState = DockState

class GetDockingStateRequest(google.protobuf.message.Message):
    """Message to get the overall docking state"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header"]) -> None: ...
global___GetDockingStateRequest = GetDockingStateRequest

class GetDockingStateResponse(google.protobuf.message.Message):
    """Response of a GetDockingStateRequest"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    DOCK_STATE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def dock_state(self) -> global___DockState: ...
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        dock_state: typing.Optional[global___DockState] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dock_state",b"dock_state","header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dock_state",b"dock_state","header",b"header"]) -> None: ...
global___GetDockingStateResponse = GetDockingStateResponse
