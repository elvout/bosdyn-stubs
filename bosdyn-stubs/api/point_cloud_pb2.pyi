"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.geometry_pb2
import bosdyn.api.header_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class PointCloudSource(google.protobuf.message.Message):
    """Information about a sensor or process that produces point clouds."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    FRAME_NAME_SENSOR_FIELD_NUMBER: builtins.int
    ACQUISITION_TIME_FIELD_NUMBER: builtins.int
    TRANSFORMS_SNAPSHOT_FIELD_NUMBER: builtins.int
    name: typing.Text
    """The name of the point cloud source. This is intended to be unique accross all point cloud sources,
    and should be human readable.
    """

    frame_name_sensor: typing.Text
    """The frame name of the sensor. The transformation from vision_tform_sensor can be computed
    by traversing the tree in the FrameTreeSnapshot.
    """

    @property
    def acquisition_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time that the data was produced on the sensor in the robot's clock."""
        pass
    @property
    def transforms_snapshot(self) -> bosdyn.api.geometry_pb2.FrameTreeSnapshot:
        """A tree-based collection of transformations, which will include the transformations
        to the point cloud data frame and the point cloud sensor frame.
        """
        pass
    def __init__(self,
        *,
        name: typing.Text = ...,
        frame_name_sensor: typing.Text = ...,
        acquisition_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        transforms_snapshot: typing.Optional[bosdyn.api.geometry_pb2.FrameTreeSnapshot] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["acquisition_time",b"acquisition_time","transforms_snapshot",b"transforms_snapshot"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["acquisition_time",b"acquisition_time","frame_name_sensor",b"frame_name_sensor","name",b"name","transforms_snapshot",b"transforms_snapshot"]) -> None: ...
global___PointCloudSource = PointCloudSource

class PointCloud(google.protobuf.message.Message):
    """Data from a point-cloud producing sensor or process."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Encoding:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _EncodingEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[PointCloud._Encoding.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        ENCODING_UNKNOWN: PointCloud._Encoding.ValueType  # 0
        """The point cloud has an unknown encoding."""

        ENCODING_XYZ_32F: PointCloud._Encoding.ValueType  # 1
        """Each point is x,y,z float32 value (12 bytes, little-endian) stored sequentially. This allows
        the point cloud to be expressed in any range and resolution represented by floating point
        numbers, but the point cloud will be larger than if one of the other encodings is used.
        """

        ENCODING_XYZ_4SC: PointCloud._Encoding.ValueType  # 2
        """Each point is 3 signed int8s plus an extra shared signed int8s (4 byte).
        byte layout: [..., p1_x, p1_y, p1_z, x, ...]
        Each coordinate is mapped to a value between -1 and +1 (corresponding to a
        minimum and maximum range).
        The resulting point is:
          P = remap(p1 * f + p2, c * f, m)
        Where:
          p1 = the highest byte in each dimension of the point.
          p2 = a vector of "extra" bytes converted to metric units.
            = [mod (x, f), mod(x/f, f), mod(x/(f^2), f)] - f/2
          x = the "extra" byte for each point.
          f = An integer scale factor.
          m = [max_x, max_y, max_z], the point cloud max bounds in meters.
          c = a remapping constant.
        And:
         remap(a, b, c) = (a + b)/(2 * b) - c
        Point clouds use 1/3 the memory of XYZ_32F, but have limits on resolution
        and range. Points must not lie outside of the box of size [-m, m]. Within that box,
        the resolution of the point cloud will depend on the encoding parameters.
        For example if m = [10, 10, 10], and f = 5 with c = 127 the resolution is
        approximately 1.5 cm per point.
        """

        ENCODING_XYZ_5SC: PointCloud._Encoding.ValueType  # 3
        """Each point is 3 signed int8s plus two extra shared signed int8s (5 byte).
        The encoding is the same as XYZ_4SC, except the "extra" value x is a 16 bit integer.
        This encoding has roughly double the resolution of XYZ_4SC, but takes up
        an additional byte for each point.
        """

    class Encoding(_Encoding, metaclass=_EncodingEnumTypeWrapper):
        """Point clouds may be encoded in different ways to preserve bandwidth or disk space."""
        pass

    ENCODING_UNKNOWN: PointCloud.Encoding.ValueType  # 0
    """The point cloud has an unknown encoding."""

    ENCODING_XYZ_32F: PointCloud.Encoding.ValueType  # 1
    """Each point is x,y,z float32 value (12 bytes, little-endian) stored sequentially. This allows
    the point cloud to be expressed in any range and resolution represented by floating point
    numbers, but the point cloud will be larger than if one of the other encodings is used.
    """

    ENCODING_XYZ_4SC: PointCloud.Encoding.ValueType  # 2
    """Each point is 3 signed int8s plus an extra shared signed int8s (4 byte).
    byte layout: [..., p1_x, p1_y, p1_z, x, ...]
    Each coordinate is mapped to a value between -1 and +1 (corresponding to a
    minimum and maximum range).
    The resulting point is:
      P = remap(p1 * f + p2, c * f, m)
    Where:
      p1 = the highest byte in each dimension of the point.
      p2 = a vector of "extra" bytes converted to metric units.
        = [mod (x, f), mod(x/f, f), mod(x/(f^2), f)] - f/2
      x = the "extra" byte for each point.
      f = An integer scale factor.
      m = [max_x, max_y, max_z], the point cloud max bounds in meters.
      c = a remapping constant.
    And:
     remap(a, b, c) = (a + b)/(2 * b) - c
    Point clouds use 1/3 the memory of XYZ_32F, but have limits on resolution
    and range. Points must not lie outside of the box of size [-m, m]. Within that box,
    the resolution of the point cloud will depend on the encoding parameters.
    For example if m = [10, 10, 10], and f = 5 with c = 127 the resolution is
    approximately 1.5 cm per point.
    """

    ENCODING_XYZ_5SC: PointCloud.Encoding.ValueType  # 3
    """Each point is 3 signed int8s plus two extra shared signed int8s (5 byte).
    The encoding is the same as XYZ_4SC, except the "extra" value x is a 16 bit integer.
    This encoding has roughly double the resolution of XYZ_4SC, but takes up
    an additional byte for each point.
    """


    class EncodingParameters(google.protobuf.message.Message):
        """Parameters needed to decode the point cloud."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        SCALE_FACTOR_FIELD_NUMBER: builtins.int
        MAX_X_FIELD_NUMBER: builtins.int
        MAX_Y_FIELD_NUMBER: builtins.int
        MAX_Z_FIELD_NUMBER: builtins.int
        REMAPPING_CONSTANT_FIELD_NUMBER: builtins.int
        BYTES_PER_POINT_FIELD_NUMBER: builtins.int
        scale_factor: builtins.int
        """Used in the remapping process from bytes to metric units. (unitless)"""

        max_x: builtins.float
        """In XYZ_4SC and XYZ_5SC, the point cloud is assumed to lie inside a box
        centered in the data frame. max_x, max_y, max_z are half the dimensions
        of that box. These dimensions should be assumed to be meters.
        """

        max_y: builtins.float
        """max_y is half the dimensions of the assumed box (for XYZ_4SC and XYZ_5SC). These
        dimensions should be assumed to be meters.
        """

        max_z: builtins.float
        """max_z is half the dimensions of the assumed box (for XYZ_4SC and XYZ_5SC). These
        dimensions should be assumed to be meters.
        """

        remapping_constant: builtins.float
        """Used in the remapping process from bytes to metric units. (unitless)
        For XYZ_4SC and XYZ_5C, this should equal 127.
        """

        bytes_per_point: builtins.int
        """Number of bytes in each point in this encoding."""

        def __init__(self,
            *,
            scale_factor: builtins.int = ...,
            max_x: builtins.float = ...,
            max_y: builtins.float = ...,
            max_z: builtins.float = ...,
            remapping_constant: builtins.float = ...,
            bytes_per_point: builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["bytes_per_point",b"bytes_per_point","max_x",b"max_x","max_y",b"max_y","max_z",b"max_z","remapping_constant",b"remapping_constant","scale_factor",b"scale_factor"]) -> None: ...

    SOURCE_FIELD_NUMBER: builtins.int
    NUM_POINTS_FIELD_NUMBER: builtins.int
    ENCODING_FIELD_NUMBER: builtins.int
    ENCODING_PARAMETERS_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    @property
    def source(self) -> global___PointCloudSource:
        """The sensor or process that produced the point cloud."""
        pass
    num_points: builtins.int
    """The number of points in the point cloud."""

    encoding: global___PointCloud.Encoding.ValueType
    """Representation of the underlying point cloud data."""

    @property
    def encoding_parameters(self) -> global___PointCloud.EncodingParameters:
        """Constants needed to decode the point cloud."""
        pass
    data: builtins.bytes
    """Raw byte data representing the points."""

    def __init__(self,
        *,
        source: typing.Optional[global___PointCloudSource] = ...,
        num_points: builtins.int = ...,
        encoding: global___PointCloud.Encoding.ValueType = ...,
        encoding_parameters: typing.Optional[global___PointCloud.EncodingParameters] = ...,
        data: builtins.bytes = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["encoding_parameters",b"encoding_parameters","source",b"source"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["data",b"data","encoding",b"encoding","encoding_parameters",b"encoding_parameters","num_points",b"num_points","source",b"source"]) -> None: ...
global___PointCloud = PointCloud

class ListPointCloudSourcesRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header"]) -> None: ...
global___ListPointCloudSourcesRequest = ListPointCloudSourcesRequest

class ListPointCloudSourcesResponse(google.protobuf.message.Message):
    """The GetPointCloud response message which returns any point cloud data associated with that service."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    POINT_CLOUD_SOURCES_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response Header."""
        pass
    @property
    def point_cloud_sources(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PointCloudSource]:
        """The set of PointCloudSources available from this service.
        May be empty if the service serves no point clouds (e.g., if no sensors were found on startup).
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        point_cloud_sources: typing.Optional[typing.Iterable[global___PointCloudSource]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","point_cloud_sources",b"point_cloud_sources"]) -> None: ...
global___ListPointCloudSourcesResponse = ListPointCloudSourcesResponse

class PointCloudRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    POINT_CLOUD_SOURCE_NAME_FIELD_NUMBER: builtins.int
    point_cloud_source_name: typing.Text
    """Name of the point cloud source to request from."""

    def __init__(self,
        *,
        point_cloud_source_name: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["point_cloud_source_name",b"point_cloud_source_name"]) -> None: ...
global___PointCloudRequest = PointCloudRequest

class GetPointCloudRequest(google.protobuf.message.Message):
    """The GetPointCloud request message to ask a specific point cloud service for data."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    POINT_CLOUD_REQUESTS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def point_cloud_requests(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PointCloudRequest]:
        """Sources to retrieve from. The service will return a response for each PointCloudRequest."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        point_cloud_requests: typing.Optional[typing.Iterable[global___PointCloudRequest]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","point_cloud_requests",b"point_cloud_requests"]) -> None: ...
global___GetPointCloudRequest = GetPointCloudRequest

class PointCloudResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[PointCloudResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: PointCloudResponse._Status.ValueType  # 0
        """UNKNOWN should never be used.
        An internal PointCloudService issue has happened if UNKNOWN is set.
        None of the other fields are filled out.
        """

        STATUS_OK: PointCloudResponse._Status.ValueType  # 1
        """Call succeeded at filling out all the fields."""

        STATUS_SOURCE_DATA_ERROR: PointCloudResponse._Status.ValueType  # 2
        """Failed to fill out PointCloudSource. All the other fields are not filled out."""

        STATUS_POINT_CLOUD_DATA_ERROR: PointCloudResponse._Status.ValueType  # 3
        """There was a problem with the point cloud data.  Only the PointCloudSource is filled out."""

        STATUS_UNKNOWN_SOURCE: PointCloudResponse._Status.ValueType  # 4
        """Provided point cloud source was not found. One"""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: PointCloudResponse.Status.ValueType  # 0
    """UNKNOWN should never be used.
    An internal PointCloudService issue has happened if UNKNOWN is set.
    None of the other fields are filled out.
    """

    STATUS_OK: PointCloudResponse.Status.ValueType  # 1
    """Call succeeded at filling out all the fields."""

    STATUS_SOURCE_DATA_ERROR: PointCloudResponse.Status.ValueType  # 2
    """Failed to fill out PointCloudSource. All the other fields are not filled out."""

    STATUS_POINT_CLOUD_DATA_ERROR: PointCloudResponse.Status.ValueType  # 3
    """There was a problem with the point cloud data.  Only the PointCloudSource is filled out."""

    STATUS_UNKNOWN_SOURCE: PointCloudResponse.Status.ValueType  # 4
    """Provided point cloud source was not found. One"""


    STATUS_FIELD_NUMBER: builtins.int
    POINT_CLOUD_FIELD_NUMBER: builtins.int
    status: global___PointCloudResponse.Status.ValueType
    """Return status for the request."""

    @property
    def point_cloud(self) -> global___PointCloud:
        """The current point cloud from the service."""
        pass
    def __init__(self,
        *,
        status: global___PointCloudResponse.Status.ValueType = ...,
        point_cloud: typing.Optional[global___PointCloud] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["point_cloud",b"point_cloud"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["point_cloud",b"point_cloud","status",b"status"]) -> None: ...
global___PointCloudResponse = PointCloudResponse

class GetPointCloudResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    POINT_CLOUD_RESPONSES_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def point_cloud_responses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PointCloudResponse]:
        """The resulting point clouds for each requested source."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        point_cloud_responses: typing.Optional[typing.Iterable[global___PointCloudResponse]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","point_cloud_responses",b"point_cloud_responses"]) -> None: ...
global___GetPointCloudResponse = GetPointCloudResponse
