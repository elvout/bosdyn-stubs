"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.geometry_pb2
import bosdyn.api.graph_nav.map_pb2
import bosdyn.api.header_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class ProcessTopologyRequest(google.protobuf.message.Message):
    """Processes a GraphNav map by creating additional edges. After processing,
    a new subgraph is created containing additional edges to add to the map.
    Edges are created between waypoints that are near each other. These waypoint pairs
    are called "loop closures", and are found by different means.
    In general, if parameters are not provided, reasonable defaults will be used.
    Note that this can be used to merge disconnected subgraphs from multiple recording
    sessions so long as they share fiducial observations.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class ICPParams(google.protobuf.message.Message):
        """Parameters for how to refine loop closure edges using iterative
        closest point matching.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        ICP_ITERS_FIELD_NUMBER: builtins.int
        MAX_POINT_MATCH_DISTANCE_FIELD_NUMBER: builtins.int
        @property
        def icp_iters(self) -> google.protobuf.wrappers_pb2.Int32Value:
            """The maximum number of iterations to run. Set to zero to skip ICP processing."""
            pass
        @property
        def max_point_match_distance(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """The maximum distance between points in the point cloud we are willing to
            accept for matches.
            """
            pass
        def __init__(self,
            *,
            icp_iters: typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
            max_point_match_distance: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["icp_iters",b"icp_iters","max_point_match_distance",b"max_point_match_distance"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["icp_iters",b"icp_iters","max_point_match_distance",b"max_point_match_distance"]) -> None: ...

    class OdometryLoopClosureParams(google.protobuf.message.Message):
        """Parameters for how to close loops using odometry. This infers which waypoints
        should be connected to one another based on the odometry measurements in the map.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        MAX_LOOP_CLOSURE_PATH_LENGTH_FIELD_NUMBER: builtins.int
        MIN_LOOP_CLOSURE_PATH_LENGTH_FIELD_NUMBER: builtins.int
        MAX_LOOP_CLOSURE_HEIGHT_CHANGE_FIELD_NUMBER: builtins.int
        MAX_LOOP_CLOSURE_EDGE_LENGTH_FIELD_NUMBER: builtins.int
        NUM_EXTRA_LOOP_CLOSURE_ITERATIONS_FIELD_NUMBER: builtins.int
        @property
        def max_loop_closure_path_length(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """The maximum distance between waypoints found by walking a path from one
            waypoint to the other using only the existing edges in the map. Beyond
            this distance, we are unwilling to trust odometry.
            """
            pass
        @property
        def min_loop_closure_path_length(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """The minimum distance between waypoints found by walking a path from
            one waypoint to the other using only the existing edges in the map.
            Set this higher to avoid creating small shortcuts along the existing path.
            Note that this is a 2d path length.
            """
            pass
        @property
        def max_loop_closure_height_change(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """The maximum apparent height change of the created edge that we are
            willing to accept between waypoints. This avoids closing loops up ramps,
            stairs, etc. or closing loops where there is significant odometry drift.
            """
            pass
        @property
        def max_loop_closure_edge_length(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Once a loop closure candidate is found, the system creates an edge between the
            candidate waypoints. Only create the edge if it is shorter than this value.
            Note that this is a 3d edge length.
            """
            pass
        @property
        def num_extra_loop_closure_iterations(self) -> google.protobuf.wrappers_pb2.Int32Value:
            """Use prior loop closures to infer new odometry based loop closures. This is
            useful when other sources of loop closures (like fiducials) are being used.
            The existence of those loop closures allows the system to infer other nearby
            loop closures using odometry. Alternatively, the user may call the ProcessTopology
            RPC multiple times to achieve the same effect.
            """
            pass
        def __init__(self,
            *,
            max_loop_closure_path_length: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            min_loop_closure_path_length: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_loop_closure_height_change: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_loop_closure_edge_length: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            num_extra_loop_closure_iterations: typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["max_loop_closure_edge_length",b"max_loop_closure_edge_length","max_loop_closure_height_change",b"max_loop_closure_height_change","max_loop_closure_path_length",b"max_loop_closure_path_length","min_loop_closure_path_length",b"min_loop_closure_path_length","num_extra_loop_closure_iterations",b"num_extra_loop_closure_iterations"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["max_loop_closure_edge_length",b"max_loop_closure_edge_length","max_loop_closure_height_change",b"max_loop_closure_height_change","max_loop_closure_path_length",b"max_loop_closure_path_length","min_loop_closure_path_length",b"min_loop_closure_path_length","num_extra_loop_closure_iterations",b"num_extra_loop_closure_iterations"]) -> None: ...

    class FiducialLoopClosureParams(google.protobuf.message.Message):
        """Parameters for how to close a loop using fiducials (AprilTags). This infers
        which waypoints should be connected to one another based on shared observations
        of AprilTags.
        Note that multiple disconnected subgraphs (for example from multiple recording sessions)
        can be merged this way.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        MIN_LOOP_CLOSURE_PATH_LENGTH_FIELD_NUMBER: builtins.int
        MAX_LOOP_CLOSURE_EDGE_LENGTH_FIELD_NUMBER: builtins.int
        MAX_FIDUCIAL_DISTANCE_FIELD_NUMBER: builtins.int
        MAX_LOOP_CLOSURE_HEIGHT_CHANGE_FIELD_NUMBER: builtins.int
        @property
        def min_loop_closure_path_length(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """The minimum distance between waypoints found by walking a path from
            one waypoint to the other using only the existing edges in the map.
            Set this higher to avoid creating small shortcuts along the existing path.
            Note that this is a 2d path length.
            """
            pass
        @property
        def max_loop_closure_edge_length(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Once a loop closure candidate is found, the system creates an edge between the
            candidate waypoints. Only create the edge if it is shorter than this value.
            Note that this is a 3d edge length.
            """
            pass
        @property
        def max_fiducial_distance(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Maximum distance to accept between a waypoint and a fiducial detection to
            use that fiducial detection for generating loop closure candidates.
            """
            pass
        @property
        def max_loop_closure_height_change(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """The maximum apparent height change of the created edge that we are
            willing to accept between waypoints. This avoids closing loops up ramps,
            stairs, etc. or closing loops where there is significant odometry drift.
            """
            pass
        def __init__(self,
            *,
            min_loop_closure_path_length: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_loop_closure_edge_length: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_fiducial_distance: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_loop_closure_height_change: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["max_fiducial_distance",b"max_fiducial_distance","max_loop_closure_edge_length",b"max_loop_closure_edge_length","max_loop_closure_height_change",b"max_loop_closure_height_change","min_loop_closure_path_length",b"min_loop_closure_path_length"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["max_fiducial_distance",b"max_fiducial_distance","max_loop_closure_edge_length",b"max_loop_closure_edge_length","max_loop_closure_height_change",b"max_loop_closure_height_change","min_loop_closure_path_length",b"min_loop_closure_path_length"]) -> None: ...

    class CollisionCheckingParams(google.protobuf.message.Message):
        """Parameters for how to check for collisions when creating loop closures. The system
        will avoid creating edges in the map that the robot cannot actually traverse due to
        the presence of nearby obstacles.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        CHECK_EDGES_FOR_COLLISION_FIELD_NUMBER: builtins.int
        COLLISION_CHECK_ROBOT_RADIUS_FIELD_NUMBER: builtins.int
        COLLISION_CHECK_HEIGHT_VARIATION_FIELD_NUMBER: builtins.int
        @property
        def check_edges_for_collision(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """By default, this is true."""
            pass
        @property
        def collision_check_robot_radius(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Assume that the robot is a sphere with this radius. Only accept a
            loop closure if this spherical robot can travel in a straight line
            from one waypoint to the other without hitting obstacles.
            """
            pass
        @property
        def collision_check_height_variation(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Consider significant height variations along the edge (like stairs or ramps)
            to be obstacles. The edge will not be created if there is a height change along
            it of more than this value according to the nearby sensor data.
            """
            pass
        def __init__(self,
            *,
            check_edges_for_collision: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            collision_check_robot_radius: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            collision_check_height_variation: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["check_edges_for_collision",b"check_edges_for_collision","collision_check_height_variation",b"collision_check_height_variation","collision_check_robot_radius",b"collision_check_robot_radius"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["check_edges_for_collision",b"check_edges_for_collision","collision_check_height_variation",b"collision_check_height_variation","collision_check_robot_radius",b"collision_check_robot_radius"]) -> None: ...

    class Params(google.protobuf.message.Message):
        """Parameters which control topology processing. In general, anything which isn't filled out
        will be replaced by reasonable defaults.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        DO_ODOMETRY_LOOP_CLOSURE_FIELD_NUMBER: builtins.int
        ODOMETRY_LOOP_CLOSURE_PARAMS_FIELD_NUMBER: builtins.int
        ICP_PARAMS_FIELD_NUMBER: builtins.int
        DO_FIDUCIAL_LOOP_CLOSURE_FIELD_NUMBER: builtins.int
        FIDUCIAL_LOOP_CLOSURE_PARAMS_FIELD_NUMBER: builtins.int
        COLLISION_CHECK_PARAMS_FIELD_NUMBER: builtins.int
        TIMEOUT_SECONDS_FIELD_NUMBER: builtins.int
        @property
        def do_odometry_loop_closure(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """True by default -- generate loop closure candidates using odometry."""
            pass
        @property
        def odometry_loop_closure_params(self) -> global___ProcessTopologyRequest.OdometryLoopClosureParams:
            """Parameters for generating loop closure candidates using odometry."""
            pass
        @property
        def icp_params(self) -> global___ProcessTopologyRequest.ICPParams:
            """Parameters for refining loop closure candidates using iterative closest point
            cloud matching.
            """
            pass
        @property
        def do_fiducial_loop_closure(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """True by default -- generate loop closure candidates using fiducials."""
            pass
        @property
        def fiducial_loop_closure_params(self) -> global___ProcessTopologyRequest.FiducialLoopClosureParams:
            """Parameters for generating loop closure candidates using fiducials."""
            pass
        @property
        def collision_check_params(self) -> global___ProcessTopologyRequest.CollisionCheckingParams:
            """Parameters which control rejecting loop closure candidates which
            collide with obstacles.
            """
            pass
        timeout_seconds: builtins.float
        """Causes the processing to time out after this many seconds. If not set, a default of 45 seconds
        will be used. If this timeout occurs before the overall RPC timeout, a partial result will be
        returned with ProcessTopologyResponse.timed_out set to true. Processing can be continued by
        calling ProcessTopology again.
        """

        def __init__(self,
            *,
            do_odometry_loop_closure: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            odometry_loop_closure_params: typing.Optional[global___ProcessTopologyRequest.OdometryLoopClosureParams] = ...,
            icp_params: typing.Optional[global___ProcessTopologyRequest.ICPParams] = ...,
            do_fiducial_loop_closure: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            fiducial_loop_closure_params: typing.Optional[global___ProcessTopologyRequest.FiducialLoopClosureParams] = ...,
            collision_check_params: typing.Optional[global___ProcessTopologyRequest.CollisionCheckingParams] = ...,
            timeout_seconds: builtins.float = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["collision_check_params",b"collision_check_params","do_fiducial_loop_closure",b"do_fiducial_loop_closure","do_odometry_loop_closure",b"do_odometry_loop_closure","fiducial_loop_closure_params",b"fiducial_loop_closure_params","icp_params",b"icp_params","odometry_loop_closure_params",b"odometry_loop_closure_params"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["collision_check_params",b"collision_check_params","do_fiducial_loop_closure",b"do_fiducial_loop_closure","do_odometry_loop_closure",b"do_odometry_loop_closure","fiducial_loop_closure_params",b"fiducial_loop_closure_params","icp_params",b"icp_params","odometry_loop_closure_params",b"odometry_loop_closure_params","timeout_seconds",b"timeout_seconds"]) -> None: ...

    HEADER_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    MODIFY_MAP_ON_SERVER_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Standard message header."""
        pass
    @property
    def params(self) -> global___ProcessTopologyRequest.Params:
        """Parameters. If not filled out, reasonable defaults will be used."""
        pass
    modify_map_on_server: builtins.bool
    """If true, any processing should directly modify the map on the server.
    Otherwise, the client is expected to upload the processing results (newly created edges)
    back to the server. The processing service shares memory with a map container service
    (e.g the GraphNav service).
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        params: typing.Optional[global___ProcessTopologyRequest.Params] = ...,
        modify_map_on_server: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","params",b"params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","modify_map_on_server",b"modify_map_on_server","params",b"params"]) -> None: ...
global___ProcessTopologyRequest = ProcessTopologyRequest

class ProcessTopologyResponse(google.protobuf.message.Message):
    """Result of the topology processing RPC. If successful, contains a subgraph of new
    waypoints or edges created by this process.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ProcessTopologyResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: ProcessTopologyResponse._Status.ValueType  # 0
        """Programming error."""

        STATUS_OK: ProcessTopologyResponse._Status.ValueType  # 1
        """Success."""

        STATUS_MISSING_WAYPOINT_SNAPSHOTS: ProcessTopologyResponse._Status.ValueType  # 2
        """Not all of the waypoint snapshots exist on the server. Upload them to continue."""

        STATUS_INVALID_GRAPH: ProcessTopologyResponse._Status.ValueType  # 3
        """The graph is invalid topologically, for example containing missing waypoints referenced by edges."""

        STATUS_MAP_MODIFIED_DURING_PROCESSING: ProcessTopologyResponse._Status.ValueType  # 4
        """Tried to write the anchoring after processing, but another client may have modified the map. Try again"""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: ProcessTopologyResponse.Status.ValueType  # 0
    """Programming error."""

    STATUS_OK: ProcessTopologyResponse.Status.ValueType  # 1
    """Success."""

    STATUS_MISSING_WAYPOINT_SNAPSHOTS: ProcessTopologyResponse.Status.ValueType  # 2
    """Not all of the waypoint snapshots exist on the server. Upload them to continue."""

    STATUS_INVALID_GRAPH: ProcessTopologyResponse.Status.ValueType  # 3
    """The graph is invalid topologically, for example containing missing waypoints referenced by edges."""

    STATUS_MAP_MODIFIED_DURING_PROCESSING: ProcessTopologyResponse.Status.ValueType  # 4
    """Tried to write the anchoring after processing, but another client may have modified the map. Try again"""


    HEADER_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    NEW_SUBGRAPH_FIELD_NUMBER: builtins.int
    MAP_ON_SERVER_WAS_MODIFIED_FIELD_NUMBER: builtins.int
    MISSING_SNAPSHOT_IDS_FIELD_NUMBER: builtins.int
    MISSING_WAYPOINT_IDS_FIELD_NUMBER: builtins.int
    TIMED_OUT_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Standard message header."""
        pass
    status: global___ProcessTopologyResponse.Status.ValueType
    """Result of the processing."""

    @property
    def new_subgraph(self) -> bosdyn.api.graph_nav.map_pb2.Graph:
        """This graph contains the new edge(s) created by map processing. Note that these edges will be
        annotated with their creation method. Note that several subgraphs may be returned via
        streaming as the map is processed.
        """
        pass
    map_on_server_was_modified: builtins.bool
    """If modify_map_on_server was set to true in the request, then the map currently on the server
    was modified using map processing. If this is set to false, then either an error occurred during
    processing, or modify_map_on_server was set to false in the request.
    When map_on_server_was_modified is set to false, the client is expected to upload the results
    back to the server to commit the changes.
    """

    @property
    def missing_snapshot_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """When there are missing waypoint snapshots, these are the IDs of the missing snapshots.
        Upload them to continue.
        """
        pass
    @property
    def missing_waypoint_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """When there are missing waypoints, these are the IDs of the missing waypoints. Upload them
        to continue.
        """
        pass
    timed_out: builtins.bool
    """If true, the processing timed out. Note that this is not considered an error. Run topology processing again
    to continue adding edges.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        status: global___ProcessTopologyResponse.Status.ValueType = ...,
        new_subgraph: typing.Optional[bosdyn.api.graph_nav.map_pb2.Graph] = ...,
        map_on_server_was_modified: builtins.bool = ...,
        missing_snapshot_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        missing_waypoint_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        timed_out: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","new_subgraph",b"new_subgraph"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","map_on_server_was_modified",b"map_on_server_was_modified","missing_snapshot_ids",b"missing_snapshot_ids","missing_waypoint_ids",b"missing_waypoint_ids","new_subgraph",b"new_subgraph","status",b"status","timed_out",b"timed_out"]) -> None: ...
global___ProcessTopologyResponse = ProcessTopologyResponse

class PoseBounds(google.protobuf.message.Message):
    """Represents an interval in x, y, z and yaw around some center. Some value x
    will be within the bounds if  center - x_bounds <= x >= center + x_bounds.
    If the values are left at zero, the bounds are considered to be unconstrained.
    The center of the bounds is left implicit, and should be whatever this message
    is packaged with.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    X_BOUNDS_FIELD_NUMBER: builtins.int
    Y_BOUNDS_FIELD_NUMBER: builtins.int
    Z_BOUNDS_FIELD_NUMBER: builtins.int
    YAW_BOUNDS_FIELD_NUMBER: builtins.int
    x_bounds: builtins.float
    """Bounds on the x position in meters."""

    y_bounds: builtins.float
    """Bounds on the y position in meters."""

    z_bounds: builtins.float
    """Bounds on the z position in meters."""

    yaw_bounds: builtins.float
    """Bounds on the yaw (rotation around z axis) in radians."""

    def __init__(self,
        *,
        x_bounds: builtins.float = ...,
        y_bounds: builtins.float = ...,
        z_bounds: builtins.float = ...,
        yaw_bounds: builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["x_bounds",b"x_bounds","y_bounds",b"y_bounds","yaw_bounds",b"yaw_bounds","z_bounds",b"z_bounds"]) -> None: ...
global___PoseBounds = PoseBounds

class AnchorHintUncertainty(google.protobuf.message.Message):
    """Controls how certain the user is of an anchor's pose. If left empty, a reasonable default will be chosen."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SE3_COVARIANCE_FIELD_NUMBER: builtins.int
    CONFIDENCE_BOUNDS_FIELD_NUMBER: builtins.int
    @property
    def se3_covariance(self) -> bosdyn.api.geometry_pb2.SE3Covariance:
        """A full 6x6 Gaussian covariance matrix representing uncertainty of an anchoring."""
        pass
    @property
    def confidence_bounds(self) -> global___PoseBounds:
        """Represents the 95 percent confidence interval on individual axes. This
        will be converted to a SE3Covariance internally by creating a diagonal
        matrix whose elements are informed by the confidence bounds.
        """
        pass
    def __init__(self,
        *,
        se3_covariance: typing.Optional[bosdyn.api.geometry_pb2.SE3Covariance] = ...,
        confidence_bounds: typing.Optional[global___PoseBounds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["confidence_bounds",b"confidence_bounds","se3_covariance",b"se3_covariance","uncertainty",b"uncertainty"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["confidence_bounds",b"confidence_bounds","se3_covariance",b"se3_covariance","uncertainty",b"uncertainty"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["uncertainty",b"uncertainty"]) -> typing.Optional[typing_extensions.Literal["se3_covariance","confidence_bounds"]]: ...
global___AnchorHintUncertainty = AnchorHintUncertainty

class WaypointAnchorHint(google.protobuf.message.Message):
    """Waypoints may be anchored to a particular seed frame. The user may request that a waypoint
    be anchored in a particular place with some Gaussian uncertainty.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    WAYPOINT_ANCHOR_FIELD_NUMBER: builtins.int
    SEED_TFORM_WAYPOINT_UNCERTAINTY_FIELD_NUMBER: builtins.int
    SEED_TFORM_WAYPOINT_CONSTRAINT_FIELD_NUMBER: builtins.int
    @property
    def waypoint_anchor(self) -> bosdyn.api.graph_nav.map_pb2.Anchor:
        """This is to be interpreted as the mean of a Gaussian distribution, representing
        the pose of the waypoint in the seed frame.
        """
        pass
    @property
    def seed_tform_waypoint_uncertainty(self) -> global___AnchorHintUncertainty:
        """This is the uncertainty of the anchor's pose in the seed frame.
        If left empty, a reasonable default uncertainty will be generated.
        """
        pass
    @property
    def seed_tform_waypoint_constraint(self) -> global___PoseBounds:
        """Normally, the optimizer will move the anchorings of waypoints based on context, to minimize the
        overall cost of the optimization problem. By providing a constraint on pose, the user can ensure
        that the anchors stay within a certain region in the seed frame.
        Leaving this empty will allow the optimizer to move the anchoring from the hint as far as it likes.
        """
        pass
    def __init__(self,
        *,
        waypoint_anchor: typing.Optional[bosdyn.api.graph_nav.map_pb2.Anchor] = ...,
        seed_tform_waypoint_uncertainty: typing.Optional[global___AnchorHintUncertainty] = ...,
        seed_tform_waypoint_constraint: typing.Optional[global___PoseBounds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["seed_tform_waypoint_constraint",b"seed_tform_waypoint_constraint","seed_tform_waypoint_uncertainty",b"seed_tform_waypoint_uncertainty","waypoint_anchor",b"waypoint_anchor"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["seed_tform_waypoint_constraint",b"seed_tform_waypoint_constraint","seed_tform_waypoint_uncertainty",b"seed_tform_waypoint_uncertainty","waypoint_anchor",b"waypoint_anchor"]) -> None: ...
global___WaypointAnchorHint = WaypointAnchorHint

class WorldObjectAnchorHint(google.protobuf.message.Message):
    """World objects (such as fiducials) may be anchored to a particular seed frame. The user may request that an object
    be anchored in a particular place with some Gaussian uncertainty.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OBJECT_ANCHOR_FIELD_NUMBER: builtins.int
    SEED_TFORM_OBJECT_UNCERTAINTY_FIELD_NUMBER: builtins.int
    SEED_TFORM_OBJECT_CONSTRAINT_FIELD_NUMBER: builtins.int
    @property
    def object_anchor(self) -> bosdyn.api.graph_nav.map_pb2.AnchoredWorldObject:
        """This is to be interpreted as the mean of a Gaussian distribution, representing
        the pose of the object in the seed frame.
        """
        pass
    @property
    def seed_tform_object_uncertainty(self) -> global___AnchorHintUncertainty:
        """This is the uncertainty of the anchor's pose in the seed frame.
        If left empty, a reasonable default uncertainty will be generated.
        """
        pass
    @property
    def seed_tform_object_constraint(self) -> global___PoseBounds:
        """Normally, the optimizer will move the anchorings of object based on context, to minimize the
        overall cost of the optimization problem. By providing a constraint on pose, the user can ensure
        that the anchors stay within a certain region in the seed frame.
        Leaving this empty will allow the optimizer to move the anchoring from the hint as far as it likes.
        """
        pass
    def __init__(self,
        *,
        object_anchor: typing.Optional[bosdyn.api.graph_nav.map_pb2.AnchoredWorldObject] = ...,
        seed_tform_object_uncertainty: typing.Optional[global___AnchorHintUncertainty] = ...,
        seed_tform_object_constraint: typing.Optional[global___PoseBounds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["object_anchor",b"object_anchor","seed_tform_object_constraint",b"seed_tform_object_constraint","seed_tform_object_uncertainty",b"seed_tform_object_uncertainty"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["object_anchor",b"object_anchor","seed_tform_object_constraint",b"seed_tform_object_constraint","seed_tform_object_uncertainty",b"seed_tform_object_uncertainty"]) -> None: ...
global___WorldObjectAnchorHint = WorldObjectAnchorHint

class AnchoringHint(google.protobuf.message.Message):
    """The user may assign a number of world objects and waypoints a guess at where they are in the seed frame.
    These hints will be respected by the ProcessAnchoringRequest.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    WAYPOINT_ANCHORS_FIELD_NUMBER: builtins.int
    WORLD_OBJECTS_FIELD_NUMBER: builtins.int
    @property
    def waypoint_anchors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___WaypointAnchorHint]:
        """List of waypoints and hints as to where they are in the seed frame."""
        pass
    @property
    def world_objects(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___WorldObjectAnchorHint]:
        """List of world objects and hints as to where they are in the seed frame."""
        pass
    def __init__(self,
        *,
        waypoint_anchors: typing.Optional[typing.Iterable[global___WaypointAnchorHint]] = ...,
        world_objects: typing.Optional[typing.Iterable[global___WorldObjectAnchorHint]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["waypoint_anchors",b"waypoint_anchors","world_objects",b"world_objects"]) -> None: ...
global___AnchoringHint = AnchoringHint

class ProcessAnchoringRequest(google.protobuf.message.Message):
    """Causes the server to optimize an existing anchoring, or generate a new anchoring for the map using the given parameters.
    In general, if parameters are not provided, reasonable defaults will be used.
    The new anchoring will be streamed back to the client, or modified on the server if desired.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Params(google.protobuf.message.Message):
        """Parameters for procesing an anchoring."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class OptimizerParams(google.protobuf.message.Message):
            """Parameters affecting the underlying optimizer."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            MAX_ITERS_FIELD_NUMBER: builtins.int
            MAX_TIME_SECONDS_FIELD_NUMBER: builtins.int
            @property
            def max_iters(self) -> google.protobuf.wrappers_pb2.Int32Value:
                """Maximum iterations of the optimizer to run."""
                pass
            @property
            def max_time_seconds(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """Maximum time the optimizer is allowed to run before giving up."""
                pass
            def __init__(self,
                *,
                max_iters: typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
                max_time_seconds: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["max_iters",b"max_iters","max_time_seconds",b"max_time_seconds"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["max_iters",b"max_iters","max_time_seconds",b"max_time_seconds"]) -> None: ...

        class MeasurementParams(google.protobuf.message.Message):
            """Parameters which affect the measurements the optimzier uses to process the anchoring."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            USE_KINEMATIC_ODOMETRY_FIELD_NUMBER: builtins.int
            USE_VISUAL_ODOMETRY_FIELD_NUMBER: builtins.int
            USE_GYROSCOPE_MEASUREMENTS_FIELD_NUMBER: builtins.int
            USE_LOOP_CLOSURES_FIELD_NUMBER: builtins.int
            USE_WORLD_OBJECTS_FIELD_NUMBER: builtins.int
            @property
            def use_kinematic_odometry(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, waypoints which share the same kinematic odometry
                frame will be constrained to one another using it.
                """
                pass
            @property
            def use_visual_odometry(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, waypoints which share the same visual odometry frame
                will be constrained to one another using it.
                """
                pass
            @property
            def use_gyroscope_measurements(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, waypoints will be constrained so that the apparent pose of the
                robot w.r.t the waypoint at the time of recording is consistent with gravity.
                """
                pass
            @property
            def use_loop_closures(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, edges which were created by topology processing via loop closures will
                be used as constraints.
                """
                pass
            @property
            def use_world_objects(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, world object measurements will be used to constrain waypoints to one another
                when those waypoints co-observe the same world object.
                """
                pass
            def __init__(self,
                *,
                use_kinematic_odometry: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                use_visual_odometry: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                use_gyroscope_measurements: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                use_loop_closures: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                use_world_objects: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["use_gyroscope_measurements",b"use_gyroscope_measurements","use_kinematic_odometry",b"use_kinematic_odometry","use_loop_closures",b"use_loop_closures","use_visual_odometry",b"use_visual_odometry","use_world_objects",b"use_world_objects"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["use_gyroscope_measurements",b"use_gyroscope_measurements","use_kinematic_odometry",b"use_kinematic_odometry","use_loop_closures",b"use_loop_closures","use_visual_odometry",b"use_visual_odometry","use_world_objects",b"use_world_objects"]) -> None: ...

        class Weights(google.protobuf.message.Message):
            """Relative weights to use for each of the optimizer's terms. These can be any positive value.
            If set to zero, a reasonable default will be used. In general, the higher the weight, the more
            the optimizer will care about that particular measurement.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            KINEMATIC_ODOMETRY_WEIGHT_FIELD_NUMBER: builtins.int
            VISUAL_ODOMETRY_WEIGHT_FIELD_NUMBER: builtins.int
            WORLD_OBJECT_WEIGHT_FIELD_NUMBER: builtins.int
            HINT_WEIGHT_FIELD_NUMBER: builtins.int
            GYROSCOPE_WEIGHT_FIELD_NUMBER: builtins.int
            LOOP_CLOSURE_WEIGHT_FIELD_NUMBER: builtins.int
            kinematic_odometry_weight: builtins.float
            visual_odometry_weight: builtins.float
            world_object_weight: builtins.float
            hint_weight: builtins.float
            gyroscope_weight: builtins.float
            loop_closure_weight: builtins.float
            def __init__(self,
                *,
                kinematic_odometry_weight: builtins.float = ...,
                visual_odometry_weight: builtins.float = ...,
                world_object_weight: builtins.float = ...,
                hint_weight: builtins.float = ...,
                gyroscope_weight: builtins.float = ...,
                loop_closure_weight: builtins.float = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["gyroscope_weight",b"gyroscope_weight","hint_weight",b"hint_weight","kinematic_odometry_weight",b"kinematic_odometry_weight","loop_closure_weight",b"loop_closure_weight","visual_odometry_weight",b"visual_odometry_weight","world_object_weight",b"world_object_weight"]) -> None: ...

        OPTIMIZER_PARAMS_FIELD_NUMBER: builtins.int
        MEASUREMENT_PARAMS_FIELD_NUMBER: builtins.int
        WEIGHTS_FIELD_NUMBER: builtins.int
        OPTIMIZE_EXISTING_ANCHORING_FIELD_NUMBER: builtins.int
        GRAVITY_EWRT_SEED_FIELD_NUMBER: builtins.int
        @property
        def optimizer_params(self) -> global___ProcessAnchoringRequest.Params.OptimizerParams: ...
        @property
        def measurement_params(self) -> global___ProcessAnchoringRequest.Params.MeasurementParams: ...
        @property
        def weights(self) -> global___ProcessAnchoringRequest.Params.Weights: ...
        @property
        def optimize_existing_anchoring(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """If true, the anchoring which already exists on the server will be used as the initial
            guess for the optimizer. Otherwise, a new anchoring will be generated for every waypoint
            which doesn't have a value passed in through initial_hint. If no hint is provided,
            and this value is false, every waypoint will be given a starting anchoring based on
            the oldest waypoint in the map.
            """
            pass
        @property
        def gravity_ewrt_seed(self) -> bosdyn.api.geometry_pb2.Vec3:
            """The optimizer will try to keep the orientation of waypoints consistent with gravity.
            If provided, this is the gravity direction expressed with respect to the seed. This
            will be interpreted as a unit vector. If not filled out, a default of (0, 0, -1) will be
            used.
            """
            pass
        def __init__(self,
            *,
            optimizer_params: typing.Optional[global___ProcessAnchoringRequest.Params.OptimizerParams] = ...,
            measurement_params: typing.Optional[global___ProcessAnchoringRequest.Params.MeasurementParams] = ...,
            weights: typing.Optional[global___ProcessAnchoringRequest.Params.Weights] = ...,
            optimize_existing_anchoring: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            gravity_ewrt_seed: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["gravity_ewrt_seed",b"gravity_ewrt_seed","measurement_params",b"measurement_params","optimize_existing_anchoring",b"optimize_existing_anchoring","optimizer_params",b"optimizer_params","weights",b"weights"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["gravity_ewrt_seed",b"gravity_ewrt_seed","measurement_params",b"measurement_params","optimize_existing_anchoring",b"optimize_existing_anchoring","optimizer_params",b"optimizer_params","weights",b"weights"]) -> None: ...

    HEADER_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    INITIAL_HINT_FIELD_NUMBER: builtins.int
    MODIFY_ANCHORING_ON_SERVER_FIELD_NUMBER: builtins.int
    STREAM_INTERMEDIATE_RESULTS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Standard request header."""
        pass
    @property
    def params(self) -> global___ProcessAnchoringRequest.Params: ...
    @property
    def initial_hint(self) -> global___AnchoringHint:
        """Initial guess at some number of waypoints and world objects and their anchorings."""
        pass
    modify_anchoring_on_server: builtins.bool
    """If true, the map currently uploaded to the server will have its anchoring modified.
    Otherwise, the user is expected to re-upload the anchoring.
    """

    stream_intermediate_results: builtins.bool
    """If true, the anchoring will be streamed back to the user after every iteration.
    This is useful for debug visualization.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        params: typing.Optional[global___ProcessAnchoringRequest.Params] = ...,
        initial_hint: typing.Optional[global___AnchoringHint] = ...,
        modify_anchoring_on_server: builtins.bool = ...,
        stream_intermediate_results: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","initial_hint",b"initial_hint","params",b"params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","initial_hint",b"initial_hint","modify_anchoring_on_server",b"modify_anchoring_on_server","params",b"params","stream_intermediate_results",b"stream_intermediate_results"]) -> None: ...
global___ProcessAnchoringRequest = ProcessAnchoringRequest

class ProcessAnchoringResponse(google.protobuf.message.Message):
    """Streamed response from the ProcessAnchoringRequest. These will be streamed until optimization is complete.
    New anchorings will be streamed as they become available.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ProcessAnchoringResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: ProcessAnchoringResponse._Status.ValueType  # 0
        """Programming error."""

        STATUS_OK: ProcessAnchoringResponse._Status.ValueType  # 1
        """Success."""

        STATUS_MISSING_WAYPOINT_SNAPSHOTS: ProcessAnchoringResponse._Status.ValueType  # 2
        """Not all of the waypoint snapshots exist on the server. Upload them to continue."""

        STATUS_INVALID_GRAPH: ProcessAnchoringResponse._Status.ValueType  # 3
        """The graph is invalid topologically, for example containing missing waypoints referenced by edges."""

        STATUS_OPTIMIZATION_FAILURE: ProcessAnchoringResponse._Status.ValueType  # 4
        """The optimization failed due to local minima or an ill-conditioned problem definition."""

        STATUS_INVALID_PARAMS: ProcessAnchoringResponse._Status.ValueType  # 5
        """The parameters passed to the optimizer do not make sense (e.g negative weights)."""

        STATUS_CONSTRAINT_VIOLATION: ProcessAnchoringResponse._Status.ValueType  # 6
        """One or more anchors were moved outside of the desired constraints."""

        STATUS_MAX_ITERATIONS: ProcessAnchoringResponse._Status.ValueType  # 7
        """The optimizer reached the maximum number of iterations before converging."""

        STATUS_MAX_TIME: ProcessAnchoringResponse._Status.ValueType  # 8
        """The optimizer timed out before converging."""

        STATUS_INVALID_HINTS: ProcessAnchoringResponse._Status.ValueType  # 9
        """One or more of the hints passed in to the optimizer are invalid (do not correspond to real waypoints or objects)."""

        STATUS_MAP_MODIFIED_DURING_PROCESSING: ProcessAnchoringResponse._Status.ValueType  # 10
        """Tried to write the anchoring after processing, but another client may have modified the map. Try again."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: ProcessAnchoringResponse.Status.ValueType  # 0
    """Programming error."""

    STATUS_OK: ProcessAnchoringResponse.Status.ValueType  # 1
    """Success."""

    STATUS_MISSING_WAYPOINT_SNAPSHOTS: ProcessAnchoringResponse.Status.ValueType  # 2
    """Not all of the waypoint snapshots exist on the server. Upload them to continue."""

    STATUS_INVALID_GRAPH: ProcessAnchoringResponse.Status.ValueType  # 3
    """The graph is invalid topologically, for example containing missing waypoints referenced by edges."""

    STATUS_OPTIMIZATION_FAILURE: ProcessAnchoringResponse.Status.ValueType  # 4
    """The optimization failed due to local minima or an ill-conditioned problem definition."""

    STATUS_INVALID_PARAMS: ProcessAnchoringResponse.Status.ValueType  # 5
    """The parameters passed to the optimizer do not make sense (e.g negative weights)."""

    STATUS_CONSTRAINT_VIOLATION: ProcessAnchoringResponse.Status.ValueType  # 6
    """One or more anchors were moved outside of the desired constraints."""

    STATUS_MAX_ITERATIONS: ProcessAnchoringResponse.Status.ValueType  # 7
    """The optimizer reached the maximum number of iterations before converging."""

    STATUS_MAX_TIME: ProcessAnchoringResponse.Status.ValueType  # 8
    """The optimizer timed out before converging."""

    STATUS_INVALID_HINTS: ProcessAnchoringResponse.Status.ValueType  # 9
    """One or more of the hints passed in to the optimizer are invalid (do not correspond to real waypoints or objects)."""

    STATUS_MAP_MODIFIED_DURING_PROCESSING: ProcessAnchoringResponse.Status.ValueType  # 10
    """Tried to write the anchoring after processing, but another client may have modified the map. Try again."""


    HEADER_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    WAYPOINT_RESULTS_FIELD_NUMBER: builtins.int
    WORLD_OBJECT_RESULTS_FIELD_NUMBER: builtins.int
    ANCHORING_ON_SERVER_WAS_MODIFIED_FIELD_NUMBER: builtins.int
    ITERATION_FIELD_NUMBER: builtins.int
    COST_FIELD_NUMBER: builtins.int
    FINAL_ITERATION_FIELD_NUMBER: builtins.int
    VIOLATED_WAYPOINT_CONSTRAINTS_FIELD_NUMBER: builtins.int
    VIOLATED_OBJECT_CONSTRAINTS_FIELD_NUMBER: builtins.int
    MISSING_SNAPSHOT_IDS_FIELD_NUMBER: builtins.int
    MISSING_WAYPOINT_IDS_FIELD_NUMBER: builtins.int
    INVALID_HINTS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader: ...
    status: global___ProcessAnchoringResponse.Status.ValueType
    @property
    def waypoint_results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.graph_nav.map_pb2.Anchor]:
        """Contains new anchorings for waypoint(s) processed by the server.
        These will be streamed back to the user as they become available.
        """
        pass
    @property
    def world_object_results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.graph_nav.map_pb2.AnchoredWorldObject]:
        """Contains new anchorings for object(s) (e.g april tags) processed by the server.
        These will be streamed back to the user as they become available
        """
        pass
    anchoring_on_server_was_modified: builtins.bool
    """If modify_anchoring_on_server was set to true in the request, then the anchoring currently on the server
    was modified using map processing. If this is set to false, then either an error occurred during
    processing, or modify_anchoring_on_server was set to false in the request.
    When anchoring_on_server_was_modified is set to false, the client is expected to upload the results
    back to the server to commit the changes.
    """

    iteration: builtins.int
    """The current optimizer iteration that produced these data."""

    cost: builtins.float
    """The current nonlinear optimization cost."""

    final_iteration: builtins.bool
    """If true, this is the result of the final iteration of optimization.
    This will always be true when stream_intermediate_results in the request is false.
    """

    @property
    def violated_waypoint_constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___WaypointAnchorHint]:
        """On failure due to constraint violation, these hints were violated by the optimization.
        Try increasing the pose bounds on the constraints of these hints.
        """
        pass
    @property
    def violated_object_constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___WorldObjectAnchorHint]:
        """On failure due to constraint violation, these hints were violated by the optimization.
        Try increasing the pose bounds on the constraints of these hints.
        """
        pass
    @property
    def missing_snapshot_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """When there are missing waypoint snapshots, these are the IDs of the missing snapshots.
        Upload them to continue.
        """
        pass
    @property
    def missing_waypoint_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """When there are missing waypoints, these are the IDs of the missing waypoints. Upload them
        to continue.
        """
        pass
    @property
    def invalid_hints(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Unorganized list of waypoints and object IDs which were invalid (missing from the map)."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        status: global___ProcessAnchoringResponse.Status.ValueType = ...,
        waypoint_results: typing.Optional[typing.Iterable[bosdyn.api.graph_nav.map_pb2.Anchor]] = ...,
        world_object_results: typing.Optional[typing.Iterable[bosdyn.api.graph_nav.map_pb2.AnchoredWorldObject]] = ...,
        anchoring_on_server_was_modified: builtins.bool = ...,
        iteration: builtins.int = ...,
        cost: builtins.float = ...,
        final_iteration: builtins.bool = ...,
        violated_waypoint_constraints: typing.Optional[typing.Iterable[global___WaypointAnchorHint]] = ...,
        violated_object_constraints: typing.Optional[typing.Iterable[global___WorldObjectAnchorHint]] = ...,
        missing_snapshot_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        missing_waypoint_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        invalid_hints: typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["anchoring_on_server_was_modified",b"anchoring_on_server_was_modified","cost",b"cost","final_iteration",b"final_iteration","header",b"header","invalid_hints",b"invalid_hints","iteration",b"iteration","missing_snapshot_ids",b"missing_snapshot_ids","missing_waypoint_ids",b"missing_waypoint_ids","status",b"status","violated_object_constraints",b"violated_object_constraints","violated_waypoint_constraints",b"violated_waypoint_constraints","waypoint_results",b"waypoint_results","world_object_results",b"world_object_results"]) -> None: ...
global___ProcessAnchoringResponse = ProcessAnchoringResponse
