"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.geometry_pb2
import bosdyn.api.image_pb2
import bosdyn.api.local_grid_pb2
import bosdyn.api.point_cloud_pb2
import bosdyn.api.robot_state_pb2
import bosdyn.api.spot.robot_command_pb2
import bosdyn.api.stairs_pb2
import bosdyn.api.world_object_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _AnnotationState:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _AnnotationStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AnnotationState.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ANNOTATION_STATE_UNKNOWN: _AnnotationState.ValueType  # 0
    """No assertions made about this annotation."""

    ANNOTATION_STATE_SET: _AnnotationState.ValueType  # 1
    """This annotation and all of its fields have been deliberately set."""

    ANNOTATION_STATE_NONE: _AnnotationState.ValueType  # 2
    """This annotation has been deliberately set to "no annotation" -- any subfields are unset."""

class AnnotationState(_AnnotationState, metaclass=_AnnotationStateEnumTypeWrapper):
    """Indicator of whether or not the waypoint and edge annotations are complete and filled out."""
    pass

ANNOTATION_STATE_UNKNOWN: AnnotationState.ValueType  # 0
"""No assertions made about this annotation."""

ANNOTATION_STATE_SET: AnnotationState.ValueType  # 1
"""This annotation and all of its fields have been deliberately set."""

ANNOTATION_STATE_NONE: AnnotationState.ValueType  # 2
"""This annotation has been deliberately set to "no annotation" -- any subfields are unset."""

global___AnnotationState = AnnotationState


class Waypoint(google.protobuf.message.Message):
    """A base element of the graph nav map. A waypoint consists of a reference frame, a name,
    a unique ID, annotations, and sensor data.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _WaypointSource:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _WaypointSourceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Waypoint._WaypointSource.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        WAYPOINT_SOURCE_UNKNOWN: Waypoint._WaypointSource.ValueType  # 0
        WAYPOINT_SOURCE_ROBOT_PATH: Waypoint._WaypointSource.ValueType  # 1
        """Waypoints from the robot's location during recording."""

        WAYPOINT_SOURCE_USER_REQUEST: Waypoint._WaypointSource.ValueType  # 2
        """Waypoints with user-requested placement."""

        WAYPOINT_SOURCE_ALTERNATE_ROUTE_FINDING: Waypoint._WaypointSource.ValueType  # 3
        """Waypoints that may help find alternate routes."""

    class WaypointSource(_WaypointSource, metaclass=_WaypointSourceEnumTypeWrapper):
        pass

    WAYPOINT_SOURCE_UNKNOWN: Waypoint.WaypointSource.ValueType  # 0
    WAYPOINT_SOURCE_ROBOT_PATH: Waypoint.WaypointSource.ValueType  # 1
    """Waypoints from the robot's location during recording."""

    WAYPOINT_SOURCE_USER_REQUEST: Waypoint.WaypointSource.ValueType  # 2
    """Waypoints with user-requested placement."""

    WAYPOINT_SOURCE_ALTERNATE_ROUTE_FINDING: Waypoint.WaypointSource.ValueType  # 3
    """Waypoints that may help find alternate routes."""


    class Annotations(google.protobuf.message.Message):
        """Annotations understood by BostonDynamics systems."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class LocalizeRegion(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            class Default(google.protobuf.message.Message):
                """Use the default region to localize in."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                def __init__(self,
                    ) -> None: ...

            class Empty(google.protobuf.message.Message):
                """Do not localize to this waypoint."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                def __init__(self,
                    ) -> None: ...

            class Circle2D(google.protobuf.message.Message):
                """Indicates the number of meters away we can be from this waypoint we can be before scan
                matching.
                - If zero, the default value is used.
                - If less than zero, no scan matching will be performed at this waypoint.
                - If greater than zero, scan matching will only be performed if the robot is at most this
                  far away from the waypoint.
                Distance calculation is done in the 2d plane with respect to the waypoint.
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor
                DIST_2D_FIELD_NUMBER: builtins.int
                dist_2d: builtins.float
                """meters."""

                def __init__(self,
                    *,
                    dist_2d: builtins.float = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["dist_2d",b"dist_2d"]) -> None: ...

            STATE_FIELD_NUMBER: builtins.int
            DEFAULT_REGION_FIELD_NUMBER: builtins.int
            EMPTY_FIELD_NUMBER: builtins.int
            CIRCLE_FIELD_NUMBER: builtins.int
            state: global___AnnotationState.ValueType
            """Check this before reading other fields."""

            @property
            def default_region(self) -> global___Waypoint.Annotations.LocalizeRegion.Default:
                """Oneof field that describes the waypoint's location as a default region (no special features/traits)."""
                pass
            @property
            def empty(self) -> global___Waypoint.Annotations.LocalizeRegion.Empty:
                """Oneof field that describes the waypoint's location as a empty/featureless region."""
                pass
            @property
            def circle(self) -> global___Waypoint.Annotations.LocalizeRegion.Circle2D:
                """Oneof field that describes the waypoint's location as a circular region."""
                pass
            def __init__(self,
                *,
                state: global___AnnotationState.ValueType = ...,
                default_region: typing.Optional[global___Waypoint.Annotations.LocalizeRegion.Default] = ...,
                empty: typing.Optional[global___Waypoint.Annotations.LocalizeRegion.Empty] = ...,
                circle: typing.Optional[global___Waypoint.Annotations.LocalizeRegion.Circle2D] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["circle",b"circle","default_region",b"default_region","empty",b"empty","region",b"region"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["circle",b"circle","default_region",b"default_region","empty",b"empty","region",b"region","state",b"state"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["region",b"region"]) -> typing.Optional[typing_extensions.Literal["default_region","empty","circle"]]: ...

        NAME_FIELD_NUMBER: builtins.int
        CREATION_TIME_FIELD_NUMBER: builtins.int
        ICP_VARIANCE_FIELD_NUMBER: builtins.int
        SCAN_MATCH_REGION_FIELD_NUMBER: builtins.int
        WAYPOINT_SOURCE_FIELD_NUMBER: builtins.int
        name: typing.Text
        """Human-friendly name of the waypoint. For example, "Kitchen Fridge" """

        @property
        def creation_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The time that the waypoint was created while recording a map."""
            pass
        @property
        def icp_variance(self) -> bosdyn.api.geometry_pb2.SE3Covariance:
            """Estimate of the variance of ICP when performed at this waypoint, collected at record time."""
            pass
        @property
        def scan_match_region(self) -> global___Waypoint.Annotations.LocalizeRegion:
            """Options for how to localize to a waypoint (if at all)."""
            pass
        waypoint_source: global___Waypoint.WaypointSource.ValueType
        """How this waypoint was made."""

        def __init__(self,
            *,
            name: typing.Text = ...,
            creation_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            icp_variance: typing.Optional[bosdyn.api.geometry_pb2.SE3Covariance] = ...,
            scan_match_region: typing.Optional[global___Waypoint.Annotations.LocalizeRegion] = ...,
            waypoint_source: global___Waypoint.WaypointSource.ValueType = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["creation_time",b"creation_time","icp_variance",b"icp_variance","scan_match_region",b"scan_match_region"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["creation_time",b"creation_time","icp_variance",b"icp_variance","name",b"name","scan_match_region",b"scan_match_region","waypoint_source",b"waypoint_source"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    SNAPSHOT_ID_FIELD_NUMBER: builtins.int
    WAYPOINT_TFORM_KO_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    id: typing.Text
    """Identifier of the waypoint. Unique across all maps.
    This identifier does not have to be updated when its fields change.
    """

    snapshot_id: typing.Text
    """Identifier of this waypoint's Snapshot data."""

    @property
    def waypoint_tform_ko(self) -> bosdyn.api.geometry_pb2.SE3Pose:
        """Transform from the KO frame (at time of recording) to the waypoint."""
        pass
    @property
    def annotations(self) -> global___Waypoint.Annotations:
        """Annotations specific to the current waypoint."""
        pass
    def __init__(self,
        *,
        id: typing.Text = ...,
        snapshot_id: typing.Text = ...,
        waypoint_tform_ko: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
        annotations: typing.Optional[global___Waypoint.Annotations] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["annotations",b"annotations","waypoint_tform_ko",b"waypoint_tform_ko"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotations",b"annotations","id",b"id","snapshot_id",b"snapshot_id","waypoint_tform_ko",b"waypoint_tform_ko"]) -> None: ...
global___Waypoint = Waypoint

class WaypointSnapshot(google.protobuf.message.Message):
    """Relevant data collected at the waypoint.
    May be used for localization or automatically generating annotations, for example.
    Should be indexed by a waypoint's "snapshot_id" field.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ID_FIELD_NUMBER: builtins.int
    IMAGES_FIELD_NUMBER: builtins.int
    POINT_CLOUD_FIELD_NUMBER: builtins.int
    OBJECTS_FIELD_NUMBER: builtins.int
    ROBOT_STATE_FIELD_NUMBER: builtins.int
    ROBOT_LOCAL_GRIDS_FIELD_NUMBER: builtins.int
    IS_POINT_CLOUD_PROCESSED_FIELD_NUMBER: builtins.int
    VERSION_ID_FIELD_NUMBER: builtins.int
    HAS_REMOTE_POINT_CLOUD_SENSOR_FIELD_NUMBER: builtins.int
    id: typing.Text
    """Identifier of this snapshot.
    Snapshots are immutable -- if any of the other fields change, this ID must also change.
    """

    @property
    def images(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.image_pb2.ImageResponse]:
        """Any images captured at the waypoint."""
        pass
    @property
    def point_cloud(self) -> bosdyn.api.point_cloud_pb2.PointCloud:
        """Aggregated point cloud data."""
        pass
    @property
    def objects(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.world_object_pb2.WorldObject]:
        """Perception objects seen at snapshot time."""
        pass
    @property
    def robot_state(self) -> bosdyn.api.robot_state_pb2.RobotState:
        """Full robot state during snapshot."""
        pass
    @property
    def robot_local_grids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.local_grid_pb2.LocalGrid]:
        """Robot grid data."""
        pass
    is_point_cloud_processed: builtins.bool
    """If true, the point cloud of this snapshot has been processed."""

    version_id: typing.Text
    """If this snapshot is a modified version of the raw snapshot with the given ID (for example, it has been processed),
    a new unique ID will we assigned to this field. If the field is empty, this is the raw version of the snapshot.
    """

    has_remote_point_cloud_sensor: builtins.bool
    """If true, the point cloud contains data from a remote point cloud service,
    such as LIDAR.
    """

    def __init__(self,
        *,
        id: typing.Text = ...,
        images: typing.Optional[typing.Iterable[bosdyn.api.image_pb2.ImageResponse]] = ...,
        point_cloud: typing.Optional[bosdyn.api.point_cloud_pb2.PointCloud] = ...,
        objects: typing.Optional[typing.Iterable[bosdyn.api.world_object_pb2.WorldObject]] = ...,
        robot_state: typing.Optional[bosdyn.api.robot_state_pb2.RobotState] = ...,
        robot_local_grids: typing.Optional[typing.Iterable[bosdyn.api.local_grid_pb2.LocalGrid]] = ...,
        is_point_cloud_processed: builtins.bool = ...,
        version_id: typing.Text = ...,
        has_remote_point_cloud_sensor: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["point_cloud",b"point_cloud","robot_state",b"robot_state"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["has_remote_point_cloud_sensor",b"has_remote_point_cloud_sensor","id",b"id","images",b"images","is_point_cloud_processed",b"is_point_cloud_processed","objects",b"objects","point_cloud",b"point_cloud","robot_local_grids",b"robot_local_grids","robot_state",b"robot_state","version_id",b"version_id"]) -> None: ...
global___WaypointSnapshot = WaypointSnapshot

class Edge(google.protobuf.message.Message):
    """A base element of the graph nav map. Edges consist of a directed edge from one
    waypoint to another and a transform that estimates the relationship in 3D space
    between the two waypoints.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _EdgeSource:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _EdgeSourceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Edge._EdgeSource.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        EDGE_SOURCE_UNKNOWN: Edge._EdgeSource.ValueType  # 0
        EDGE_SOURCE_ODOMETRY: Edge._EdgeSource.ValueType  # 1
        """Edges with transforms from odometry."""

        EDGE_SOURCE_SMALL_LOOP_CLOSURE: Edge._EdgeSource.ValueType  # 2
        """Edges with transforms from a short chain of other edges."""

        EDGE_SOURCE_FIDUCIAL_LOOP_CLOSURE: Edge._EdgeSource.ValueType  # 3
        """Edges with transforms from multiple fiducial observations."""

        EDGE_SOURCE_ALTERNATE_ROUTE_FINDING: Edge._EdgeSource.ValueType  # 4
        """Edges that may help find alternate routes."""

        EDGE_SOURCE_USER_REQUEST: Edge._EdgeSource.ValueType  # 5
        """Created via a CreateEdge RPC."""

    class EdgeSource(_EdgeSource, metaclass=_EdgeSourceEnumTypeWrapper):
        pass

    EDGE_SOURCE_UNKNOWN: Edge.EdgeSource.ValueType  # 0
    EDGE_SOURCE_ODOMETRY: Edge.EdgeSource.ValueType  # 1
    """Edges with transforms from odometry."""

    EDGE_SOURCE_SMALL_LOOP_CLOSURE: Edge.EdgeSource.ValueType  # 2
    """Edges with transforms from a short chain of other edges."""

    EDGE_SOURCE_FIDUCIAL_LOOP_CLOSURE: Edge.EdgeSource.ValueType  # 3
    """Edges with transforms from multiple fiducial observations."""

    EDGE_SOURCE_ALTERNATE_ROUTE_FINDING: Edge.EdgeSource.ValueType  # 4
    """Edges that may help find alternate routes."""

    EDGE_SOURCE_USER_REQUEST: Edge.EdgeSource.ValueType  # 5
    """Created via a CreateEdge RPC."""


    class Id(google.protobuf.message.Message):
        """An edge is uniquely identified by the waypoints it connects.
        Two waypoints will only ever be connected by a single edge.
        That edge is traversable in either direction.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        FROM_WAYPOINT_FIELD_NUMBER: builtins.int
        TO_WAYPOINT_FIELD_NUMBER: builtins.int
        from_waypoint: typing.Text
        """Identifier of the "from" waypoint."""

        to_waypoint: typing.Text
        """Identifier of the "to" waypoint."""

        def __init__(self,
            *,
            from_waypoint: typing.Text = ...,
            to_waypoint: typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["from_waypoint",b"from_waypoint","to_waypoint",b"to_waypoint"]) -> None: ...

    class Annotations(google.protobuf.message.Message):
        """Annotations understood by BostonDynamics systems."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _DirectionConstraint:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _DirectionConstraintEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Edge.Annotations._DirectionConstraint.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            DIRECTION_CONSTRAINT_UNKNOWN: Edge.Annotations._DirectionConstraint.ValueType  # 0
            """We don't know if there are direction constraints."""

            DIRECTION_CONSTRAINT_NO_TURN: Edge.Annotations._DirectionConstraint.ValueType  # 1
            """The robot must not turn while walking the edge, but can face either waypoint."""

            DIRECTION_CONSTRAINT_FORWARD: Edge.Annotations._DirectionConstraint.ValueType  # 2
            """Robot should walk the edge face-first."""

            DIRECTION_CONSTRAINT_REVERSE: Edge.Annotations._DirectionConstraint.ValueType  # 3
            """Robot should walk the edge rear-first."""

            DIRECTION_CONSTRAINT_NONE: Edge.Annotations._DirectionConstraint.ValueType  # 4
            """No constraints on which way the robot faces."""

        class DirectionConstraint(_DirectionConstraint, metaclass=_DirectionConstraintEnumTypeWrapper):
            pass

        DIRECTION_CONSTRAINT_UNKNOWN: Edge.Annotations.DirectionConstraint.ValueType  # 0
        """We don't know if there are direction constraints."""

        DIRECTION_CONSTRAINT_NO_TURN: Edge.Annotations.DirectionConstraint.ValueType  # 1
        """The robot must not turn while walking the edge, but can face either waypoint."""

        DIRECTION_CONSTRAINT_FORWARD: Edge.Annotations.DirectionConstraint.ValueType  # 2
        """Robot should walk the edge face-first."""

        DIRECTION_CONSTRAINT_REVERSE: Edge.Annotations.DirectionConstraint.ValueType  # 3
        """Robot should walk the edge rear-first."""

        DIRECTION_CONSTRAINT_NONE: Edge.Annotations.DirectionConstraint.ValueType  # 4
        """No constraints on which way the robot faces."""


        class StairData(google.protobuf.message.Message):
            """Defines any parameters of the stairs"""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            STATE_FIELD_NUMBER: builtins.int
            STRAIGHT_STAIRCASE_FIELD_NUMBER: builtins.int
            state: global___AnnotationState.ValueType
            """Check this before reading other fields."""

            @property
            def straight_staircase(self) -> bosdyn.api.stairs_pb2.StraightStaircase:
                """ Parameters describing a straight staircase."""
                pass
            def __init__(self,
                *,
                state: global___AnnotationState.ValueType = ...,
                straight_staircase: typing.Optional[bosdyn.api.stairs_pb2.StraightStaircase] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["straight_staircase",b"straight_staircase"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["state",b"state","straight_staircase",b"straight_staircase"]) -> None: ...

        VEL_LIMIT_FIELD_NUMBER: builtins.int
        STAIRS_FIELD_NUMBER: builtins.int
        DIRECTION_CONSTRAINT_FIELD_NUMBER: builtins.int
        REQUIRE_ALIGNMENT_FIELD_NUMBER: builtins.int
        FLAT_GROUND_FIELD_NUMBER: builtins.int
        GROUND_MU_HINT_FIELD_NUMBER: builtins.int
        GRATED_FLOOR_FIELD_NUMBER: builtins.int
        OVERRIDE_MOBILITY_PARAMS_FIELD_NUMBER: builtins.int
        MOBILITY_PARAMS_FIELD_NUMBER: builtins.int
        COST_FIELD_NUMBER: builtins.int
        EDGE_SOURCE_FIELD_NUMBER: builtins.int
        DISABLE_ALTERNATE_ROUTE_FINDING_FIELD_NUMBER: builtins.int
        @property
        def vel_limit(self) -> bosdyn.api.geometry_pb2.SE2VelocityLimit:
            """Velocity limits to use while traversing the edge.
            These are maxima and minima, NOT target speeds.
            NOTE: as of 2.4 this is deprecated. Please use mobility_params.vel_limit.
            """
            pass
        @property
        def stairs(self) -> global___Edge.Annotations.StairData:
            """Stairs information/parameters specific to the edge."""
            pass
        direction_constraint: global___Edge.Annotations.DirectionConstraint.ValueType
        """Direction constraints for how the robot must move and the directions it can face
        when traversing the edge.
        """

        @property
        def require_alignment(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """If true, the robot must be aligned with the edge in yaw before traversing it."""
            pass
        @property
        def flat_ground(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """If true, the edge crosses flat ground and the robot shouldn't try to climb over obstacles."""
            pass
        @property
        def ground_mu_hint(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Terrain coefficient of friction user hint. This value must be postive and will clamped if
            necessary on the robot side. Best suggested values lie in the range between 0.4 and 0.8
            (which is the robot's default.)
            WARNING: deprecated as of 2.1. Use mobility_params instead, which includes ground_mu_hint
            as part of the terrain_params.
            """
            pass
        @property
        def grated_floor(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """If true, the edge crosses over grated metal. This changes some parameters of the robot's
            perception system to allow it to see grated floors bettter.
            WARNING: deprecated as of 2.1. Use mobility_params instead, which includes grated_floor
            as part of the terrain_params.
            """
            pass
        @property
        def override_mobility_params(self) -> google.protobuf.field_mask_pb2.FieldMask:
            """Overrides the following fields of the mobility parameters to whatever is
            stored in the map. For example, if this FieldMask contains "stair_hint" and
            "terrain_params.enable_grated_floor", then the map will be
            annotated with "stair_hint" and "enable_grated_floor" settings. An empty FieldMask means all fields are active
            annotations. Note that the more conservative of the velocity limit stored in the mobility parameters and the
            TravelParams of the entire route will be used for this edge (regardless of what override_mobility_params says).
            """
            pass
        @property
        def mobility_params(self) -> bosdyn.api.spot.robot_command_pb2.MobilityParams:
            """Contains terrain parameters, swing height, obstacle avoidance parameters, etc.
            When the robot crosses this edge, it will use the mobility parameters here.
            """
            pass
        @property
        def cost(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Assign edges a cost; used when finding the "shortest" (lowest cost) path."""
            pass
        edge_source: global___Edge.EdgeSource.ValueType
        """How this edge was made."""

        disable_alternate_route_finding: builtins.bool
        """If true, disables alternate-route-finding for this edge."""

        def __init__(self,
            *,
            vel_limit: typing.Optional[bosdyn.api.geometry_pb2.SE2VelocityLimit] = ...,
            stairs: typing.Optional[global___Edge.Annotations.StairData] = ...,
            direction_constraint: global___Edge.Annotations.DirectionConstraint.ValueType = ...,
            require_alignment: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            flat_ground: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            ground_mu_hint: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            grated_floor: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            override_mobility_params: typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
            mobility_params: typing.Optional[bosdyn.api.spot.robot_command_pb2.MobilityParams] = ...,
            cost: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            edge_source: global___Edge.EdgeSource.ValueType = ...,
            disable_alternate_route_finding: builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["cost",b"cost","flat_ground",b"flat_ground","grated_floor",b"grated_floor","ground_mu_hint",b"ground_mu_hint","mobility_params",b"mobility_params","override_mobility_params",b"override_mobility_params","require_alignment",b"require_alignment","stairs",b"stairs","vel_limit",b"vel_limit"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["cost",b"cost","direction_constraint",b"direction_constraint","disable_alternate_route_finding",b"disable_alternate_route_finding","edge_source",b"edge_source","flat_ground",b"flat_ground","grated_floor",b"grated_floor","ground_mu_hint",b"ground_mu_hint","mobility_params",b"mobility_params","override_mobility_params",b"override_mobility_params","require_alignment",b"require_alignment","stairs",b"stairs","vel_limit",b"vel_limit"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    SNAPSHOT_ID_FIELD_NUMBER: builtins.int
    FROM_TFORM_TO_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> global___Edge.Id:
        """Identifier of this Edge.
        Edges are mutable -- the identifier does not have to be updated when other fields change.
        """
        pass
    snapshot_id: typing.Text
    """Identifier of this edge's Snapshot data."""

    @property
    def from_tform_to(self) -> bosdyn.api.geometry_pb2.SE3Pose:
        """Describes the transform between the "from" waypoint and the "to" waypoint."""
        pass
    @property
    def annotations(self) -> global___Edge.Annotations:
        """Annotations specific to the current edge."""
        pass
    def __init__(self,
        *,
        id: typing.Optional[global___Edge.Id] = ...,
        snapshot_id: typing.Text = ...,
        from_tform_to: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
        annotations: typing.Optional[global___Edge.Annotations] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["annotations",b"annotations","from_tform_to",b"from_tform_to","id",b"id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotations",b"annotations","from_tform_to",b"from_tform_to","id",b"id","snapshot_id",b"snapshot_id"]) -> None: ...
global___Edge = Edge

class EdgeSnapshot(google.protobuf.message.Message):
    """Relevant data collected along the edge.
    May be used for automatically generating annotations, for example.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Stance(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TIMESTAMP_FIELD_NUMBER: builtins.int
        FOOT_STATES_FIELD_NUMBER: builtins.int
        KO_TFORM_BODY_FIELD_NUMBER: builtins.int
        VISION_TFORM_BODY_FIELD_NUMBER: builtins.int
        PLANAR_GROUND_FIELD_NUMBER: builtins.int
        @property
        def timestamp(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """Timestamp of the stance."""
            pass
        @property
        def foot_states(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.robot_state_pb2.FootState]:
            """List of all the foot positions for a single stance."""
            pass
        @property
        def ko_tform_body(self) -> bosdyn.api.geometry_pb2.SE3Pose:
            """KO Body position corresponding to this stance."""
            pass
        @property
        def vision_tform_body(self) -> bosdyn.api.geometry_pb2.SE3Pose:
            """Vision Body position corresponding to this stance."""
            pass
        @property
        def planar_ground(self) -> google.protobuf.wrappers_pb2.BoolValue:
            """Does this stance correspond to a planar ground region."""
            pass
        def __init__(self,
            *,
            timestamp: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            foot_states: typing.Optional[typing.Iterable[bosdyn.api.robot_state_pb2.FootState]] = ...,
            ko_tform_body: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
            vision_tform_body: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
            planar_ground: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["ko_tform_body",b"ko_tform_body","planar_ground",b"planar_ground","timestamp",b"timestamp","vision_tform_body",b"vision_tform_body"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["foot_states",b"foot_states","ko_tform_body",b"ko_tform_body","planar_ground",b"planar_ground","timestamp",b"timestamp","vision_tform_body",b"vision_tform_body"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    STANCES_FIELD_NUMBER: builtins.int
    id: typing.Text
    """Identifier of this snapshot.
    Snapshots are immutable -- if any of the other fields change, this ID must also change.
    """

    @property
    def stances(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EdgeSnapshot.Stance]:
        """Sampling of stances as robot traversed this edge."""
        pass
    def __init__(self,
        *,
        id: typing.Text = ...,
        stances: typing.Optional[typing.Iterable[global___EdgeSnapshot.Stance]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["id",b"id","stances",b"stances"]) -> None: ...
global___EdgeSnapshot = EdgeSnapshot

class Anchor(google.protobuf.message.Message):
    """This associates a waypoint with a common reference frame, which is not necessarily metric."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ID_FIELD_NUMBER: builtins.int
    SEED_TFORM_WAYPOINT_FIELD_NUMBER: builtins.int
    id: typing.Text
    """Identifier of the waypoint."""

    @property
    def seed_tform_waypoint(self) -> bosdyn.api.geometry_pb2.SE3Pose:
        """Pose of the waypoint in the seed frame."""
        pass
    def __init__(self,
        *,
        id: typing.Text = ...,
        seed_tform_waypoint: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["seed_tform_waypoint",b"seed_tform_waypoint"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["id",b"id","seed_tform_waypoint",b"seed_tform_waypoint"]) -> None: ...
global___Anchor = Anchor

class AnchoredWorldObject(google.protobuf.message.Message):
    """This associates a world object with a common reference frame, which is not necessarily metric."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ID_FIELD_NUMBER: builtins.int
    SEED_TFORM_OBJECT_FIELD_NUMBER: builtins.int
    id: typing.Text
    """Identifier of the world object."""

    @property
    def seed_tform_object(self) -> bosdyn.api.geometry_pb2.SE3Pose:
        """Pose of the object in the seed frame."""
        pass
    def __init__(self,
        *,
        id: typing.Text = ...,
        seed_tform_object: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["seed_tform_object",b"seed_tform_object"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["id",b"id","seed_tform_object",b"seed_tform_object"]) -> None: ...
global___AnchoredWorldObject = AnchoredWorldObject

class Anchoring(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ANCHORS_FIELD_NUMBER: builtins.int
    OBJECTS_FIELD_NUMBER: builtins.int
    @property
    def anchors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Anchor]:
        """The waypoint ids for the graph, expressed in a common reference frame, which is not
        necessarily metric. If there is no anchoring, this is empty.
        """
        pass
    @property
    def objects(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnchoredWorldObject]:
        """World objects, located in the common reference frame."""
        pass
    def __init__(self,
        *,
        anchors: typing.Optional[typing.Iterable[global___Anchor]] = ...,
        objects: typing.Optional[typing.Iterable[global___AnchoredWorldObject]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["anchors",b"anchors","objects",b"objects"]) -> None: ...
global___Anchoring = Anchoring

class Graph(google.protobuf.message.Message):
    """This is an arbitrary collection of waypoints and edges. The edges and waypoints are not required
    to be connected. A waypoint may belong to multiple graphs. This message is used to pass around
    information about a graph's topology, and is used to serialize map topology to and from files.
    Note that the graph does not contain any of the waypoint/edge data (which is found in snapshots).
    Snapshots are stored separately.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    WAYPOINTS_FIELD_NUMBER: builtins.int
    EDGES_FIELD_NUMBER: builtins.int
    ANCHORING_FIELD_NUMBER: builtins.int
    @property
    def waypoints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Waypoint]:
        """The waypoints for the graph (containing frames, annotations, and sensor data)."""
        pass
    @property
    def edges(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Edge]:
        """The edges connecting the graph's waypoints."""
        pass
    @property
    def anchoring(self) -> global___Anchoring:
        """The anchoring (mapping from waypoints to their pose in a shared reference frame)."""
        pass
    def __init__(self,
        *,
        waypoints: typing.Optional[typing.Iterable[global___Waypoint]] = ...,
        edges: typing.Optional[typing.Iterable[global___Edge]] = ...,
        anchoring: typing.Optional[global___Anchoring] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["anchoring",b"anchoring"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["anchoring",b"anchoring","edges",b"edges","waypoints",b"waypoints"]) -> None: ...
global___Graph = Graph
