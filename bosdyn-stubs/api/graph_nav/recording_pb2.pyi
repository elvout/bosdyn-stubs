"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.graph_nav.map_pb2
import bosdyn.api.header_pb2
import bosdyn.api.lease_pb2
import bosdyn.api.license_pb2
import bosdyn.api.world_object_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class RecordingEnvironment(google.protobuf.message.Message):
    """The RecordingEnvironment is a set of annotation information and a name for the
    current environment that will persist for all edges and waypoints until it is
    changed or updated
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_PREFIX_FIELD_NUMBER: builtins.int
    WAYPOINT_ENVIRONMENT_FIELD_NUMBER: builtins.int
    EDGE_ENVIRONMENT_FIELD_NUMBER: builtins.int
    name_prefix: typing.Text
    """This will be prepended to the start of every waypoint name."""

    @property
    def waypoint_environment(self) -> bosdyn.api.graph_nav.map_pb2.Waypoint.Annotations:
        """Persistent waypoint annotation that will be merged in
        to all waypoints in this recording.
        """
        pass
    @property
    def edge_environment(self) -> bosdyn.api.graph_nav.map_pb2.Edge.Annotations:
        """Persistent edge annotation that will be merged in to all
        waypoints in this recording.
        """
        pass
    def __init__(self,
        *,
        name_prefix: typing.Text = ...,
        waypoint_environment: typing.Optional[bosdyn.api.graph_nav.map_pb2.Waypoint.Annotations] = ...,
        edge_environment: typing.Optional[bosdyn.api.graph_nav.map_pb2.Edge.Annotations] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["edge_environment",b"edge_environment","waypoint_environment",b"waypoint_environment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["edge_environment",b"edge_environment","name_prefix",b"name_prefix","waypoint_environment",b"waypoint_environment"]) -> None: ...
global___RecordingEnvironment = RecordingEnvironment

class SetRecordingEnvironmentRequest(google.protobuf.message.Message):
    """The SetRecordingEnvironment request message sets a persistent recording environment
    until changed with another SetRecordingEnvironment rpc.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    ENVIRONMENT_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def environment(self) -> global___RecordingEnvironment:
        """Persistent environment to use while recording. This allows the
        user to specify annotations and naming prefixes for new waypoints
        and edges.
        """
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The recording service is protected by a lease. The client must have a
        lease to the recording service to modify its internal state.
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        environment: typing.Optional[global___RecordingEnvironment] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["environment",b"environment","header",b"header","lease",b"lease"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["environment",b"environment","header",b"header","lease",b"lease"]) -> None: ...
global___SetRecordingEnvironmentRequest = SetRecordingEnvironmentRequest

class SetRecordingEnvironmentResponse(google.protobuf.message.Message):
    """The SetRecordingEnvironment response message includes the result and status of the request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """The results/status of the lease provided."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> None: ...
global___SetRecordingEnvironmentResponse = SetRecordingEnvironmentResponse

class StartRecordingRequest(google.protobuf.message.Message):
    """The StartRecording request tells the recording service to begin creating waypoints with the
    specified recording_environment.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    RECORDING_ENVIRONMENT_FIELD_NUMBER: builtins.int
    REQUIRE_FIDUCIALS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The recording service is protected by a lease. The client must have a
        lease to the recording service to modify its internal state.
        """
        pass
    @property
    def recording_environment(self) -> global___RecordingEnvironment:
        """This will be merged into a copy of the existing persistent recording
        environment and used as the environment for the created waypoint
        and the edge from the previous waypoint to the new one.
        It will not affect the persistent environment.
        """
        pass
    @property
    def require_fiducials(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """If filled out, asks that the record service verify that the given fiducial IDs
        are presently visible before starting to record. This is useful for verifying
        that the robot is where the user thinks it is in an area with known fiducials.
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        recording_environment: typing.Optional[global___RecordingEnvironment] = ...,
        require_fiducials: typing.Optional[typing.Iterable[builtins.int]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease","recording_environment",b"recording_environment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease","recording_environment",b"recording_environment","require_fiducials",b"require_fiducials"]) -> None: ...
global___StartRecordingRequest = StartRecordingRequest

class StartRecordingResponse(google.protobuf.message.Message):
    """The StartRecording response messge returns the first created waypoint, which is made at the location
    the robot was standing when the request was made, in addition to any status information.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[StartRecordingResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: StartRecordingResponse._Status.ValueType  # 0
        """Status is unknown/unset."""

        STATUS_OK: StartRecordingResponse._Status.ValueType  # 1
        """Recording has been started."""

        STATUS_COULD_NOT_CREATE_WAYPOINT: StartRecordingResponse._Status.ValueType  # 2
        """In this case we tried to start recording, but GraphNav was internally still waiting for
        some data from the robot.
        """

        STATUS_FOLLOWING_ROUTE: StartRecordingResponse._Status.ValueType  # 3
        """Can't start recording because the robot is following a route."""

        STATUS_NOT_LOCALIZED_TO_EXISTING_MAP: StartRecordingResponse._Status.ValueType  # 4
        """When recording branches, the robot is not localized to the existing map before starting
        to record a new branch.
        """

        STATUS_MISSING_FIDUCIALS: StartRecordingResponse._Status.ValueType  # 5
        """Can't start recording because the robot doesn't see the required fiducials."""

        STATUS_MAP_TOO_LARGE_LICENSE: StartRecordingResponse._Status.ValueType  # 6
        """Can't start recording because the map was too large for the license."""

        STATUS_REMOTE_CLOUD_FAILURE_NOT_IN_DIRECTORY: StartRecordingResponse._Status.ValueType  # 7
        """A required remote cloud did not exist in the service directory."""

        STATUS_REMOTE_CLOUD_FAILURE_NO_DATA: StartRecordingResponse._Status.ValueType  # 8
        """A required remote cloud did not have data."""

        STATUS_FIDUCIAL_POSE_NOT_OK: StartRecordingResponse._Status.ValueType  # 9
        """All fiducials are visible but at least one pose could not be determined accurately."""

        STATUS_TOO_FAR_FROM_EXISTING_MAP: StartRecordingResponse._Status.ValueType  # 10
        """When recording branches, the robot is too far from the existing map when starting
        to record a new branch.
        """

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: StartRecordingResponse.Status.ValueType  # 0
    """Status is unknown/unset."""

    STATUS_OK: StartRecordingResponse.Status.ValueType  # 1
    """Recording has been started."""

    STATUS_COULD_NOT_CREATE_WAYPOINT: StartRecordingResponse.Status.ValueType  # 2
    """In this case we tried to start recording, but GraphNav was internally still waiting for
    some data from the robot.
    """

    STATUS_FOLLOWING_ROUTE: StartRecordingResponse.Status.ValueType  # 3
    """Can't start recording because the robot is following a route."""

    STATUS_NOT_LOCALIZED_TO_EXISTING_MAP: StartRecordingResponse.Status.ValueType  # 4
    """When recording branches, the robot is not localized to the existing map before starting
    to record a new branch.
    """

    STATUS_MISSING_FIDUCIALS: StartRecordingResponse.Status.ValueType  # 5
    """Can't start recording because the robot doesn't see the required fiducials."""

    STATUS_MAP_TOO_LARGE_LICENSE: StartRecordingResponse.Status.ValueType  # 6
    """Can't start recording because the map was too large for the license."""

    STATUS_REMOTE_CLOUD_FAILURE_NOT_IN_DIRECTORY: StartRecordingResponse.Status.ValueType  # 7
    """A required remote cloud did not exist in the service directory."""

    STATUS_REMOTE_CLOUD_FAILURE_NO_DATA: StartRecordingResponse.Status.ValueType  # 8
    """A required remote cloud did not have data."""

    STATUS_FIDUCIAL_POSE_NOT_OK: StartRecordingResponse.Status.ValueType  # 9
    """All fiducials are visible but at least one pose could not be determined accurately."""

    STATUS_TOO_FAR_FROM_EXISTING_MAP: StartRecordingResponse.Status.ValueType  # 10
    """When recording branches, the robot is too far from the existing map when starting
    to record a new branch.
    """


    HEADER_FIELD_NUMBER: builtins.int
    CREATED_WAYPOINT_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    MISSING_FIDUCIALS_FIELD_NUMBER: builtins.int
    BAD_POSE_FIDUCIALS_FIELD_NUMBER: builtins.int
    LICENSE_STATUS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def created_waypoint(self) -> bosdyn.api.graph_nav.map_pb2.Waypoint:
        """The waypoint that was just created."""
        pass
    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """The results/status of the lease provided."""
        pass
    status: global___StartRecordingResponse.Status.ValueType
    """Return status for the request."""

    @property
    def missing_fiducials(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """If the status is STATUS_MISSING_FIDUCIALS, these are the fiducials that are not currently
        visible.
        """
        pass
    @property
    def bad_pose_fiducials(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """If the status is STATUS_FIDUCIAL_POSE_NOT_OK, these are the fiducials that could not be
        localized confidently.
        """
        pass
    license_status: bosdyn.api.license_pb2.LicenseInfo.Status.ValueType
    """Large graphs can only be uploaded if the license permits them. Recording
    will stop automatically when the graph gets too large. If StartRecording
    is requested again after the graph gets too large, it will fail, and license
    status will be filled out.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        created_waypoint: typing.Optional[bosdyn.api.graph_nav.map_pb2.Waypoint] = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        status: global___StartRecordingResponse.Status.ValueType = ...,
        missing_fiducials: typing.Optional[typing.Iterable[builtins.int]] = ...,
        bad_pose_fiducials: typing.Optional[typing.Iterable[builtins.int]] = ...,
        license_status: bosdyn.api.license_pb2.LicenseInfo.Status.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["created_waypoint",b"created_waypoint","header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bad_pose_fiducials",b"bad_pose_fiducials","created_waypoint",b"created_waypoint","header",b"header","lease_use_result",b"lease_use_result","license_status",b"license_status","missing_fiducials",b"missing_fiducials","status",b"status"]) -> None: ...
global___StartRecordingResponse = StartRecordingResponse

class StopRecordingRequest(google.protobuf.message.Message):
    """The StopRecording request message tells the robot to no longer continue adding waypoints and
    edges to the graph.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The recording service is protected by a lease. The client must have a
        lease to the recording service to modify its internal state.
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease"]) -> None: ...
global___StopRecordingRequest = StopRecordingRequest

class StopRecordingResponse(google.protobuf.message.Message):
    """The StopRecording response message contains the status of this request and any useful error
    information if the request fails.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[StopRecordingResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: StopRecordingResponse._Status.ValueType  # 0
        """Status is unknown/unset."""

        STATUS_OK: StopRecordingResponse._Status.ValueType  # 1
        """Recording is stopped."""

        STATUS_NOT_LOCALIZED_TO_END: StopRecordingResponse._Status.ValueType  # 2
        """In this case we tried to stop recording, but had an incorrect localization.
        graph_nav is expected to be localized to the final waypoint in the chain before
        we stop recording.
        """

        STATUS_NOT_READY_YET: StopRecordingResponse._Status.ValueType  # 3
        """The robot is still processing the map it created to where the robot is currently located.
        You can't stop recording until that processing is finished.  You should not move
        the robot, then try to stop recording again after 1-2 seconds.
        """

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: StopRecordingResponse.Status.ValueType  # 0
    """Status is unknown/unset."""

    STATUS_OK: StopRecordingResponse.Status.ValueType  # 1
    """Recording is stopped."""

    STATUS_NOT_LOCALIZED_TO_END: StopRecordingResponse.Status.ValueType  # 2
    """In this case we tried to stop recording, but had an incorrect localization.
    graph_nav is expected to be localized to the final waypoint in the chain before
    we stop recording.
    """

    STATUS_NOT_READY_YET: StopRecordingResponse.Status.ValueType  # 3
    """The robot is still processing the map it created to where the robot is currently located.
    You can't stop recording until that processing is finished.  You should not move
    the robot, then try to stop recording again after 1-2 seconds.
    """


    HEADER_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    ERROR_WAYPOINT_LOCALIZED_ID_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    status: global___StopRecordingResponse.Status.ValueType
    """The return status for the request."""

    error_waypoint_localized_id: typing.Text
    """If not localized to end, specifies which waypoint we are localized to."""

    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """The results/status of the lease provided."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        status: global___StopRecordingResponse.Status.ValueType = ...,
        error_waypoint_localized_id: typing.Text = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error_waypoint_localized_id",b"error_waypoint_localized_id","header",b"header","lease_use_result",b"lease_use_result","status",b"status"]) -> None: ...
global___StopRecordingResponse = StopRecordingResponse

class CreateWaypointRequest(google.protobuf.message.Message):
    """The CreateWaypoint request message specifies a name and environment the robot should
    use to generate a waypoint in the graph at it's current location.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    WAYPOINT_NAME_FIELD_NUMBER: builtins.int
    RECORDING_ENVIRONMENT_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    REQUIRE_FIDUCIALS_FIELD_NUMBER: builtins.int
    WORLD_OBJECTS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    waypoint_name: typing.Text
    """Name of the waypoint to create. Overrides any naming prefix."""

    @property
    def recording_environment(self) -> global___RecordingEnvironment:
        """This will be merged into a copy of the existing persistent recording
        environment and used as the environment for the created waypoint
        and the edge from the previous waypoint to the new one.
        It will not affect the persistent environment.
        """
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The recording service is protected by a lease. The client must have a
        lease to the recording service to modify its internal state.
        """
        pass
    @property
    def require_fiducials(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """If filled out, asks that the record service verify that the given fiducial IDs
        are presently visible before creating a waypoint. This is useful for verifying
        that the robot is where the user thinks it is in an area with known fiducials.
        """
        pass
    @property
    def world_objects(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.world_object_pb2.WorldObject]:
        """Additional world objects to insert into this waypoint."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        waypoint_name: typing.Text = ...,
        recording_environment: typing.Optional[global___RecordingEnvironment] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        require_fiducials: typing.Optional[typing.Iterable[builtins.int]] = ...,
        world_objects: typing.Optional[typing.Iterable[bosdyn.api.world_object_pb2.WorldObject]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease","recording_environment",b"recording_environment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease","recording_environment",b"recording_environment","require_fiducials",b"require_fiducials","waypoint_name",b"waypoint_name","world_objects",b"world_objects"]) -> None: ...
global___CreateWaypointRequest = CreateWaypointRequest

class CreateWaypointResponse(google.protobuf.message.Message):
    """The CreateWaypoint response message contains the complete waypoint, and the associated
    edge connecting this waypoint to the graph when the request succeeds.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[CreateWaypointResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: CreateWaypointResponse._Status.ValueType  # 0
        """Status is unknown/unset."""

        STATUS_OK: CreateWaypointResponse._Status.ValueType  # 1
        """The waypoint was successfully created."""

        STATUS_NOT_RECORDING: CreateWaypointResponse._Status.ValueType  # 2
        """Clients can only create waypoints when recording."""

        STATUS_COULD_NOT_CREATE_WAYPOINT: CreateWaypointResponse._Status.ValueType  # 3
        """An internal server error prevented the creation of the waypoint."""

        STATUS_MISSING_FIDUCIALS: CreateWaypointResponse._Status.ValueType  # 4
        """Could not see the required fiducials."""

        STATUS_MAP_TOO_LARGE_LICENSE: CreateWaypointResponse._Status.ValueType  # 5
        """The map was too big to create a waypoint based on the license."""

        STATUS_REMOTE_CLOUD_FAILURE_NOT_IN_DIRECTORY: CreateWaypointResponse._Status.ValueType  # 6
        """A required remote cloud did not exist in the service directory."""

        STATUS_REMOTE_CLOUD_FAILURE_NO_DATA: CreateWaypointResponse._Status.ValueType  # 7
        """A required remote cloud did not have data."""

        STATUS_FIDUCIAL_POSE_NOT_OK: CreateWaypointResponse._Status.ValueType  # 8
        """All fiducials are visible but their pose could not be determined accurately."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: CreateWaypointResponse.Status.ValueType  # 0
    """Status is unknown/unset."""

    STATUS_OK: CreateWaypointResponse.Status.ValueType  # 1
    """The waypoint was successfully created."""

    STATUS_NOT_RECORDING: CreateWaypointResponse.Status.ValueType  # 2
    """Clients can only create waypoints when recording."""

    STATUS_COULD_NOT_CREATE_WAYPOINT: CreateWaypointResponse.Status.ValueType  # 3
    """An internal server error prevented the creation of the waypoint."""

    STATUS_MISSING_FIDUCIALS: CreateWaypointResponse.Status.ValueType  # 4
    """Could not see the required fiducials."""

    STATUS_MAP_TOO_LARGE_LICENSE: CreateWaypointResponse.Status.ValueType  # 5
    """The map was too big to create a waypoint based on the license."""

    STATUS_REMOTE_CLOUD_FAILURE_NOT_IN_DIRECTORY: CreateWaypointResponse.Status.ValueType  # 6
    """A required remote cloud did not exist in the service directory."""

    STATUS_REMOTE_CLOUD_FAILURE_NO_DATA: CreateWaypointResponse.Status.ValueType  # 7
    """A required remote cloud did not have data."""

    STATUS_FIDUCIAL_POSE_NOT_OK: CreateWaypointResponse.Status.ValueType  # 8
    """All fiducials are visible but their pose could not be determined accurately."""


    HEADER_FIELD_NUMBER: builtins.int
    CREATED_WAYPOINT_FIELD_NUMBER: builtins.int
    CREATED_EDGE_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    MISSING_FIDUCIALS_FIELD_NUMBER: builtins.int
    BAD_POSE_FIDUCIALS_FIELD_NUMBER: builtins.int
    LICENSE_STATUS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def created_waypoint(self) -> bosdyn.api.graph_nav.map_pb2.Waypoint:
        """The waypoint that was just created."""
        pass
    @property
    def created_edge(self) -> bosdyn.api.graph_nav.map_pb2.Edge:
        """The edge connecting the waypoint just created with the last created waypoint in the map."""
        pass
    status: global___CreateWaypointResponse.Status.ValueType
    """Return status for the request."""

    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """The results/status of the lease provided."""
        pass
    @property
    def missing_fiducials(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """If the status is STATUS_MISSING_FIDUCIALS, the following fiducials
        were not visible to the robot when trying to create the waypoint.
        """
        pass
    @property
    def bad_pose_fiducials(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """If the status is STATUS_FIDUCIAL_POSE_NOT_OK, these are the fiducials that could not be
        localized confidently.
        """
        pass
    license_status: bosdyn.api.license_pb2.LicenseInfo.Status.ValueType
    """Large graphs can only be uploaded if the license permits them. Recording
    will stop automatically when the graph gets too large. If CreateWaypointResponse
    is requested after the graph gets too large, it will fail, and license
    status will be filled out.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        created_waypoint: typing.Optional[bosdyn.api.graph_nav.map_pb2.Waypoint] = ...,
        created_edge: typing.Optional[bosdyn.api.graph_nav.map_pb2.Edge] = ...,
        status: global___CreateWaypointResponse.Status.ValueType = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        missing_fiducials: typing.Optional[typing.Iterable[builtins.int]] = ...,
        bad_pose_fiducials: typing.Optional[typing.Iterable[builtins.int]] = ...,
        license_status: bosdyn.api.license_pb2.LicenseInfo.Status.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["created_edge",b"created_edge","created_waypoint",b"created_waypoint","header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bad_pose_fiducials",b"bad_pose_fiducials","created_edge",b"created_edge","created_waypoint",b"created_waypoint","header",b"header","lease_use_result",b"lease_use_result","license_status",b"license_status","missing_fiducials",b"missing_fiducials","status",b"status"]) -> None: ...
global___CreateWaypointResponse = CreateWaypointResponse

class CreateEdgeRequest(google.protobuf.message.Message):
    """The CreateEdge request message specifies an edge to create between two existing waypoints.
    The edge must not already exist in the map. This can be used to close a loop or to add any
    additional edges.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    EDGE_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def edge(self) -> bosdyn.api.graph_nav.map_pb2.Edge:
        """Create an edge between two existing waypoints in the map with
        the given parameters.
        """
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The recording service is protected by a lease. The client must have a
        lease to the recording service to modify its internal state.
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        edge: typing.Optional[bosdyn.api.graph_nav.map_pb2.Edge] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["edge",b"edge","header",b"header","lease",b"lease"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["edge",b"edge","header",b"header","lease",b"lease"]) -> None: ...
global___CreateEdgeRequest = CreateEdgeRequest

class CreateEdgeResponse(google.protobuf.message.Message):
    """The CreateEdge response message contains the status of this request and any useful error
    information if the request fails.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[CreateEdgeResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: CreateEdgeResponse._Status.ValueType  # 0
        """Status is unknown/unset."""

        STATUS_OK: CreateEdgeResponse._Status.ValueType  # 1
        """The edge was successfully created."""

        STATUS_EXISTS: CreateEdgeResponse._Status.ValueType  # 2
        """Edge already exists with the given ID."""

        STATUS_NOT_RECORDING: CreateEdgeResponse._Status.ValueType  # 3
        """Clients can only create edges when recording."""

        STATUS_UNKNOWN_WAYPOINT: CreateEdgeResponse._Status.ValueType  # 4
        """One or more of the specified waypoints aren't in the map."""

        STATUS_MISSING_TRANSFORM: CreateEdgeResponse._Status.ValueType  # 5
        """Specified edge did not include a transform."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: CreateEdgeResponse.Status.ValueType  # 0
    """Status is unknown/unset."""

    STATUS_OK: CreateEdgeResponse.Status.ValueType  # 1
    """The edge was successfully created."""

    STATUS_EXISTS: CreateEdgeResponse.Status.ValueType  # 2
    """Edge already exists with the given ID."""

    STATUS_NOT_RECORDING: CreateEdgeResponse.Status.ValueType  # 3
    """Clients can only create edges when recording."""

    STATUS_UNKNOWN_WAYPOINT: CreateEdgeResponse.Status.ValueType  # 4
    """One or more of the specified waypoints aren't in the map."""

    STATUS_MISSING_TRANSFORM: CreateEdgeResponse.Status.ValueType  # 5
    """Specified edge did not include a transform."""


    HEADER_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    ERROR_EXISTING_EDGE_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    status: global___CreateEdgeResponse.Status.ValueType
    """Return status for the request."""

    @property
    def error_existing_edge(self) -> bosdyn.api.graph_nav.map_pb2.Edge:
        """If set, the existing edge that caused the STATUS_EXISTS error."""
        pass
    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """The results/status of the lease provided."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        status: global___CreateEdgeResponse.Status.ValueType = ...,
        error_existing_edge: typing.Optional[bosdyn.api.graph_nav.map_pb2.Edge] = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["error_existing_edge",b"error_existing_edge","header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error_existing_edge",b"error_existing_edge","header",b"header","lease_use_result",b"lease_use_result","status",b"status"]) -> None: ...
global___CreateEdgeResponse = CreateEdgeResponse

class GetRecordStatusRequest(google.protobuf.message.Message):
    """The GetRecordStatus request message asks for the current state of the recording service."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header"]) -> None: ...
global___GetRecordStatusRequest = GetRecordStatusRequest

class GetRecordStatusResponse(google.protobuf.message.Message):
    """The GetRecordStatus response message returns whether the service is currently recording and what the
    persistent recording environment is at the time the request was recieved.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _MapState:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _MapStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[GetRecordStatusResponse._MapState.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        MAP_STATE_UNKNOWN: GetRecordStatusResponse._MapState.ValueType  # 0
        MAP_STATE_OK: GetRecordStatusResponse._MapState.ValueType  # 1
        """Successfully started recording."""

        MAP_STATE_TOO_LARGE_FOR_LICENSE: GetRecordStatusResponse._MapState.ValueType  # 2
        """Unable to continue recording because a larger map requires an upgraded license."""

    class MapState(_MapState, metaclass=_MapStateEnumTypeWrapper):
        pass

    MAP_STATE_UNKNOWN: GetRecordStatusResponse.MapState.ValueType  # 0
    MAP_STATE_OK: GetRecordStatusResponse.MapState.ValueType  # 1
    """Successfully started recording."""

    MAP_STATE_TOO_LARGE_FOR_LICENSE: GetRecordStatusResponse.MapState.ValueType  # 2
    """Unable to continue recording because a larger map requires an upgraded license."""


    HEADER_FIELD_NUMBER: builtins.int
    IS_RECORDING_FIELD_NUMBER: builtins.int
    RECORDING_ENVIRONMENT_FIELD_NUMBER: builtins.int
    MAP_STATE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    is_recording: builtins.bool
    """If true, the record service is actively recording
    a chain.
    """

    @property
    def recording_environment(self) -> global___RecordingEnvironment:
        """The current persistent recording environment."""
        pass
    map_state: global___GetRecordStatusResponse.MapState.ValueType
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        is_recording: builtins.bool = ...,
        recording_environment: typing.Optional[global___RecordingEnvironment] = ...,
        map_state: global___GetRecordStatusResponse.MapState.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","recording_environment",b"recording_environment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","is_recording",b"is_recording","map_state",b"map_state","recording_environment",b"recording_environment"]) -> None: ...
global___GetRecordStatusResponse = GetRecordStatusResponse
