"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.basic_command_pb2
import bosdyn.api.data_chunk_pb2
import bosdyn.api.geometry_pb2
import bosdyn.api.graph_nav.map_pb2
import bosdyn.api.graph_nav.nav_pb2
import bosdyn.api.header_pb2
import bosdyn.api.lease_pb2
import bosdyn.api.license_pb2
import bosdyn.api.robot_state_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class SetLocalizationRequest(google.protobuf.message.Message):
    """The SetLocalization request is used to initialize or reset the localization of GraphNav
    to a map. A localization consists of a waypoint ID, and a pose of the robot relative to that waypoint.
    GraphNav uses the localization to decide how to navigate through a map.
    The SetLocalizationRequest contains parameters to help find a correct localization. For example,
    AprilTags (fiducials) may be used to set the localization, or the caller can provide an explicit
    guess of the localization.
    Once the SetLocalizationRequest completes, the current localization to the map
    will be modified, and can be retrieved using a GetLocalizationStateRequest.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _FiducialInit:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _FiducialInitEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SetLocalizationRequest._FiducialInit.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        FIDUCIAL_INIT_UNKNOWN: SetLocalizationRequest._FiducialInit.ValueType  # 0
        """It is a programming error to use this one."""

        FIDUCIAL_INIT_NO_FIDUCIAL: SetLocalizationRequest._FiducialInit.ValueType  # 1
        """Ignore fiducials during initialization."""

        FIDUCIAL_INIT_NEAREST: SetLocalizationRequest._FiducialInit.ValueType  # 2
        """Localize to the nearest fiducial in any waypoint."""

        FIDUCIAL_INIT_NEAREST_AT_TARGET: SetLocalizationRequest._FiducialInit.ValueType  # 3
        """Localize to nearest fiducial at the target waypoint (from initial_guess)."""

        FIDUCIAL_INIT_SPECIFIC: SetLocalizationRequest._FiducialInit.ValueType  # 4
        """Localize to the given fiducial at the target waypoint (from initial_guess) if it exists, or any waypoint otherwise."""

    class FiducialInit(_FiducialInit, metaclass=_FiducialInitEnumTypeWrapper):
        pass

    FIDUCIAL_INIT_UNKNOWN: SetLocalizationRequest.FiducialInit.ValueType  # 0
    """It is a programming error to use this one."""

    FIDUCIAL_INIT_NO_FIDUCIAL: SetLocalizationRequest.FiducialInit.ValueType  # 1
    """Ignore fiducials during initialization."""

    FIDUCIAL_INIT_NEAREST: SetLocalizationRequest.FiducialInit.ValueType  # 2
    """Localize to the nearest fiducial in any waypoint."""

    FIDUCIAL_INIT_NEAREST_AT_TARGET: SetLocalizationRequest.FiducialInit.ValueType  # 3
    """Localize to nearest fiducial at the target waypoint (from initial_guess)."""

    FIDUCIAL_INIT_SPECIFIC: SetLocalizationRequest.FiducialInit.ValueType  # 4
    """Localize to the given fiducial at the target waypoint (from initial_guess) if it exists, or any waypoint otherwise."""


    HEADER_FIELD_NUMBER: builtins.int
    INITIAL_GUESS_FIELD_NUMBER: builtins.int
    KO_TFORM_BODY_FIELD_NUMBER: builtins.int
    MAX_DISTANCE_FIELD_NUMBER: builtins.int
    MAX_YAW_FIELD_NUMBER: builtins.int
    FIDUCIAL_INIT_FIELD_NUMBER: builtins.int
    USE_FIDUCIAL_ID_FIELD_NUMBER: builtins.int
    REFINE_FIDUCIAL_RESULT_WITH_ICP_FIELD_NUMBER: builtins.int
    DO_AMBIGUITY_CHECK_FIELD_NUMBER: builtins.int
    RESTRICT_FIDUCIAL_DETECTIONS_TO_TARGET_WAYPOINT_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def initial_guess(self) -> bosdyn.api.graph_nav.nav_pb2.Localization:
        """Operator-supplied guess at localization."""
        pass
    @property
    def ko_tform_body(self) -> bosdyn.api.geometry_pb2.SE3Pose:
        """Robot pose when the initial_guess was made.
        This overcomes the race that occurs when the client is trying to initialize a moving robot.
        GraphNav will use its local ko_tform_body and this ko_tform_body to update the initial
        localization guess, if necessary.
        """
        pass
    max_distance: builtins.float
    """The max distance [meters] is how far away the robot is allowed to localize from the position supplied
    in the initial guess. If not specified, the offset is used directly. Otherwise it searches a neighborhood
    of the given size.
    """

    max_yaw: builtins.float
    """The max yaw [radians] is how different the localized yaw is allowed to be from the supplied yaw
    in the initial guess. If not specified, the offset is used directly. Otherwise it searches a neighborhood
    of the given size.
    """

    fiducial_init: global___SetLocalizationRequest.FiducialInit.ValueType
    """Tells the initializer whether to use fiducials, and how to use them."""

    use_fiducial_id: builtins.int
    """If using FIDUCIAL_INIT_SPECIFIC, this is the specific fiducial ID to use for initialization.
    If no detection of this fiducial exists, the service will return STATUS_NO_MATCHING_FIDUCIAL.
    If detections exist, but are low quality, STATUS_FIDUCIAL_TOO_FAR_AWAY, FIDUCIAL_TOO_OLD, or FIDUCIAL_POSE_UNCERTAIN will be returned.
    """

    refine_fiducial_result_with_icp: builtins.bool
    """If true, and we are using fiducials during initialization, will run ICP after the fiducial
    was used for an initial guess.
    """

    do_ambiguity_check: builtins.bool
    """If true, consider how nearby localizations appear (like turned 180)."""

    restrict_fiducial_detections_to_target_waypoint: builtins.bool
    """If using FIDUCIAL_INIT_SPECIFIC and this is true, the initializer will only consider
    fiducial detections from the target waypoint (from initial_guess). Otherwise, if the
    target waypoint does not contain a good measurement of the desired fiducial, nearby waypoints
    may be used to infer the robot's location.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        initial_guess: typing.Optional[bosdyn.api.graph_nav.nav_pb2.Localization] = ...,
        ko_tform_body: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
        max_distance: builtins.float = ...,
        max_yaw: builtins.float = ...,
        fiducial_init: global___SetLocalizationRequest.FiducialInit.ValueType = ...,
        use_fiducial_id: builtins.int = ...,
        refine_fiducial_result_with_icp: builtins.bool = ...,
        do_ambiguity_check: builtins.bool = ...,
        restrict_fiducial_detections_to_target_waypoint: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","initial_guess",b"initial_guess","ko_tform_body",b"ko_tform_body"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["do_ambiguity_check",b"do_ambiguity_check","fiducial_init",b"fiducial_init","header",b"header","initial_guess",b"initial_guess","ko_tform_body",b"ko_tform_body","max_distance",b"max_distance","max_yaw",b"max_yaw","refine_fiducial_result_with_icp",b"refine_fiducial_result_with_icp","restrict_fiducial_detections_to_target_waypoint",b"restrict_fiducial_detections_to_target_waypoint","use_fiducial_id",b"use_fiducial_id"]) -> None: ...
global___SetLocalizationRequest = SetLocalizationRequest

class SetLocalizationResponse(google.protobuf.message.Message):
    """The SetLocalization response message contains the resulting localization to the map."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SetLocalizationResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: SetLocalizationResponse._Status.ValueType  # 0
        """The status is unknown/unset."""

        STATUS_OK: SetLocalizationResponse._Status.ValueType  # 1
        """Localization success."""

        STATUS_ROBOT_IMPAIRED: SetLocalizationResponse._Status.ValueType  # 2
        """Robot is experiencing a condition that prevents localization."""

        STATUS_UNKNOWN_WAYPOINT: SetLocalizationResponse._Status.ValueType  # 3
        """The given waypoint is unknown by the system.
        This could be due to a client error, or because the graph was changed out from under the
        client.
        """

        STATUS_ABORTED: SetLocalizationResponse._Status.ValueType  # 4
        """Localization was aborted, likely because of a new request."""

        STATUS_FAILED: SetLocalizationResponse._Status.ValueType  # 5
        """Failed to localize for some other reason; see the error_report for details.
        This is often because the initial guess was incorrect.
        """

        STATUS_FIDUCIAL_TOO_FAR_AWAY: SetLocalizationResponse._Status.ValueType  # 6
        """Failed to localize because the fiducial requested by 'use_fiducial_id' was too far away from
        the robot.
        """

        STATUS_FIDUCIAL_TOO_OLD: SetLocalizationResponse._Status.ValueType  # 7
        """Failed to localize because the fiducial requested by 'use_fiducial_id' had a detection time that was too
        far in the past.
        """

        STATUS_NO_MATCHING_FIDUCIAL: SetLocalizationResponse._Status.ValueType  # 8
        """Failed to localize because the fiducial requested by 'use_fiducial_id' did not exist in the map at
        the required location.
        """

        STATUS_FIDUCIAL_POSE_UNCERTAIN: SetLocalizationResponse._Status.ValueType  # 9
        """Failed to localize because the fiducial requested by 'use_fiducial_id' had an unreliable
        pose estimation, either in the current detection of that fiducial, or in detections that
        were saved in the map. Note that when using FIDUCIAL_INIT_SPECIFIC, fiducial detections at
        the target waypoint will be used so long as they are not uncertain -- otherwise, detections
        at adjacent waypoints may be used. If there exists no uncertain detection of the fiducial
        near the target waypoint in the map, the service returns this status.
        """

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: SetLocalizationResponse.Status.ValueType  # 0
    """The status is unknown/unset."""

    STATUS_OK: SetLocalizationResponse.Status.ValueType  # 1
    """Localization success."""

    STATUS_ROBOT_IMPAIRED: SetLocalizationResponse.Status.ValueType  # 2
    """Robot is experiencing a condition that prevents localization."""

    STATUS_UNKNOWN_WAYPOINT: SetLocalizationResponse.Status.ValueType  # 3
    """The given waypoint is unknown by the system.
    This could be due to a client error, or because the graph was changed out from under the
    client.
    """

    STATUS_ABORTED: SetLocalizationResponse.Status.ValueType  # 4
    """Localization was aborted, likely because of a new request."""

    STATUS_FAILED: SetLocalizationResponse.Status.ValueType  # 5
    """Failed to localize for some other reason; see the error_report for details.
    This is often because the initial guess was incorrect.
    """

    STATUS_FIDUCIAL_TOO_FAR_AWAY: SetLocalizationResponse.Status.ValueType  # 6
    """Failed to localize because the fiducial requested by 'use_fiducial_id' was too far away from
    the robot.
    """

    STATUS_FIDUCIAL_TOO_OLD: SetLocalizationResponse.Status.ValueType  # 7
    """Failed to localize because the fiducial requested by 'use_fiducial_id' had a detection time that was too
    far in the past.
    """

    STATUS_NO_MATCHING_FIDUCIAL: SetLocalizationResponse.Status.ValueType  # 8
    """Failed to localize because the fiducial requested by 'use_fiducial_id' did not exist in the map at
    the required location.
    """

    STATUS_FIDUCIAL_POSE_UNCERTAIN: SetLocalizationResponse.Status.ValueType  # 9
    """Failed to localize because the fiducial requested by 'use_fiducial_id' had an unreliable
    pose estimation, either in the current detection of that fiducial, or in detections that
    were saved in the map. Note that when using FIDUCIAL_INIT_SPECIFIC, fiducial detections at
    the target waypoint will be used so long as they are not uncertain -- otherwise, detections
    at adjacent waypoints may be used. If there exists no uncertain detection of the fiducial
    near the target waypoint in the map, the service returns this status.
    """


    class SuspectedAmbiguity(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        ALTERNATE_ROBOT_TFORM_WAYPOINT_FIELD_NUMBER: builtins.int
        @property
        def alternate_robot_tform_waypoint(self) -> bosdyn.api.geometry_pb2.SE3Pose:
            """Example of a potentially ambiguous localization near the
            result of the initialization.
            """
            pass
        def __init__(self,
            *,
            alternate_robot_tform_waypoint: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["alternate_robot_tform_waypoint",b"alternate_robot_tform_waypoint"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["alternate_robot_tform_waypoint",b"alternate_robot_tform_waypoint"]) -> None: ...

    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    ERROR_REPORT_FIELD_NUMBER: builtins.int
    LOCALIZATION_FIELD_NUMBER: builtins.int
    SUSPECTED_AMBIGUITY_FIELD_NUMBER: builtins.int
    IMPAIRED_STATE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """Result of using the lease."""
        pass
    status: global___SetLocalizationResponse.Status.ValueType
    """Return status for the request."""

    error_report: typing.Text
    """If set, describes the reason the status is not OK."""

    @property
    def localization(self) -> bosdyn.api.graph_nav.nav_pb2.Localization:
        """Result of localization."""
        pass
    @property
    def suspected_ambiguity(self) -> global___SetLocalizationResponse.SuspectedAmbiguity:
        """Alternative information if the localization is ambiguous."""
        pass
    @property
    def impaired_state(self) -> bosdyn.api.robot_state_pb2.RobotImpairedState:
        """If the status is ROBOT_IMPAIRED, this is why the robot is impaired."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        status: global___SetLocalizationResponse.Status.ValueType = ...,
        error_report: typing.Text = ...,
        localization: typing.Optional[bosdyn.api.graph_nav.nav_pb2.Localization] = ...,
        suspected_ambiguity: typing.Optional[global___SetLocalizationResponse.SuspectedAmbiguity] = ...,
        impaired_state: typing.Optional[bosdyn.api.robot_state_pb2.RobotImpairedState] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","impaired_state",b"impaired_state","lease_use_result",b"lease_use_result","localization",b"localization","suspected_ambiguity",b"suspected_ambiguity"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["error_report",b"error_report","header",b"header","impaired_state",b"impaired_state","lease_use_result",b"lease_use_result","localization",b"localization","status",b"status","suspected_ambiguity",b"suspected_ambiguity"]) -> None: ...
global___SetLocalizationResponse = SetLocalizationResponse

class RouteGenParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___RouteGenParams = RouteGenParams

class TravelParams(google.protobuf.message.Message):
    """Parameters describing how to travel along a route."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _FeatureQualityTolerance:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _FeatureQualityToleranceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[TravelParams._FeatureQualityTolerance.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TOLERANCE_UNKNOWN: TravelParams._FeatureQualityTolerance.ValueType  # 0
        """Unknown value"""

        TOLERANCE_DEFAULT: TravelParams._FeatureQualityTolerance.ValueType  # 1
        """Navigate through default number of waypoints with poor quality features"""

        TOLERANCE_IGNORE_POOR_FEATURE_QUALITY: TravelParams._FeatureQualityTolerance.ValueType  # 2
        """Navigate through unlimited number of waypoints with poor quality features"""

    class FeatureQualityTolerance(_FeatureQualityTolerance, metaclass=_FeatureQualityToleranceEnumTypeWrapper):
        """Indicates whether robot will navigate through areas with poor quality features"""
        pass

    TOLERANCE_UNKNOWN: TravelParams.FeatureQualityTolerance.ValueType  # 0
    """Unknown value"""

    TOLERANCE_DEFAULT: TravelParams.FeatureQualityTolerance.ValueType  # 1
    """Navigate through default number of waypoints with poor quality features"""

    TOLERANCE_IGNORE_POOR_FEATURE_QUALITY: TravelParams.FeatureQualityTolerance.ValueType  # 2
    """Navigate through unlimited number of waypoints with poor quality features"""


    MAX_DISTANCE_FIELD_NUMBER: builtins.int
    MAX_YAW_FIELD_NUMBER: builtins.int
    VELOCITY_LIMIT_FIELD_NUMBER: builtins.int
    IGNORE_FINAL_YAW_FIELD_NUMBER: builtins.int
    FEATURE_QUALITY_TOLERANCE_FIELD_NUMBER: builtins.int
    DISABLE_DIRECTED_EXPLORATION_FIELD_NUMBER: builtins.int
    DISABLE_ALTERNATE_ROUTE_FINDING_FIELD_NUMBER: builtins.int
    max_distance: builtins.float
    """Threshold for the maximum distance [meters] that defines when we have reached
    the final waypoint.
    """

    max_yaw: builtins.float
    """Threshold for the maximum yaw [radians] that defines when we have reached
    the final waypoint (ignored if ignore_final_yaw is set to true).
    """

    @property
    def velocity_limit(self) -> bosdyn.api.geometry_pb2.SE2VelocityLimit:
        """Speed the robot should use.
        Omit to let the robot choose.
        """
        pass
    ignore_final_yaw: builtins.bool
    """If true, the robot will only try to achieve
    the final translation of the route. Otherwise,
    it will attempt to achieve the yaw as well.
    """

    feature_quality_tolerance: global___TravelParams.FeatureQualityTolerance.ValueType
    disable_directed_exploration: builtins.bool
    """Disable directed exploration to skip blocked portions of route"""

    disable_alternate_route_finding: builtins.bool
    """Disable alternate-route-finding; overrides the per-edge setting in the map."""

    def __init__(self,
        *,
        max_distance: builtins.float = ...,
        max_yaw: builtins.float = ...,
        velocity_limit: typing.Optional[bosdyn.api.geometry_pb2.SE2VelocityLimit] = ...,
        ignore_final_yaw: builtins.bool = ...,
        feature_quality_tolerance: global___TravelParams.FeatureQualityTolerance.ValueType = ...,
        disable_directed_exploration: builtins.bool = ...,
        disable_alternate_route_finding: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["velocity_limit",b"velocity_limit"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["disable_alternate_route_finding",b"disable_alternate_route_finding","disable_directed_exploration",b"disable_directed_exploration","feature_quality_tolerance",b"feature_quality_tolerance","ignore_final_yaw",b"ignore_final_yaw","max_distance",b"max_distance","max_yaw",b"max_yaw","velocity_limit",b"velocity_limit"]) -> None: ...
global___TravelParams = TravelParams

class NavigateToRequest(google.protobuf.message.Message):
    """The NavigateToRequest can be used to command GraphNav to drive the robot to a specific waypoint.
    GraphNav will plan a path through the map which most efficiently gets the robot to the specified goal waypoint.
    Parameters are provided which influence how GraphNav will generate and follow the path.
    This RPC returns immediately after the request is processed. It does not block until GraphNav completes the path
    to the goal waypoint. The user is expected to periodically check the status of the NavigateTo command using
    the NavigationFeedbackRequest RPC.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASES_FIELD_NUMBER: builtins.int
    DESTINATION_WAYPOINT_ID_FIELD_NUMBER: builtins.int
    ROUTE_PARAMS_FIELD_NUMBER: builtins.int
    TRAVEL_PARAMS_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    CLOCK_IDENTIFIER_FIELD_NUMBER: builtins.int
    DESTINATION_WAYPOINT_TFORM_BODY_GOAL_FIELD_NUMBER: builtins.int
    COMMAND_ID_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def leases(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.lease_pb2.Lease]:
        """The Leases to show ownership of the robot and the graph."""
        pass
    destination_waypoint_id: typing.Text
    """ID of the waypoint to go to."""

    @property
    def route_params(self) -> global___RouteGenParams:
        """Preferences on how to pick the route."""
        pass
    @property
    def travel_params(self) -> global___TravelParams:
        """Parameters that define how to traverse and end the route."""
        pass
    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The timestamp (in robot time) that the navigation command is valid until."""
        pass
    clock_identifier: typing.Text
    """Identifier provided by the time sync service to verify time sync between robot and client."""

    @property
    def destination_waypoint_tform_body_goal(self) -> bosdyn.api.geometry_pb2.SE2Pose:
        """If provided, graph_nav will move the robot to an SE2 pose relative to the waypoint.
        Note that the robot will treat this as a simple goto request. It will first arrive at the
        destination waypoint, and then travel in a straight line from the destination waypoint to the
        offset goal, attempting to avoid obstacles along the way.
        """
        pass
    command_id: builtins.int
    """Unique identifier for the command. If 0, this is a new command, otherwise it is a continuation
    of an existing command. If this is a continuation of an existing command, all parameters will be
    ignored, and the old parameters will be preserved.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        leases: typing.Optional[typing.Iterable[bosdyn.api.lease_pb2.Lease]] = ...,
        destination_waypoint_id: typing.Text = ...,
        route_params: typing.Optional[global___RouteGenParams] = ...,
        travel_params: typing.Optional[global___TravelParams] = ...,
        end_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        clock_identifier: typing.Text = ...,
        destination_waypoint_tform_body_goal: typing.Optional[bosdyn.api.geometry_pb2.SE2Pose] = ...,
        command_id: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["destination_waypoint_tform_body_goal",b"destination_waypoint_tform_body_goal","end_time",b"end_time","header",b"header","route_params",b"route_params","travel_params",b"travel_params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["clock_identifier",b"clock_identifier","command_id",b"command_id","destination_waypoint_id",b"destination_waypoint_id","destination_waypoint_tform_body_goal",b"destination_waypoint_tform_body_goal","end_time",b"end_time","header",b"header","leases",b"leases","route_params",b"route_params","travel_params",b"travel_params"]) -> None: ...
global___NavigateToRequest = NavigateToRequest

class NavigateToResponse(google.protobuf.message.Message):
    """Response to a NavigateToRequest. This is returned immediately after the request is processed. A command_id
    is provided to specify the ID that the user may use to poll the system for feedback on the NavigateTo command.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NavigateToResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: NavigateToResponse._Status.ValueType  # 0
        """An unknown / unexpected error occurred."""

        STATUS_OK: NavigateToResponse._Status.ValueType  # 1
        """Request was accepted."""

        STATUS_NO_TIMESYNC: NavigateToResponse._Status.ValueType  # 2
        """[Time error] Client has not done timesync with robot."""

        STATUS_EXPIRED: NavigateToResponse._Status.ValueType  # 3
        """[Time error] The command was received after its end time had already passed."""

        STATUS_TOO_DISTANT: NavigateToResponse._Status.ValueType  # 4
        """[Time error]The command end time was too far in the future."""

        STATUS_ROBOT_IMPAIRED: NavigateToResponse._Status.ValueType  # 5
        """[Robot State Error] Cannot navigate a route if the robot has a critical
         perception fault, or behavior fault, or LIDAR not working.
        """

        STATUS_RECORDING: NavigateToResponse._Status.ValueType  # 6
        """[Robot State Error] Cannot navigate a route while recording a map."""

        STATUS_UNKNOWN_WAYPOINT: NavigateToResponse._Status.ValueType  # 7
        """[Route Error] One or more of the waypoints specified weren't in the map."""

        STATUS_NO_PATH: NavigateToResponse._Status.ValueType  # 8
        """[Route Error] There is no path to the specified waypoint."""

        STATUS_FEATURE_DESERT: NavigateToResponse._Status.ValueType  # 10
        """[Route Error] Route contained too many waypoints with low-quality features."""

        STATUS_LOST: NavigateToResponse._Status.ValueType  # 11
        """[Route Error] Happens when you try to issue a navigate to while the robot is lost."""

        STATUS_NOT_LOCALIZED_TO_MAP: NavigateToResponse._Status.ValueType  # 13
        """[Route Error] Happens when the current localization doesn't refer to any waypoint in the map (possibly uninitialized localization)."""

        STATUS_COULD_NOT_UPDATE_ROUTE: NavigateToResponse._Status.ValueType  # 12
        """[Wrestling error] Happens when graph nav refuses to follow the route you specified."""

        STATUS_STUCK: NavigateToResponse._Status.ValueType  # 14
        """[Route Error] Happens when you try to issue a navigate to while the robot is stuck. Navigate to a different
        waypoint, or clear the route and try again.
        """

        STATUS_UNRECOGNIZED_COMMAND: NavigateToResponse._Status.ValueType  # 15
        """[Request Error] Happens when you try to continue a command that was either expired, or had an unrecognized id."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: NavigateToResponse.Status.ValueType  # 0
    """An unknown / unexpected error occurred."""

    STATUS_OK: NavigateToResponse.Status.ValueType  # 1
    """Request was accepted."""

    STATUS_NO_TIMESYNC: NavigateToResponse.Status.ValueType  # 2
    """[Time error] Client has not done timesync with robot."""

    STATUS_EXPIRED: NavigateToResponse.Status.ValueType  # 3
    """[Time error] The command was received after its end time had already passed."""

    STATUS_TOO_DISTANT: NavigateToResponse.Status.ValueType  # 4
    """[Time error]The command end time was too far in the future."""

    STATUS_ROBOT_IMPAIRED: NavigateToResponse.Status.ValueType  # 5
    """[Robot State Error] Cannot navigate a route if the robot has a critical
     perception fault, or behavior fault, or LIDAR not working.
    """

    STATUS_RECORDING: NavigateToResponse.Status.ValueType  # 6
    """[Robot State Error] Cannot navigate a route while recording a map."""

    STATUS_UNKNOWN_WAYPOINT: NavigateToResponse.Status.ValueType  # 7
    """[Route Error] One or more of the waypoints specified weren't in the map."""

    STATUS_NO_PATH: NavigateToResponse.Status.ValueType  # 8
    """[Route Error] There is no path to the specified waypoint."""

    STATUS_FEATURE_DESERT: NavigateToResponse.Status.ValueType  # 10
    """[Route Error] Route contained too many waypoints with low-quality features."""

    STATUS_LOST: NavigateToResponse.Status.ValueType  # 11
    """[Route Error] Happens when you try to issue a navigate to while the robot is lost."""

    STATUS_NOT_LOCALIZED_TO_MAP: NavigateToResponse.Status.ValueType  # 13
    """[Route Error] Happens when the current localization doesn't refer to any waypoint in the map (possibly uninitialized localization)."""

    STATUS_COULD_NOT_UPDATE_ROUTE: NavigateToResponse.Status.ValueType  # 12
    """[Wrestling error] Happens when graph nav refuses to follow the route you specified."""

    STATUS_STUCK: NavigateToResponse.Status.ValueType  # 14
    """[Route Error] Happens when you try to issue a navigate to while the robot is stuck. Navigate to a different
    waypoint, or clear the route and try again.
    """

    STATUS_UNRECOGNIZED_COMMAND: NavigateToResponse.Status.ValueType  # 15
    """[Request Error] Happens when you try to continue a command that was either expired, or had an unrecognized id."""


    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULTS_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    IMPAIRED_STATE_FIELD_NUMBER: builtins.int
    COMMAND_ID_FIELD_NUMBER: builtins.int
    ERROR_WAYPOINT_IDS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.lease_pb2.LeaseUseResult]:
        """Results of using the various leases."""
        pass
    status: global___NavigateToResponse.Status.ValueType
    """Return status for the request."""

    @property
    def impaired_state(self) -> bosdyn.api.robot_state_pb2.RobotImpairedState:
        """If the status is ROBOT_IMPAIRED, this is why the robot is impaired."""
        pass
    command_id: builtins.int
    """Unique identifier for the command, If 0, command was not accepted."""

    @property
    def error_waypoint_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """On a relevant error status code, these fields contain the waypoint/edge IDs that caused the error."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_results: typing.Optional[typing.Iterable[bosdyn.api.lease_pb2.LeaseUseResult]] = ...,
        status: global___NavigateToResponse.Status.ValueType = ...,
        impaired_state: typing.Optional[bosdyn.api.robot_state_pb2.RobotImpairedState] = ...,
        command_id: builtins.int = ...,
        error_waypoint_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","impaired_state",b"impaired_state"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["command_id",b"command_id","error_waypoint_ids",b"error_waypoint_ids","header",b"header","impaired_state",b"impaired_state","lease_use_results",b"lease_use_results","status",b"status"]) -> None: ...
global___NavigateToResponse = NavigateToResponse

class RouteFollowingParams(google.protobuf.message.Message):
    """These parameters are specific to how the robot follows a specified route in NavigateRoute.
    For each enum in this message, if UNKNOWN is passed in, we default to one of the values
    (indicated in the comments). Passing UNKNOWN is not considered a programming error.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _StartRouteBehavior:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StartRouteBehaviorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RouteFollowingParams._StartRouteBehavior.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        START_UNKNOWN: RouteFollowingParams._StartRouteBehavior.ValueType  # 0
        """The mode is unset."""

        START_GOTO_START: RouteFollowingParams._StartRouteBehavior.ValueType  # 1
        """The robot will find the shortest path to the start of the route, possibly using
        edges that are not in the route. After going to the start, the robot will follow the
        route.
        """

        START_GOTO_ROUTE: RouteFollowingParams._StartRouteBehavior.ValueType  # 2
        """The robot will find the shortest path to any point on the route, and go to the point
        that gives that shortest path. Then, the robot will follow the rest of the route from
        that point.
        If multiple points on the route are similarly close to the robot, the robot will
        prefer the earliest on the route.
        This is the default.
        """

        START_FAIL_WHEN_NOT_ON_ROUTE: RouteFollowingParams._StartRouteBehavior.ValueType  # 3
        """The robot will fail the command with status STATUS_NOT_LOCALIZED_TO_ROUTE."""

    class StartRouteBehavior(_StartRouteBehavior, metaclass=_StartRouteBehaviorEnumTypeWrapper):
        """This setting applies when a new NavigateRoute command is issued (different route or
        final-waypoint-offset), and command_id indicates a new command.
        """
        pass

    START_UNKNOWN: RouteFollowingParams.StartRouteBehavior.ValueType  # 0
    """The mode is unset."""

    START_GOTO_START: RouteFollowingParams.StartRouteBehavior.ValueType  # 1
    """The robot will find the shortest path to the start of the route, possibly using
    edges that are not in the route. After going to the start, the robot will follow the
    route.
    """

    START_GOTO_ROUTE: RouteFollowingParams.StartRouteBehavior.ValueType  # 2
    """The robot will find the shortest path to any point on the route, and go to the point
    that gives that shortest path. Then, the robot will follow the rest of the route from
    that point.
    If multiple points on the route are similarly close to the robot, the robot will
    prefer the earliest on the route.
    This is the default.
    """

    START_FAIL_WHEN_NOT_ON_ROUTE: RouteFollowingParams.StartRouteBehavior.ValueType  # 3
    """The robot will fail the command with status STATUS_NOT_LOCALIZED_TO_ROUTE."""


    class _ResumeBehavior:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ResumeBehaviorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RouteFollowingParams._ResumeBehavior.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        RESUME_UNKNOWN: RouteFollowingParams._ResumeBehavior.ValueType  # 0
        """The mode is unset."""

        RESUME_RETURN_TO_UNFINISHED_ROUTE: RouteFollowingParams._ResumeBehavior.ValueType  # 1
        """The robot will find the shortest path to any point on the route after the
        furthest-along traversed edge, and go to the point that gives that shortest path.
        Then, the robot will follow the rest of the route from that point.
        This is the default.
        """

        RESUME_FAIL_WHEN_NOT_ON_ROUTE: RouteFollowingParams._ResumeBehavior.ValueType  # 2
        """The robot will fail the command with status STATUS_NOT_LOCALIZED_TO_ROUTE."""

    class ResumeBehavior(_ResumeBehavior, metaclass=_ResumeBehaviorEnumTypeWrapper):
        """This setting applies when a NavigateRoute command is issued with the same route and
        final-waypoint-offset. It is not necessary that command_id indicate the same command.
        The expected waypoint is the last waypoint that GraphNav was autonomously navigating to.
        """
        pass

    RESUME_UNKNOWN: RouteFollowingParams.ResumeBehavior.ValueType  # 0
    """The mode is unset."""

    RESUME_RETURN_TO_UNFINISHED_ROUTE: RouteFollowingParams.ResumeBehavior.ValueType  # 1
    """The robot will find the shortest path to any point on the route after the
    furthest-along traversed edge, and go to the point that gives that shortest path.
    Then, the robot will follow the rest of the route from that point.
    This is the default.
    """

    RESUME_FAIL_WHEN_NOT_ON_ROUTE: RouteFollowingParams.ResumeBehavior.ValueType  # 2
    """The robot will fail the command with status STATUS_NOT_LOCALIZED_TO_ROUTE."""


    class _RouteBlockedBehavior:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _RouteBlockedBehaviorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RouteFollowingParams._RouteBlockedBehavior.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        ROUTE_BLOCKED_UNKNOWN: RouteFollowingParams._RouteBlockedBehavior.ValueType  # 0
        """The mode is unset."""

        ROUTE_BLOCKED_REROUTE: RouteFollowingParams._RouteBlockedBehavior.ValueType  # 1
        """The robot will find the shortest path to any point after the furthest-along blockage,
        and after the furthest-along traversed edge, and go to the point that gives that
        shortest path. Then, the robot will follow the rest of the route from that point.
        If multiple points on the route are similarly close to the robot, the robot will
        prefer the earliest on the route.
        This is the default.
        """

        ROUTE_BLOCKED_FAIL: RouteFollowingParams._RouteBlockedBehavior.ValueType  # 2
        """The robot will fail the command with status STATUS_STUCK;"""

    class RouteBlockedBehavior(_RouteBlockedBehavior, metaclass=_RouteBlockedBehaviorEnumTypeWrapper):
        """This setting applies when the robot discovers that the route is blocked."""
        pass

    ROUTE_BLOCKED_UNKNOWN: RouteFollowingParams.RouteBlockedBehavior.ValueType  # 0
    """The mode is unset."""

    ROUTE_BLOCKED_REROUTE: RouteFollowingParams.RouteBlockedBehavior.ValueType  # 1
    """The robot will find the shortest path to any point after the furthest-along blockage,
    and after the furthest-along traversed edge, and go to the point that gives that
    shortest path. Then, the robot will follow the rest of the route from that point.
    If multiple points on the route are similarly close to the robot, the robot will
    prefer the earliest on the route.
    This is the default.
    """

    ROUTE_BLOCKED_FAIL: RouteFollowingParams.RouteBlockedBehavior.ValueType  # 2
    """The robot will fail the command with status STATUS_STUCK;"""


    NEW_CMD_BEHAVIOR_FIELD_NUMBER: builtins.int
    EXISTING_CMD_BEHAVIOR_FIELD_NUMBER: builtins.int
    ROUTE_BLOCKED_BEHAVIOR_FIELD_NUMBER: builtins.int
    new_cmd_behavior: global___RouteFollowingParams.StartRouteBehavior.ValueType
    existing_cmd_behavior: global___RouteFollowingParams.ResumeBehavior.ValueType
    route_blocked_behavior: global___RouteFollowingParams.RouteBlockedBehavior.ValueType
    def __init__(self,
        *,
        new_cmd_behavior: global___RouteFollowingParams.StartRouteBehavior.ValueType = ...,
        existing_cmd_behavior: global___RouteFollowingParams.ResumeBehavior.ValueType = ...,
        route_blocked_behavior: global___RouteFollowingParams.RouteBlockedBehavior.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["existing_cmd_behavior",b"existing_cmd_behavior","new_cmd_behavior",b"new_cmd_behavior","route_blocked_behavior",b"route_blocked_behavior"]) -> None: ...
global___RouteFollowingParams = RouteFollowingParams

class NavigateRouteRequest(google.protobuf.message.Message):
    """A NavigateRoute request message specifies a route of waypoints/edges and parameters
    about how to get there. Like NavigateTo, this command returns immediately upon
    processing and provides a command_id that the user can use along with a NavigationFeedbackRequest RPC to
    poll the system for feedback on this command. The RPC does not block until the route is completed.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASES_FIELD_NUMBER: builtins.int
    ROUTE_FIELD_NUMBER: builtins.int
    ROUTE_FOLLOW_PARAMS_FIELD_NUMBER: builtins.int
    TRAVEL_PARAMS_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    CLOCK_IDENTIFIER_FIELD_NUMBER: builtins.int
    DESTINATION_WAYPOINT_TFORM_BODY_GOAL_FIELD_NUMBER: builtins.int
    COMMAND_ID_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def leases(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.lease_pb2.Lease]:
        """The Lease to show ownership of the robot."""
        pass
    @property
    def route(self) -> bosdyn.api.graph_nav.nav_pb2.Route:
        """A route for the robot to follow."""
        pass
    @property
    def route_follow_params(self) -> global___RouteFollowingParams:
        """What should the robot do if it is not at the expected point in the route, or the route is
        blocked.
        """
        pass
    @property
    def travel_params(self) -> global___TravelParams:
        """How to travel the route."""
        pass
    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The timestamp (in robot time) that the navigation command is valid until."""
        pass
    clock_identifier: typing.Text
    """Identifier provided by the time sync service to verify time sync between robot and client."""

    @property
    def destination_waypoint_tform_body_goal(self) -> bosdyn.api.geometry_pb2.SE2Pose:
        """If provided, graph_nav will move the robot to an SE2 pose relative to the final waypoint
        in the route.
        Note that the robot will treat this as a simple goto request. It will first arrive at the
        destination waypoint, and then travel in a straight line from the destination waypoint to the
        offset goal, attempting to avoid obstacles along the way.
        """
        pass
    command_id: builtins.int
    """Unique identifier for the command. If 0, this is a new command, otherwise it is a continuation
    of an existing command.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        leases: typing.Optional[typing.Iterable[bosdyn.api.lease_pb2.Lease]] = ...,
        route: typing.Optional[bosdyn.api.graph_nav.nav_pb2.Route] = ...,
        route_follow_params: typing.Optional[global___RouteFollowingParams] = ...,
        travel_params: typing.Optional[global___TravelParams] = ...,
        end_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        clock_identifier: typing.Text = ...,
        destination_waypoint_tform_body_goal: typing.Optional[bosdyn.api.geometry_pb2.SE2Pose] = ...,
        command_id: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["destination_waypoint_tform_body_goal",b"destination_waypoint_tform_body_goal","end_time",b"end_time","header",b"header","route",b"route","route_follow_params",b"route_follow_params","travel_params",b"travel_params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["clock_identifier",b"clock_identifier","command_id",b"command_id","destination_waypoint_tform_body_goal",b"destination_waypoint_tform_body_goal","end_time",b"end_time","header",b"header","leases",b"leases","route",b"route","route_follow_params",b"route_follow_params","travel_params",b"travel_params"]) -> None: ...
global___NavigateRouteRequest = NavigateRouteRequest

class NavigateRouteResponse(google.protobuf.message.Message):
    """Response to a NavigateRouteRequest. This is returned immediately after the request is processed. A command_id
    is provided to specify the ID that the user may use to poll the system for feedback on the NavigateRoute command.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NavigateRouteResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: NavigateRouteResponse._Status.ValueType  # 0
        """An unknown / unexpected error occurred."""

        STATUS_OK: NavigateRouteResponse._Status.ValueType  # 1
        """Request was accepted."""

        STATUS_NO_TIMESYNC: NavigateRouteResponse._Status.ValueType  # 2
        """[Time Error] Client has not done timesync with robot."""

        STATUS_EXPIRED: NavigateRouteResponse._Status.ValueType  # 3
        """[Time Error] The command was received after its end time had already passed."""

        STATUS_TOO_DISTANT: NavigateRouteResponse._Status.ValueType  # 4
        """[Time Error] The command end time was too far in the future."""

        STATUS_ROBOT_IMPAIRED: NavigateRouteResponse._Status.ValueType  # 5
        """[Robot State Error] Cannot navigate a route if the robot has a crtical
         perception fault, or behavior fault, or LIDAR not working.
        """

        STATUS_RECORDING: NavigateRouteResponse._Status.ValueType  # 6
        """[Robot State Error] Cannot navigate a route while recording a map."""

        STATUS_UNKNOWN_ROUTE_ELEMENTS: NavigateRouteResponse._Status.ValueType  # 8
        """[Route Error] One or more waypoints/edges are not in the map."""

        STATUS_INVALID_EDGE: NavigateRouteResponse._Status.ValueType  # 9
        """[Route Error] One or more edges do not connect to expected waypoints."""

        STATUS_NO_PATH: NavigateRouteResponse._Status.ValueType  # 20
        """[Route Error] There is no path to the specified route."""

        STATUS_CONSTRAINT_FAULT: NavigateRouteResponse._Status.ValueType  # 11
        """[Route Error] Route contained a constraint fault."""

        STATUS_FEATURE_DESERT: NavigateRouteResponse._Status.ValueType  # 13
        """[Route Error] Route contained too many waypoints with low-quality features."""

        STATUS_LOST: NavigateRouteResponse._Status.ValueType  # 14
        """[Route Error] Happens when you try to issue a navigate route while the robot is lost."""

        STATUS_NOT_LOCALIZED_TO_ROUTE: NavigateRouteResponse._Status.ValueType  # 16
        """[Route Error] Happens when the current localization doesn't refer to any waypoint
        in the route (possibly uninitialized localization).
        """

        STATUS_NOT_LOCALIZED_TO_MAP: NavigateRouteResponse._Status.ValueType  # 19
        """[Route Error] Happens when the current localization doesn't refer to any waypoint in the map (possibly uninitialized localization)."""

        STATUS_COULD_NOT_UPDATE_ROUTE: NavigateRouteResponse._Status.ValueType  # 15
        """[Wrestling Errors] Happens when graph nav refuses to follow the route you specified.  Try saying please?"""

        STATUS_STUCK: NavigateRouteResponse._Status.ValueType  # 17
        """[Route Error] Happens when you try to issue a navigate to while the robot is stuck. Navigate a different
        route, or clear the route and try again.
        """

        STATUS_UNRECOGNIZED_COMMAND: NavigateRouteResponse._Status.ValueType  # 18
        """[Request Error] Happens when you try to continue a command that was either expired, or had an unrecognized id."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: NavigateRouteResponse.Status.ValueType  # 0
    """An unknown / unexpected error occurred."""

    STATUS_OK: NavigateRouteResponse.Status.ValueType  # 1
    """Request was accepted."""

    STATUS_NO_TIMESYNC: NavigateRouteResponse.Status.ValueType  # 2
    """[Time Error] Client has not done timesync with robot."""

    STATUS_EXPIRED: NavigateRouteResponse.Status.ValueType  # 3
    """[Time Error] The command was received after its end time had already passed."""

    STATUS_TOO_DISTANT: NavigateRouteResponse.Status.ValueType  # 4
    """[Time Error] The command end time was too far in the future."""

    STATUS_ROBOT_IMPAIRED: NavigateRouteResponse.Status.ValueType  # 5
    """[Robot State Error] Cannot navigate a route if the robot has a crtical
     perception fault, or behavior fault, or LIDAR not working.
    """

    STATUS_RECORDING: NavigateRouteResponse.Status.ValueType  # 6
    """[Robot State Error] Cannot navigate a route while recording a map."""

    STATUS_UNKNOWN_ROUTE_ELEMENTS: NavigateRouteResponse.Status.ValueType  # 8
    """[Route Error] One or more waypoints/edges are not in the map."""

    STATUS_INVALID_EDGE: NavigateRouteResponse.Status.ValueType  # 9
    """[Route Error] One or more edges do not connect to expected waypoints."""

    STATUS_NO_PATH: NavigateRouteResponse.Status.ValueType  # 20
    """[Route Error] There is no path to the specified route."""

    STATUS_CONSTRAINT_FAULT: NavigateRouteResponse.Status.ValueType  # 11
    """[Route Error] Route contained a constraint fault."""

    STATUS_FEATURE_DESERT: NavigateRouteResponse.Status.ValueType  # 13
    """[Route Error] Route contained too many waypoints with low-quality features."""

    STATUS_LOST: NavigateRouteResponse.Status.ValueType  # 14
    """[Route Error] Happens when you try to issue a navigate route while the robot is lost."""

    STATUS_NOT_LOCALIZED_TO_ROUTE: NavigateRouteResponse.Status.ValueType  # 16
    """[Route Error] Happens when the current localization doesn't refer to any waypoint
    in the route (possibly uninitialized localization).
    """

    STATUS_NOT_LOCALIZED_TO_MAP: NavigateRouteResponse.Status.ValueType  # 19
    """[Route Error] Happens when the current localization doesn't refer to any waypoint in the map (possibly uninitialized localization)."""

    STATUS_COULD_NOT_UPDATE_ROUTE: NavigateRouteResponse.Status.ValueType  # 15
    """[Wrestling Errors] Happens when graph nav refuses to follow the route you specified.  Try saying please?"""

    STATUS_STUCK: NavigateRouteResponse.Status.ValueType  # 17
    """[Route Error] Happens when you try to issue a navigate to while the robot is stuck. Navigate a different
    route, or clear the route and try again.
    """

    STATUS_UNRECOGNIZED_COMMAND: NavigateRouteResponse.Status.ValueType  # 18
    """[Request Error] Happens when you try to continue a command that was either expired, or had an unrecognized id."""


    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULTS_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    IMPAIRED_STATE_FIELD_NUMBER: builtins.int
    COMMAND_ID_FIELD_NUMBER: builtins.int
    ERROR_WAYPOINT_IDS_FIELD_NUMBER: builtins.int
    ERROR_EDGE_IDS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.lease_pb2.LeaseUseResult]:
        """Details about how the lease was used."""
        pass
    status: global___NavigateRouteResponse.Status.ValueType
    """Return status for the request."""

    @property
    def impaired_state(self) -> bosdyn.api.robot_state_pb2.RobotImpairedState:
        """If the status is ROBOT_IMPAIRED, this is why the robot is impaired."""
        pass
    command_id: builtins.int
    """Unique identifier for the command, If 0, command was not accepted."""

    @property
    def error_waypoint_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """On a relevant error status code, these fields contain the waypoint/edge IDs that caused the error."""
        pass
    @property
    def error_edge_ids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.graph_nav.map_pb2.Edge.Id]:
        """On a relevant error status code (STATUS_INVALID_EDGE), this is populated with the edge ID's that cased the error."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_results: typing.Optional[typing.Iterable[bosdyn.api.lease_pb2.LeaseUseResult]] = ...,
        status: global___NavigateRouteResponse.Status.ValueType = ...,
        impaired_state: typing.Optional[bosdyn.api.robot_state_pb2.RobotImpairedState] = ...,
        command_id: builtins.int = ...,
        error_waypoint_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        error_edge_ids: typing.Optional[typing.Iterable[bosdyn.api.graph_nav.map_pb2.Edge.Id]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","impaired_state",b"impaired_state"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["command_id",b"command_id","error_edge_ids",b"error_edge_ids","error_waypoint_ids",b"error_waypoint_ids","header",b"header","impaired_state",b"impaired_state","lease_use_results",b"lease_use_results","status",b"status"]) -> None: ...
global___NavigateRouteResponse = NavigateRouteResponse

class NavigateToAnchorRequest(google.protobuf.message.Message):
    """The NavigateToAnchorRequest can be used to command GraphNav to drive the robot to a specific
    place in an anchoring. GraphNav will find the waypoint that has the shortest path length from
    robot's current position but is still close to the goal. GraphNav will plan a path through the
    map which most efficiently gets the robot to the goal waypoint, and will then travel
    in a straight line from the destination waypoint to the offset goal, attempting to avoid
    obstacles along the way.
    Parameters are provided which influence how GraphNav will generate and follow the path.
    This RPC returns immediately after the request is processed. It does not block until GraphNav
    completes the path to the goal waypoint. The user is expected to periodically check the status
    of the NavigateToAnchor command using the NavigationFeedbackRequest RPC.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASES_FIELD_NUMBER: builtins.int
    SEED_TFORM_GOAL_FIELD_NUMBER: builtins.int
    GOAL_WAYPOINT_RT_SEED_EWRT_SEED_TOLERANCE_FIELD_NUMBER: builtins.int
    ROUTE_PARAMS_FIELD_NUMBER: builtins.int
    TRAVEL_PARAMS_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    CLOCK_IDENTIFIER_FIELD_NUMBER: builtins.int
    COMMAND_ID_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def leases(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.lease_pb2.Lease]:
        """The Leases to show ownership of the robot and the graph."""
        pass
    @property
    def seed_tform_goal(self) -> bosdyn.api.geometry_pb2.SE3Pose:
        """The goal, expressed with respect to the seed frame of the current anchoring.
        The robot will use the z value to find the goal waypoint, but the final z height the robot
        achieves will depend on the terrain height at the offset from the goal.
        """
        pass
    @property
    def goal_waypoint_rt_seed_ewrt_seed_tolerance(self) -> bosdyn.api.geometry_pb2.Vec3:
        """These parameters control selection of the goal waypoint. In seed frame, they are the x, y,
        and z tolerances with respect to the goal pose within which waypoints will be considered.
        If these values are negative, or too small, reasonable defaults will be used.
        """
        pass
    @property
    def route_params(self) -> global___RouteGenParams:
        """Preferences on how to pick the route."""
        pass
    @property
    def travel_params(self) -> global___TravelParams:
        """Parameters that define how to traverse and end the route."""
        pass
    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The timestamp (in robot time) that the navigation command is valid until."""
        pass
    clock_identifier: typing.Text
    """Identifier provided by the time sync service to verify time sync between robot and client."""

    command_id: builtins.int
    """Unique identifier for the command. If 0, this is a new command, otherwise it is a continuation
    of an existing command. If this is a continuation of an existing command, all parameters will be
    ignored, and the old parameters will be preserved.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        leases: typing.Optional[typing.Iterable[bosdyn.api.lease_pb2.Lease]] = ...,
        seed_tform_goal: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
        goal_waypoint_rt_seed_ewrt_seed_tolerance: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
        route_params: typing.Optional[global___RouteGenParams] = ...,
        travel_params: typing.Optional[global___TravelParams] = ...,
        end_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        clock_identifier: typing.Text = ...,
        command_id: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","goal_waypoint_rt_seed_ewrt_seed_tolerance",b"goal_waypoint_rt_seed_ewrt_seed_tolerance","header",b"header","route_params",b"route_params","seed_tform_goal",b"seed_tform_goal","travel_params",b"travel_params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["clock_identifier",b"clock_identifier","command_id",b"command_id","end_time",b"end_time","goal_waypoint_rt_seed_ewrt_seed_tolerance",b"goal_waypoint_rt_seed_ewrt_seed_tolerance","header",b"header","leases",b"leases","route_params",b"route_params","seed_tform_goal",b"seed_tform_goal","travel_params",b"travel_params"]) -> None: ...
global___NavigateToAnchorRequest = NavigateToAnchorRequest

class NavigateToAnchorResponse(google.protobuf.message.Message):
    """Response to a NavigateToAnchorRequest. This is returned immediately after the request is
    processed. A command_id is provided to specify the ID that the user may use to poll the system
    for feedback on the NavigateTo command.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NavigateToAnchorResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: NavigateToAnchorResponse._Status.ValueType  # 0
        """An unknown / unexpected error occurred."""

        STATUS_OK: NavigateToAnchorResponse._Status.ValueType  # 1
        """Request was accepted."""

        STATUS_NO_TIMESYNC: NavigateToAnchorResponse._Status.ValueType  # 2
        """[Time error] Client has not done timesync with robot."""

        STATUS_EXPIRED: NavigateToAnchorResponse._Status.ValueType  # 3
        """[Time error] The command was received after its end time had already passed."""

        STATUS_TOO_DISTANT: NavigateToAnchorResponse._Status.ValueType  # 4
        """[Time error]The command end time was too far in the future."""

        STATUS_ROBOT_IMPAIRED: NavigateToAnchorResponse._Status.ValueType  # 5
        """[Robot State Error] Cannot navigate a route if the robot has a critical
         perception fault, or behavior fault, or LIDAR not working.
        """

        STATUS_RECORDING: NavigateToAnchorResponse._Status.ValueType  # 6
        """[Robot State Error] Cannot navigate a route while recording a map."""

        STATUS_NO_ANCHORING: NavigateToAnchorResponse._Status.ValueType  # 7
        """[Route Error] There is no anchoring."""

        STATUS_NO_PATH: NavigateToAnchorResponse._Status.ValueType  # 8
        """[Route Error] There is no path to a waypoint near the specified goal.
                      If any waypoints were found (but no path), the error_waypoint_ids field
                      will be filled.
        """

        STATUS_FEATURE_DESERT: NavigateToAnchorResponse._Status.ValueType  # 10
        """[Route Error] Route contained too many waypoints with low-quality features."""

        STATUS_LOST: NavigateToAnchorResponse._Status.ValueType  # 11
        """[Route Error] Happens when you try to issue a navigate to while the robot is lost."""

        STATUS_NOT_LOCALIZED_TO_MAP: NavigateToAnchorResponse._Status.ValueType  # 13
        """[Route Error] Happens when the current localization doesn't refer to any waypoint in the map (possibly uninitialized localization)."""

        STATUS_COULD_NOT_UPDATE_ROUTE: NavigateToAnchorResponse._Status.ValueType  # 12
        """[Wrestling error] Happens when graph nav refuses to follow the route you specified."""

        STATUS_STUCK: NavigateToAnchorResponse._Status.ValueType  # 14
        """[Route Error] Happens when you try to issue a navigate to while the robot is stuck. Navigate to a different
        waypoint, or clear the route and try again.
        """

        STATUS_UNRECOGNIZED_COMMAND: NavigateToAnchorResponse._Status.ValueType  # 15
        """[Request Error] Happens when you try to continue a command that was either expired, or had an unrecognized id."""

        STATUS_INVALID_POSE: NavigateToAnchorResponse._Status.ValueType  # 16
        """[Route Error] The pose is invalid, or known to be unachievable (upside-down, etc)."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: NavigateToAnchorResponse.Status.ValueType  # 0
    """An unknown / unexpected error occurred."""

    STATUS_OK: NavigateToAnchorResponse.Status.ValueType  # 1
    """Request was accepted."""

    STATUS_NO_TIMESYNC: NavigateToAnchorResponse.Status.ValueType  # 2
    """[Time error] Client has not done timesync with robot."""

    STATUS_EXPIRED: NavigateToAnchorResponse.Status.ValueType  # 3
    """[Time error] The command was received after its end time had already passed."""

    STATUS_TOO_DISTANT: NavigateToAnchorResponse.Status.ValueType  # 4
    """[Time error]The command end time was too far in the future."""

    STATUS_ROBOT_IMPAIRED: NavigateToAnchorResponse.Status.ValueType  # 5
    """[Robot State Error] Cannot navigate a route if the robot has a critical
     perception fault, or behavior fault, or LIDAR not working.
    """

    STATUS_RECORDING: NavigateToAnchorResponse.Status.ValueType  # 6
    """[Robot State Error] Cannot navigate a route while recording a map."""

    STATUS_NO_ANCHORING: NavigateToAnchorResponse.Status.ValueType  # 7
    """[Route Error] There is no anchoring."""

    STATUS_NO_PATH: NavigateToAnchorResponse.Status.ValueType  # 8
    """[Route Error] There is no path to a waypoint near the specified goal.
                  If any waypoints were found (but no path), the error_waypoint_ids field
                  will be filled.
    """

    STATUS_FEATURE_DESERT: NavigateToAnchorResponse.Status.ValueType  # 10
    """[Route Error] Route contained too many waypoints with low-quality features."""

    STATUS_LOST: NavigateToAnchorResponse.Status.ValueType  # 11
    """[Route Error] Happens when you try to issue a navigate to while the robot is lost."""

    STATUS_NOT_LOCALIZED_TO_MAP: NavigateToAnchorResponse.Status.ValueType  # 13
    """[Route Error] Happens when the current localization doesn't refer to any waypoint in the map (possibly uninitialized localization)."""

    STATUS_COULD_NOT_UPDATE_ROUTE: NavigateToAnchorResponse.Status.ValueType  # 12
    """[Wrestling error] Happens when graph nav refuses to follow the route you specified."""

    STATUS_STUCK: NavigateToAnchorResponse.Status.ValueType  # 14
    """[Route Error] Happens when you try to issue a navigate to while the robot is stuck. Navigate to a different
    waypoint, or clear the route and try again.
    """

    STATUS_UNRECOGNIZED_COMMAND: NavigateToAnchorResponse.Status.ValueType  # 15
    """[Request Error] Happens when you try to continue a command that was either expired, or had an unrecognized id."""

    STATUS_INVALID_POSE: NavigateToAnchorResponse.Status.ValueType  # 16
    """[Route Error] The pose is invalid, or known to be unachievable (upside-down, etc)."""


    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULTS_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    IMPAIRED_STATE_FIELD_NUMBER: builtins.int
    COMMAND_ID_FIELD_NUMBER: builtins.int
    ERROR_WAYPOINT_IDS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[bosdyn.api.lease_pb2.LeaseUseResult]:
        """Results of using the various leases."""
        pass
    status: global___NavigateToAnchorResponse.Status.ValueType
    """Return status for the request."""

    @property
    def impaired_state(self) -> bosdyn.api.robot_state_pb2.RobotImpairedState:
        """If the status is ROBOT_IMPAIRED, this is why the robot is impaired."""
        pass
    command_id: builtins.int
    """Unique identifier for the command, If 0, command was not accepted."""

    @property
    def error_waypoint_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """On a relevant error status code, these fields contain the waypoint/edge IDs that caused the error."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_results: typing.Optional[typing.Iterable[bosdyn.api.lease_pb2.LeaseUseResult]] = ...,
        status: global___NavigateToAnchorResponse.Status.ValueType = ...,
        impaired_state: typing.Optional[bosdyn.api.robot_state_pb2.RobotImpairedState] = ...,
        command_id: builtins.int = ...,
        error_waypoint_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","impaired_state",b"impaired_state"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["command_id",b"command_id","error_waypoint_ids",b"error_waypoint_ids","header",b"header","impaired_state",b"impaired_state","lease_use_results",b"lease_use_results","status",b"status"]) -> None: ...
global___NavigateToAnchorResponse = NavigateToAnchorResponse

class NavigationFeedbackRequest(google.protobuf.message.Message):
    """The NavigationFeedback request message uses the command_id of a navigation request to get
    the robot's progress and current status for the command. Note that all commands return immediately
    after they are processed, and the robot will continue to execute the command asynchronously until
    it times out or completes. New commands override old ones.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    COMMAND_ID_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    command_id: builtins.int
    """Unique identifier for the command, provided by nav command response.
    Omit to get feedback on currently executing command.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        command_id: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["command_id",b"command_id","header",b"header"]) -> None: ...
global___NavigationFeedbackRequest = NavigationFeedbackRequest

class NavigationFeedbackResponse(google.protobuf.message.Message):
    """The NavigationFeedback response message returns the robot's
    progress and current status for the command.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NavigationFeedbackResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: NavigationFeedbackResponse._Status.ValueType  # 0
        """An unknown / unexpected error occurred."""

        STATUS_FOLLOWING_ROUTE: NavigationFeedbackResponse._Status.ValueType  # 1
        """The robot is currently, successfully following the route."""

        STATUS_REACHED_GOAL: NavigationFeedbackResponse._Status.ValueType  # 2
        """The robot has reached the final goal of the navigation request."""

        STATUS_NO_ROUTE: NavigationFeedbackResponse._Status.ValueType  # 3
        """There's no route currently being navigated.
        This can happen if no command has been issued, or if the graph has been changed during
        navigation.
        """

        STATUS_NO_LOCALIZATION: NavigationFeedbackResponse._Status.ValueType  # 4
        """Robot is not localized to a route."""

        STATUS_LOST: NavigationFeedbackResponse._Status.ValueType  # 5
        """Robot appears to be lost."""

        STATUS_STUCK: NavigationFeedbackResponse._Status.ValueType  # 6
        """Robot appears stuck against an obstacle."""

        STATUS_COMMAND_TIMED_OUT: NavigationFeedbackResponse._Status.ValueType  # 7
        """The command expired."""

        STATUS_ROBOT_IMPAIRED: NavigationFeedbackResponse._Status.ValueType  # 8
        """Cannot navigate a route if the robot has a crtical perception fault, or behavior fault,
        or LIDAR not working. See impared_status for details.
        """

        STATUS_CONSTRAINT_FAULT: NavigationFeedbackResponse._Status.ValueType  # 11
        """The route constraints were not feasible."""

        STATUS_COMMAND_OVERRIDDEN: NavigationFeedbackResponse._Status.ValueType  # 12
        """The command was replaced by a new command"""

        STATUS_NOT_LOCALIZED_TO_ROUTE: NavigationFeedbackResponse._Status.ValueType  # 13
        """The localization or route changed mid-traverse."""

        STATUS_LEASE_ERROR: NavigationFeedbackResponse._Status.ValueType  # 14
        """The lease is no longer valid."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: NavigationFeedbackResponse.Status.ValueType  # 0
    """An unknown / unexpected error occurred."""

    STATUS_FOLLOWING_ROUTE: NavigationFeedbackResponse.Status.ValueType  # 1
    """The robot is currently, successfully following the route."""

    STATUS_REACHED_GOAL: NavigationFeedbackResponse.Status.ValueType  # 2
    """The robot has reached the final goal of the navigation request."""

    STATUS_NO_ROUTE: NavigationFeedbackResponse.Status.ValueType  # 3
    """There's no route currently being navigated.
    This can happen if no command has been issued, or if the graph has been changed during
    navigation.
    """

    STATUS_NO_LOCALIZATION: NavigationFeedbackResponse.Status.ValueType  # 4
    """Robot is not localized to a route."""

    STATUS_LOST: NavigationFeedbackResponse.Status.ValueType  # 5
    """Robot appears to be lost."""

    STATUS_STUCK: NavigationFeedbackResponse.Status.ValueType  # 6
    """Robot appears stuck against an obstacle."""

    STATUS_COMMAND_TIMED_OUT: NavigationFeedbackResponse.Status.ValueType  # 7
    """The command expired."""

    STATUS_ROBOT_IMPAIRED: NavigationFeedbackResponse.Status.ValueType  # 8
    """Cannot navigate a route if the robot has a crtical perception fault, or behavior fault,
    or LIDAR not working. See impared_status for details.
    """

    STATUS_CONSTRAINT_FAULT: NavigationFeedbackResponse.Status.ValueType  # 11
    """The route constraints were not feasible."""

    STATUS_COMMAND_OVERRIDDEN: NavigationFeedbackResponse.Status.ValueType  # 12
    """The command was replaced by a new command"""

    STATUS_NOT_LOCALIZED_TO_ROUTE: NavigationFeedbackResponse.Status.ValueType  # 13
    """The localization or route changed mid-traverse."""

    STATUS_LEASE_ERROR: NavigationFeedbackResponse.Status.ValueType  # 14
    """The lease is no longer valid."""


    HEADER_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    IMPAIRED_STATE_FIELD_NUMBER: builtins.int
    REMAINING_ROUTE_FIELD_NUMBER: builtins.int
    COMMAND_ID_FIELD_NUMBER: builtins.int
    LAST_KO_TFORM_GOAL_FIELD_NUMBER: builtins.int
    BODY_MOVEMENT_STATUS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    status: global___NavigationFeedbackResponse.Status.ValueType
    """Return status for the request."""

    @property
    def impaired_state(self) -> bosdyn.api.robot_state_pb2.RobotImpairedState:
        """If the status is ROBOT_IMPAIRED, this is why the robot is impaired."""
        pass
    @property
    def remaining_route(self) -> bosdyn.api.graph_nav.nav_pb2.Route:
        """Remaining part of current route."""
        pass
    command_id: builtins.int
    """ID of the command this feedback corresponds to."""

    @property
    def last_ko_tform_goal(self) -> bosdyn.api.geometry_pb2.SE3Pose:
        """The most recent transform describing the robot's pose relative to the navigation goal."""
        pass
    body_movement_status: bosdyn.api.basic_command_pb2.SE2TrajectoryCommand.Feedback.BodyMovementStatus.ValueType
    """Indicates whether the robot's body is currently in motion."""

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        status: global___NavigationFeedbackResponse.Status.ValueType = ...,
        impaired_state: typing.Optional[bosdyn.api.robot_state_pb2.RobotImpairedState] = ...,
        remaining_route: typing.Optional[bosdyn.api.graph_nav.nav_pb2.Route] = ...,
        command_id: builtins.int = ...,
        last_ko_tform_goal: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
        body_movement_status: bosdyn.api.basic_command_pb2.SE2TrajectoryCommand.Feedback.BodyMovementStatus.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","impaired_state",b"impaired_state","last_ko_tform_goal",b"last_ko_tform_goal","remaining_route",b"remaining_route"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["body_movement_status",b"body_movement_status","command_id",b"command_id","header",b"header","impaired_state",b"impaired_state","last_ko_tform_goal",b"last_ko_tform_goal","remaining_route",b"remaining_route","status",b"status"]) -> None: ...
global___NavigationFeedbackResponse = NavigationFeedbackResponse

class GetLocalizationStateRequest(google.protobuf.message.Message):
    """The GetLocalizationState request message requests the current localization state and any other
    live data from the robot if desired. The localization consists of a waypoint ID and the relative
    pose of the robot with respect to that waypoint.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    WAYPOINT_ID_FIELD_NUMBER: builtins.int
    REQUEST_LIVE_POINT_CLOUD_FIELD_NUMBER: builtins.int
    REQUEST_LIVE_IMAGES_FIELD_NUMBER: builtins.int
    REQUEST_LIVE_TERRAIN_MAPS_FIELD_NUMBER: builtins.int
    REQUEST_LIVE_WORLD_OBJECTS_FIELD_NUMBER: builtins.int
    REQUEST_LIVE_ROBOT_STATE_FIELD_NUMBER: builtins.int
    COMPRESS_LIVE_POINT_CLOUD_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    waypoint_id: typing.Text
    """Return the localization relative to this waypoint, if specified."""

    request_live_point_cloud: builtins.bool
    """If true, request the live edge-segmented point cloud that was used
    to generate this localization.
    """

    request_live_images: builtins.bool
    """If true, request the live images from realsense cameras at the time of
    localization.
    """

    request_live_terrain_maps: builtins.bool
    """If true, request the live terrain maps at the time of localization."""

    request_live_world_objects: builtins.bool
    """If true, reqeuest the live world objects at the time of localization."""

    request_live_robot_state: builtins.bool
    """If true, requests the full live robot state at the time of localization."""

    compress_live_point_cloud: builtins.bool
    """If true, the smallest available encoding will be used for the live point cloud
    data. If false, three 32 bit floats will be used per point in the point cloud.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        waypoint_id: typing.Text = ...,
        request_live_point_cloud: builtins.bool = ...,
        request_live_images: builtins.bool = ...,
        request_live_terrain_maps: builtins.bool = ...,
        request_live_world_objects: builtins.bool = ...,
        request_live_robot_state: builtins.bool = ...,
        compress_live_point_cloud: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["compress_live_point_cloud",b"compress_live_point_cloud","header",b"header","request_live_images",b"request_live_images","request_live_point_cloud",b"request_live_point_cloud","request_live_robot_state",b"request_live_robot_state","request_live_terrain_maps",b"request_live_terrain_maps","request_live_world_objects",b"request_live_world_objects","waypoint_id",b"waypoint_id"]) -> None: ...
global___GetLocalizationStateRequest = GetLocalizationStateRequest

class RemotePointCloudStatus(google.protobuf.message.Message):
    """Message describing the state of a remote point cloud service (such as a velodyne)."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SERVICE_NAME_FIELD_NUMBER: builtins.int
    EXISTS_IN_DIRECTORY_FIELD_NUMBER: builtins.int
    HAS_DATA_FIELD_NUMBER: builtins.int
    service_name: typing.Text
    """The name of the point cloud service."""

    exists_in_directory: builtins.bool
    """Boolean indicating if the point cloud service was registered in the robot's directory with
    the provided name.
    """

    has_data: builtins.bool
    """Boolean indicating if the point cloud service is currently outputting data."""

    def __init__(self,
        *,
        service_name: typing.Text = ...,
        exists_in_directory: builtins.bool = ...,
        has_data: builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["exists_in_directory",b"exists_in_directory","has_data",b"has_data","service_name",b"service_name"]) -> None: ...
global___RemotePointCloudStatus = RemotePointCloudStatus

class LostDetectorState(google.protobuf.message.Message):
    """Message describing whether or not graph nav is lost, and if it is lost, how lost it is.
    If robot is lost, this state can be reset by either:
       * Driving to an area where the robot's localization improves.
       * Calling SetLocalization RPC.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    IS_LOST_FIELD_NUMBER: builtins.int
    is_lost: builtins.bool
    """Whether or not the robot is currently lost.  If this is true, graph nav will reject
    NavigateTo or NavigateRoute RPC's.
    """

    def __init__(self,
        *,
        is_lost: builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["is_lost",b"is_lost"]) -> None: ...
global___LostDetectorState = LostDetectorState

class GetLocalizationStateResponse(google.protobuf.message.Message):
    """The GetLocalizationState response message returns the current localization and robot state, as well
    as any requested live data information.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LOCALIZATION_FIELD_NUMBER: builtins.int
    ROBOT_KINEMATICS_FIELD_NUMBER: builtins.int
    REMOTE_CLOUD_STATUS_FIELD_NUMBER: builtins.int
    LIVE_DATA_FIELD_NUMBER: builtins.int
    LOST_DETECTOR_STATE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def localization(self) -> bosdyn.api.graph_nav.nav_pb2.Localization:
        """Where the robot currently is. If a waypoint_id was specified in the request, this localization
        will be relative to that waypoint.
        """
        pass
    @property
    def robot_kinematics(self) -> bosdyn.api.robot_state_pb2.KinematicState:
        """Robot kinematic state at time of localization."""
        pass
    @property
    def remote_cloud_status(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RemotePointCloudStatus]:
        """Status of one or more remote point cloud services (such as velodyne)."""
        pass
    @property
    def live_data(self) -> bosdyn.api.graph_nav.map_pb2.WaypointSnapshot:
        """Contains live data at the time of localization, with elements only filled out
        if requested.
        """
        pass
    @property
    def lost_detector_state(self) -> global___LostDetectorState:
        """If the robot drives around without a good localization for a while, eventually
        it becomes "lost."  I.E. it has a localization, but it no longer trusts
        that the localization it has is accurate.  Lost detector state is
        available through this message.
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        localization: typing.Optional[bosdyn.api.graph_nav.nav_pb2.Localization] = ...,
        robot_kinematics: typing.Optional[bosdyn.api.robot_state_pb2.KinematicState] = ...,
        remote_cloud_status: typing.Optional[typing.Iterable[global___RemotePointCloudStatus]] = ...,
        live_data: typing.Optional[bosdyn.api.graph_nav.map_pb2.WaypointSnapshot] = ...,
        lost_detector_state: typing.Optional[global___LostDetectorState] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","live_data",b"live_data","localization",b"localization","lost_detector_state",b"lost_detector_state","robot_kinematics",b"robot_kinematics"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","live_data",b"live_data","localization",b"localization","lost_detector_state",b"lost_detector_state","remote_cloud_status",b"remote_cloud_status","robot_kinematics",b"robot_kinematics"]) -> None: ...
global___GetLocalizationStateResponse = GetLocalizationStateResponse

class ClearGraphRequest(google.protobuf.message.Message):
    """Clears the graph on the server. Also clears GraphNav's localization to the graph.
    Note that waypoint and edge snapshots may still be cached on the server after this
    operation.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The Lease to show ownership of graph-nav service."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease"]) -> None: ...
global___ClearGraphRequest = ClearGraphRequest

class ClearGraphResponse(google.protobuf.message.Message):
    """The results of the ClearGraphRequest."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """Details about how the lease was used."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> None: ...
global___ClearGraphResponse = ClearGraphResponse

class UploadGraphRequest(google.protobuf.message.Message):
    """Uploads a graph to the server. This graph will be appended to the graph that
    currently exists on the server.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    GRAPH_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    GENERATE_NEW_ANCHORING_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def graph(self) -> bosdyn.api.graph_nav.map_pb2.Graph:
        """Structure of the graph containing waypoints and edges without
        underlying sensor data.
        """
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The Lease to show ownership of graph-nav service."""
        pass
    generate_new_anchoring: builtins.bool
    """If this is true, generate an (overwrite the) anchoring on upload."""

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        graph: typing.Optional[bosdyn.api.graph_nav.map_pb2.Graph] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        generate_new_anchoring: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["graph",b"graph","header",b"header","lease",b"lease"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["generate_new_anchoring",b"generate_new_anchoring","graph",b"graph","header",b"header","lease",b"lease"]) -> None: ...
global___UploadGraphRequest = UploadGraphRequest

class UploadGraphResponse(google.protobuf.message.Message):
    """Response to the UploadGraphRequest. After uploading a graph, the user is expected
    to upload large data at waypoints and edges (called snapshots). The response provides
    a list of snapshot IDs which are not yet cached on the server. Snapshots with these IDs should
    be uploaded by the client.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[UploadGraphResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: UploadGraphResponse._Status.ValueType  # 0
        STATUS_OK: UploadGraphResponse._Status.ValueType  # 1
        STATUS_MAP_TOO_LARGE_LICENSE: UploadGraphResponse._Status.ValueType  # 3
        """Can't upload the graph because it was too large for the license."""

        STATUS_INVALID_GRAPH: UploadGraphResponse._Status.ValueType  # 4
        """The graph is invalid topologically, for example containing missing waypoints referenced by edges."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: UploadGraphResponse.Status.ValueType  # 0
    STATUS_OK: UploadGraphResponse.Status.ValueType  # 1
    STATUS_MAP_TOO_LARGE_LICENSE: UploadGraphResponse.Status.ValueType  # 3
    """Can't upload the graph because it was too large for the license."""

    STATUS_INVALID_GRAPH: UploadGraphResponse.Status.ValueType  # 4
    """The graph is invalid topologically, for example containing missing waypoints referenced by edges."""


    HEADER_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    LOADED_WAYPOINT_SNAPSHOT_IDS_FIELD_NUMBER: builtins.int
    UNKNOWN_WAYPOINT_SNAPSHOT_IDS_FIELD_NUMBER: builtins.int
    LOADED_EDGE_SNAPSHOT_IDS_FIELD_NUMBER: builtins.int
    UNKNOWN_EDGE_SNAPSHOT_IDS_FIELD_NUMBER: builtins.int
    LICENSE_STATUS_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    status: global___UploadGraphResponse.Status.ValueType
    """Status for an upload request."""

    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """Details about how the lease was used."""
        pass
    @property
    def loaded_waypoint_snapshot_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The waypoint snapshot ids for which there was cached data."""
        pass
    @property
    def unknown_waypoint_snapshot_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The waypoint snapshot ids for which there is no cached data."""
        pass
    @property
    def loaded_edge_snapshot_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The edge snapshot ids for which there was cached data."""
        pass
    @property
    def unknown_edge_snapshot_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The edge snapshot ids for which there was no cached data."""
        pass
    license_status: bosdyn.api.license_pb2.LicenseInfo.Status.ValueType
    """Large graphs can only be uploaded if the license permits them."""

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        status: global___UploadGraphResponse.Status.ValueType = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        loaded_waypoint_snapshot_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        unknown_waypoint_snapshot_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        loaded_edge_snapshot_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        unknown_edge_snapshot_ids: typing.Optional[typing.Iterable[typing.Text]] = ...,
        license_status: bosdyn.api.license_pb2.LicenseInfo.Status.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result","license_status",b"license_status","loaded_edge_snapshot_ids",b"loaded_edge_snapshot_ids","loaded_waypoint_snapshot_ids",b"loaded_waypoint_snapshot_ids","status",b"status","unknown_edge_snapshot_ids",b"unknown_edge_snapshot_ids","unknown_waypoint_snapshot_ids",b"unknown_waypoint_snapshot_ids"]) -> None: ...
global___UploadGraphResponse = UploadGraphResponse

class DownloadGraphRequest(google.protobuf.message.Message):
    """The DownloadGraphRequest requests that the server send the graph (waypoints and edges)
    to the client. Note that the returned Graph message contains only the topological
    structure of the map, and not any large sensor data. Large sensor data should be downloaded
    using DownloadWaypointSnapshotRequest and DownloadEdgeSnapshotRequest. Both snapshots and
    the graph are required to exist on the server for GraphNav to localize and navigate.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header"]) -> None: ...
global___DownloadGraphRequest = DownloadGraphRequest

class DownloadGraphResponse(google.protobuf.message.Message):
    """The DownloadGraph response message includes the current graph on the robot."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    GRAPH_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common request header."""
        pass
    @property
    def graph(self) -> bosdyn.api.graph_nav.map_pb2.Graph:
        """The structure of the graph."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        graph: typing.Optional[bosdyn.api.graph_nav.map_pb2.Graph] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["graph",b"graph","header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["graph",b"graph","header",b"header"]) -> None: ...
global___DownloadGraphResponse = DownloadGraphResponse

class UploadWaypointSnapshotRequest(google.protobuf.message.Message):
    """Used to upload waypoint snapshot in chunks for a specific waypoint snapshot. Waypoint
    snapshots consist of the large sensor data at each waypoint.
    Chunks will be streamed one at a time to the server. Chunk streaming is required to prevent
    overwhelming gRPC with large http requests.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    CHUNK_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common response header."""
        pass
    @property
    def chunk(self) -> bosdyn.api.data_chunk_pb2.DataChunk:
        """Serialized bytes of a WaypointSnapshot message, restricted to a chunk no larger than 4MB in size.
        To break the data into chunks, first serialize it to bytes. Then, send the bytes in order as DataChunk objects.
        The chunks will be concatenated together on the server, and deserialized.
        """
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The Leases to show ownership of the graph-nav service."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        chunk: typing.Optional[bosdyn.api.data_chunk_pb2.DataChunk] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["chunk",b"chunk","header",b"header","lease",b"lease"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunk",b"chunk","header",b"header","lease",b"lease"]) -> None: ...
global___UploadWaypointSnapshotRequest = UploadWaypointSnapshotRequest

class UploadWaypointSnapshotResponse(google.protobuf.message.Message):
    """One response for the entire WaypointSnapshot after all chunks have
    been concatenated and deserialized.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """Details about how the lease was used."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> None: ...
global___UploadWaypointSnapshotResponse = UploadWaypointSnapshotResponse

class UploadEdgeSnapshotRequest(google.protobuf.message.Message):
    """Used to upload edge data in chunks for a specific edge snapshot. Edge snapshots contain
    large sensor data associated with each edge.
    Chunks will be streamed one at a time to the server. Chunk streaming is required to prevent
    overwhelming gRPC with large http requests.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    CHUNK_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common response header."""
        pass
    @property
    def chunk(self) -> bosdyn.api.data_chunk_pb2.DataChunk:
        """Serialized bytes of a EdgeSnapshot message, restricted to a chunk no larger than 4MB in size.
        To break the data into chunks, first serialize it to bytes. Then, send the bytes in order as DataChunk objects.
        The chunks will be concatenated together on the server, and deserialized
        """
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The Leases to show ownership of the graph-nav service."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        chunk: typing.Optional[bosdyn.api.data_chunk_pb2.DataChunk] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["chunk",b"chunk","header",b"header","lease",b"lease"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunk",b"chunk","header",b"header","lease",b"lease"]) -> None: ...
global___UploadEdgeSnapshotRequest = UploadEdgeSnapshotRequest

class UploadEdgeSnapshotResponse(google.protobuf.message.Message):
    """One response for the entire EdgeSnapshot after all chunks have
    been concatenated and deserialized.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """Details about how the lease was used."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> None: ...
global___UploadEdgeSnapshotResponse = UploadEdgeSnapshotResponse

class DownloadWaypointSnapshotRequest(google.protobuf.message.Message):
    """The DownloadWaypointSnapshot request asks for a specific waypoint snapshot id to
    be downloaded and has parameters to decrease the amount of data downloaded. After
    recording a map, first call the DownloadGraph RPC. Then, for each waypoint snapshot id,
    request the waypoint snapshot from the server using the DownloadWaypointSnapshot RPC.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    WAYPOINT_SNAPSHOT_ID_FIELD_NUMBER: builtins.int
    DOWNLOAD_IMAGES_FIELD_NUMBER: builtins.int
    COMPRESS_POINT_CLOUD_FIELD_NUMBER: builtins.int
    DO_NOT_DOWNLOAD_POINT_CLOUD_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    waypoint_snapshot_id: typing.Text
    """ID of the snapshot associated with a waypoint."""

    download_images: builtins.bool
    """If true, download the full images and point clouds from
    each camera.
    """

    compress_point_cloud: builtins.bool
    """If true, the point cloud will be compressed using the smallest
    available point cloud encoding. If false, three 32-bit floats will
    be used per point.
    """

    do_not_download_point_cloud: builtins.bool
    """Skip downloading the point cloud, and only download other data such as images or world
    objects.
    """

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        waypoint_snapshot_id: typing.Text = ...,
        download_images: builtins.bool = ...,
        compress_point_cloud: builtins.bool = ...,
        do_not_download_point_cloud: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["compress_point_cloud",b"compress_point_cloud","do_not_download_point_cloud",b"do_not_download_point_cloud","download_images",b"download_images","header",b"header","waypoint_snapshot_id",b"waypoint_snapshot_id"]) -> None: ...
global___DownloadWaypointSnapshotRequest = DownloadWaypointSnapshotRequest

class DownloadWaypointSnapshotResponse(google.protobuf.message.Message):
    """The DownloadWaypointSnapshot response streams the data of the waypoint snapshot id
    currently being downloaded in data chunks no larger than 4MB in size. It is necessary
    to stream these data to avoid overwhelming gRPC with large http requests.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DownloadWaypointSnapshotResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: DownloadWaypointSnapshotResponse._Status.ValueType  # 0
        STATUS_OK: DownloadWaypointSnapshotResponse._Status.ValueType  # 1
        STATUS_SNAPSHOT_DOES_NOT_EXIST: DownloadWaypointSnapshotResponse._Status.ValueType  # 2
        """Error where the given snapshot ID does not exist."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: DownloadWaypointSnapshotResponse.Status.ValueType  # 0
    STATUS_OK: DownloadWaypointSnapshotResponse.Status.ValueType  # 1
    STATUS_SNAPSHOT_DOES_NOT_EXIST: DownloadWaypointSnapshotResponse.Status.ValueType  # 2
    """Error where the given snapshot ID does not exist."""


    HEADER_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    WAYPOINT_SNAPSHOT_ID_FIELD_NUMBER: builtins.int
    CHUNK_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    status: global___DownloadWaypointSnapshotResponse.Status.ValueType
    """Return status for the request."""

    waypoint_snapshot_id: typing.Text
    """ID of the snapshot associated with a waypoint."""

    @property
    def chunk(self) -> bosdyn.api.data_chunk_pb2.DataChunk:
        """Chunk of data to download. Responses are sent in sequence until the
        data chunk is complete. After receiving all chunks, concatenate them
        into a single byte string. Then, deserialize the byte string into a
        WaypointSnapshot object.
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        status: global___DownloadWaypointSnapshotResponse.Status.ValueType = ...,
        waypoint_snapshot_id: typing.Text = ...,
        chunk: typing.Optional[bosdyn.api.data_chunk_pb2.DataChunk] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["chunk",b"chunk","header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunk",b"chunk","header",b"header","status",b"status","waypoint_snapshot_id",b"waypoint_snapshot_id"]) -> None: ...
global___DownloadWaypointSnapshotResponse = DownloadWaypointSnapshotResponse

class DownloadEdgeSnapshotRequest(google.protobuf.message.Message):
    """The DownloadEdgeSnapshot request asks for a specific edge snapshot id to
    be downloaded. Edge snapshots contain the large sensor data stored in each edge.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    EDGE_SNAPSHOT_ID_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    edge_snapshot_id: typing.Text
    """ID of the data associated with an edge."""

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        edge_snapshot_id: typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["edge_snapshot_id",b"edge_snapshot_id","header",b"header"]) -> None: ...
global___DownloadEdgeSnapshotRequest = DownloadEdgeSnapshotRequest

class DownloadEdgeSnapshotResponse(google.protobuf.message.Message):
    """The DownloadEdgeSnapshot response streams the data of the edge snapshot id
    currently being downloaded in data chunks no larger than 4MB in size. It is necessary
    to stream these data to avoid overwhelming gRPC with large http requests.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DownloadEdgeSnapshotResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: DownloadEdgeSnapshotResponse._Status.ValueType  # 0
        STATUS_OK: DownloadEdgeSnapshotResponse._Status.ValueType  # 1
        STATUS_SNAPSHOT_DOES_NOT_EXIST: DownloadEdgeSnapshotResponse._Status.ValueType  # 2
        """Error where the given snapshot ID does not exist."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: DownloadEdgeSnapshotResponse.Status.ValueType  # 0
    STATUS_OK: DownloadEdgeSnapshotResponse.Status.ValueType  # 1
    STATUS_SNAPSHOT_DOES_NOT_EXIST: DownloadEdgeSnapshotResponse.Status.ValueType  # 2
    """Error where the given snapshot ID does not exist."""


    HEADER_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    EDGE_SNAPSHOT_ID_FIELD_NUMBER: builtins.int
    CHUNK_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    status: global___DownloadEdgeSnapshotResponse.Status.ValueType
    """Return status for the request."""

    edge_snapshot_id: typing.Text
    """ID of the snapshot associated with an edge."""

    @property
    def chunk(self) -> bosdyn.api.data_chunk_pb2.DataChunk:
        """Chunk of data to download. Responses are sent in sequence until the
        data chunk is complete. After receiving all chunks, concatenate them
        into a single byte string. Then, deserialize the byte string into an
        EdgeSnapshot object.
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        status: global___DownloadEdgeSnapshotResponse.Status.ValueType = ...,
        edge_snapshot_id: typing.Text = ...,
        chunk: typing.Optional[bosdyn.api.data_chunk_pb2.DataChunk] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["chunk",b"chunk","header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunk",b"chunk","edge_snapshot_id",b"edge_snapshot_id","header",b"header","status",b"status"]) -> None: ...
global___DownloadEdgeSnapshotResponse = DownloadEdgeSnapshotResponse
