"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.arm_command_pb2
import bosdyn.api.geometry_pb2
import bosdyn.api.gripper_command_pb2
import bosdyn.api.trajectory_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class ArmSurfaceContact(google.protobuf.message.Message):
    """ArmSurfaceContact lets you accurately move the robot's arm in the world while having some ability
    to perform force control.  This mode is useful for drawing, wiping, and other similar behaviors.

    The message is similar to the ArmCartesianCommand message, which you can look at for additional
    details.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _AxisMode:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _AxisModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ArmSurfaceContact.Request._AxisMode.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            AXIS_MODE_POSITION: ArmSurfaceContact.Request._AxisMode.ValueType  # 0
            AXIS_MODE_FORCE: ArmSurfaceContact.Request._AxisMode.ValueType  # 1
        class AxisMode(_AxisMode, metaclass=_AxisModeEnumTypeWrapper):
            """If an axis is set to position mode (default), read desired from SE3Trajectory command.
            If mode is set to force, use the "press_force_percentage" field to determine force.
            """
            pass

        AXIS_MODE_POSITION: ArmSurfaceContact.Request.AxisMode.ValueType  # 0
        AXIS_MODE_FORCE: ArmSurfaceContact.Request.AxisMode.ValueType  # 1

        class _AdmittanceSetting:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _AdmittanceSettingEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ArmSurfaceContact.Request._AdmittanceSetting.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            ADMITTANCE_SETTING_UNKNOWN: ArmSurfaceContact.Request._AdmittanceSetting.ValueType  # 0
            ADMITTANCE_SETTING_OFF: ArmSurfaceContact.Request._AdmittanceSetting.ValueType  # 1
            """No admittance."""

            ADMITTANCE_SETTING_NORMAL: ArmSurfaceContact.Request._AdmittanceSetting.ValueType  # 2
            """Normal reaction to touching things in the world"""

            ADMITTANCE_SETTING_LOOSE: ArmSurfaceContact.Request._AdmittanceSetting.ValueType  # 3
            """Robot will not push very hard against objects"""

            ADMITTANCE_SETTING_STIFF: ArmSurfaceContact.Request._AdmittanceSetting.ValueType  # 4
            """Robot will push hard against the world"""

            ADMITTANCE_SETTING_VERY_STIFF: ArmSurfaceContact.Request._AdmittanceSetting.ValueType  # 5
            """Robot will push very hard against the world"""

        class AdmittanceSetting(_AdmittanceSetting, metaclass=_AdmittanceSettingEnumTypeWrapper):
            """Parameters for controlling admittance.  By default, the robot will
            stop moving the arm when it encounters resistance.  You can control that reaction to
            make the robot stiffer or less stiff by changing the parameters.
            """
            pass

        ADMITTANCE_SETTING_UNKNOWN: ArmSurfaceContact.Request.AdmittanceSetting.ValueType  # 0
        ADMITTANCE_SETTING_OFF: ArmSurfaceContact.Request.AdmittanceSetting.ValueType  # 1
        """No admittance."""

        ADMITTANCE_SETTING_NORMAL: ArmSurfaceContact.Request.AdmittanceSetting.ValueType  # 2
        """Normal reaction to touching things in the world"""

        ADMITTANCE_SETTING_LOOSE: ArmSurfaceContact.Request.AdmittanceSetting.ValueType  # 3
        """Robot will not push very hard against objects"""

        ADMITTANCE_SETTING_STIFF: ArmSurfaceContact.Request.AdmittanceSetting.ValueType  # 4
        """Robot will push hard against the world"""

        ADMITTANCE_SETTING_VERY_STIFF: ArmSurfaceContact.Request.AdmittanceSetting.ValueType  # 5
        """Robot will push very hard against the world"""


        ROOT_FRAME_NAME_FIELD_NUMBER: builtins.int
        WRIST_TFORM_TOOL_FIELD_NUMBER: builtins.int
        ROOT_TFORM_TASK_FIELD_NUMBER: builtins.int
        POSE_TRAJECTORY_IN_TASK_FIELD_NUMBER: builtins.int
        MAXIMUM_ACCELERATION_FIELD_NUMBER: builtins.int
        MAX_LINEAR_VELOCITY_FIELD_NUMBER: builtins.int
        MAX_ANGULAR_VELOCITY_FIELD_NUMBER: builtins.int
        MAX_POS_TRACKING_ERROR_FIELD_NUMBER: builtins.int
        MAX_ROT_TRACKING_ERROR_FIELD_NUMBER: builtins.int
        FORCE_REMAIN_NEAR_CURRENT_JOINT_CONFIGURATION_FIELD_NUMBER: builtins.int
        PREFERRED_JOINT_CONFIGURATION_FIELD_NUMBER: builtins.int
        X_AXIS_FIELD_NUMBER: builtins.int
        Y_AXIS_FIELD_NUMBER: builtins.int
        Z_AXIS_FIELD_NUMBER: builtins.int
        PRESS_FORCE_PERCENTAGE_FIELD_NUMBER: builtins.int
        XY_ADMITTANCE_FIELD_NUMBER: builtins.int
        Z_ADMITTANCE_FIELD_NUMBER: builtins.int
        XY_TO_Z_CROSS_TERM_ADMITTANCE_FIELD_NUMBER: builtins.int
        BIAS_FORCE_EWRT_BODY_FIELD_NUMBER: builtins.int
        GRIPPER_COMMAND_FIELD_NUMBER: builtins.int
        IS_ROBOT_FOLLOWING_HAND_FIELD_NUMBER: builtins.int
        root_frame_name: typing.Text
        """The root frame is used to set the optional task frame that all trajectories are 
        specified with respect to.  If the optional task frame is left un-specified it defaults
        to the identity transform and the root frame becomes the task frame.
        """

        @property
        def wrist_tform_tool(self) -> bosdyn.api.geometry_pb2.SE3Pose:
            """The tool pose relative to the parent link (wrist).
            Defaults to
               [0.19557 0 0]
               [1 0 0 0]
            a frame with it's origin slightly in front of the gripper's palm plate aligned with wrists orientation.
            """
            pass
        @property
        def root_tform_task(self) -> bosdyn.api.geometry_pb2.SE3Pose:
            """The fields below are specified in this optional task frame.  If unset int defaults
            to the identity transform and all quantities are therefore expressed in the root_frame_name.
            """
            pass
        @property
        def pose_trajectory_in_task(self) -> bosdyn.api.trajectory_pb2.SE3Trajectory:
            """A 3D pose trajectory for the tool expressed in the task frame, e.g. task_T_tool.
            This pose trajectory is optional if requesting a pure wrench at the end-effector, 
            otherwise required for position or mixed force/position end-effector requests.
            """
            pass
        @property
        def maximum_acceleration(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional Maximum acceleration magnitude of the end-effector.
            Valid ranges (0, 20]
            """
            pass
        @property
        def max_linear_velocity(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional Maximum linear velocity magnitude of the end-effector. (m/s)"""
            pass
        @property
        def max_angular_velocity(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional Maximum angular velocity magnitude of the end-effector. (rad/s)"""
            pass
        @property
        def max_pos_tracking_error(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Maximum allowable tracking error of the tool frame from the desired trajectory
            before the arm will stop moving and cancel the rest of the trajectory. When this limit is exceeded, the
            hand will stay at the pose it was at when it exceeded the tracking error, and any other part of the
            trajectory specified in the rest of this message will be ignored.
            max position tracking error in meters
            """
            pass
        @property
        def max_rot_tracking_error(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """max orientation tracking error in radians"""
            pass
        force_remain_near_current_joint_configuration: builtins.bool
        @property
        def preferred_joint_configuration(self) -> bosdyn.api.arm_command_pb2.ArmJointPosition: ...
        x_axis: global___ArmSurfaceContact.Request.AxisMode.ValueType
        y_axis: global___ArmSurfaceContact.Request.AxisMode.ValueType
        z_axis: global___ArmSurfaceContact.Request.AxisMode.ValueType
        @property
        def press_force_percentage(self) -> bosdyn.api.geometry_pb2.Vec3:
            """Amount of force to use on each axis, from 0 (no force) to 1.0 (maximum force), can also
            be negative.  Full range: [-1.0, 1.0]
            """
            pass
        xy_admittance: global___ArmSurfaceContact.Request.AdmittanceSetting.ValueType
        """Admittance settings for each axis in the admittance frame."""

        z_admittance: global___ArmSurfaceContact.Request.AdmittanceSetting.ValueType
        xy_to_z_cross_term_admittance: global___ArmSurfaceContact.Request.AdmittanceSetting.ValueType
        """Cross term, making force in the XY axis cause movement in the z-axis.
        By default is OFF
        Setting this value will make the arm move in the negative Z-axis whenever it feels force in
        the XY axis.
        """

        @property
        def bias_force_ewrt_body(self) -> bosdyn.api.geometry_pb2.Vec3:
            """Specifies a force that the body should expect to feel.  This allows the robot to "lean into"
            an external force.  Be careful using this field, because if you lie to the robot, it can
            fall over.
            """
            pass
        @property
        def gripper_command(self) -> bosdyn.api.gripper_command_pb2.ClawGripperCommand.Request:
            """Gripper control"""
            pass
        is_robot_following_hand: builtins.bool
        """Set to true to have robot is walk around to follow the hand."""

        def __init__(self,
            *,
            root_frame_name: typing.Text = ...,
            wrist_tform_tool: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
            root_tform_task: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
            pose_trajectory_in_task: typing.Optional[bosdyn.api.trajectory_pb2.SE3Trajectory] = ...,
            maximum_acceleration: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_linear_velocity: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_angular_velocity: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_pos_tracking_error: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_rot_tracking_error: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            force_remain_near_current_joint_configuration: builtins.bool = ...,
            preferred_joint_configuration: typing.Optional[bosdyn.api.arm_command_pb2.ArmJointPosition] = ...,
            x_axis: global___ArmSurfaceContact.Request.AxisMode.ValueType = ...,
            y_axis: global___ArmSurfaceContact.Request.AxisMode.ValueType = ...,
            z_axis: global___ArmSurfaceContact.Request.AxisMode.ValueType = ...,
            press_force_percentage: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
            xy_admittance: global___ArmSurfaceContact.Request.AdmittanceSetting.ValueType = ...,
            z_admittance: global___ArmSurfaceContact.Request.AdmittanceSetting.ValueType = ...,
            xy_to_z_cross_term_admittance: global___ArmSurfaceContact.Request.AdmittanceSetting.ValueType = ...,
            bias_force_ewrt_body: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
            gripper_command: typing.Optional[bosdyn.api.gripper_command_pb2.ClawGripperCommand.Request] = ...,
            is_robot_following_hand: builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["bias_force_ewrt_body",b"bias_force_ewrt_body","force_remain_near_current_joint_configuration",b"force_remain_near_current_joint_configuration","gripper_command",b"gripper_command","joint_configuration",b"joint_configuration","max_angular_velocity",b"max_angular_velocity","max_linear_velocity",b"max_linear_velocity","max_pos_tracking_error",b"max_pos_tracking_error","max_rot_tracking_error",b"max_rot_tracking_error","maximum_acceleration",b"maximum_acceleration","pose_trajectory_in_task",b"pose_trajectory_in_task","preferred_joint_configuration",b"preferred_joint_configuration","press_force_percentage",b"press_force_percentage","root_tform_task",b"root_tform_task","wrist_tform_tool",b"wrist_tform_tool"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["bias_force_ewrt_body",b"bias_force_ewrt_body","force_remain_near_current_joint_configuration",b"force_remain_near_current_joint_configuration","gripper_command",b"gripper_command","is_robot_following_hand",b"is_robot_following_hand","joint_configuration",b"joint_configuration","max_angular_velocity",b"max_angular_velocity","max_linear_velocity",b"max_linear_velocity","max_pos_tracking_error",b"max_pos_tracking_error","max_rot_tracking_error",b"max_rot_tracking_error","maximum_acceleration",b"maximum_acceleration","pose_trajectory_in_task",b"pose_trajectory_in_task","preferred_joint_configuration",b"preferred_joint_configuration","press_force_percentage",b"press_force_percentage","root_frame_name",b"root_frame_name","root_tform_task",b"root_tform_task","wrist_tform_tool",b"wrist_tform_tool","x_axis",b"x_axis","xy_admittance",b"xy_admittance","xy_to_z_cross_term_admittance",b"xy_to_z_cross_term_admittance","y_axis",b"y_axis","z_admittance",b"z_admittance","z_axis",b"z_axis"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["joint_configuration",b"joint_configuration"]) -> typing.Optional[typing_extensions.Literal["force_remain_near_current_joint_configuration","preferred_joint_configuration"]]: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    def __init__(self,
        ) -> None: ...
global___ArmSurfaceContact = ArmSurfaceContact
