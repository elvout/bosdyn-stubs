"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.basic_command_pb2
import bosdyn.api.geometry_pb2
import bosdyn.api.trajectory_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class ArmCommand(google.protobuf.message.Message):
    """The synchronized command message for commanding the arm to move.
    A synchronized commands is one of the possible robot command messages for controlling the robot.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        """The arm request must be one of the basic command primitives."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        ARM_CARTESIAN_COMMAND_FIELD_NUMBER: builtins.int
        ARM_JOINT_MOVE_COMMAND_FIELD_NUMBER: builtins.int
        NAMED_ARM_POSITION_COMMAND_FIELD_NUMBER: builtins.int
        ARM_VELOCITY_COMMAND_FIELD_NUMBER: builtins.int
        ARM_GAZE_COMMAND_FIELD_NUMBER: builtins.int
        ARM_STOP_COMMAND_FIELD_NUMBER: builtins.int
        ARM_DRAG_COMMAND_FIELD_NUMBER: builtins.int
        PARAMS_FIELD_NUMBER: builtins.int
        @property
        def arm_cartesian_command(self) -> global___ArmCartesianCommand.Request:
            """Control the end-effector in Cartesian space."""
            pass
        @property
        def arm_joint_move_command(self) -> global___ArmJointMoveCommand.Request:
            """Control joint angles of the arm."""
            pass
        @property
        def named_arm_position_command(self) -> global___NamedArmPositionsCommand.Request:
            """Move the arm to some predefined configurations."""
            pass
        @property
        def arm_velocity_command(self) -> global___ArmVelocityCommand.Request:
            """Velocity control of the end-effector."""
            pass
        @property
        def arm_gaze_command(self) -> global___GazeCommand.Request:
            """Point the gripper at a point in the world."""
            pass
        @property
        def arm_stop_command(self) -> global___ArmStopCommand.Request:
            """Stop the arm in place with minimal motion."""
            pass
        @property
        def arm_drag_command(self) -> bosdyn.api.basic_command_pb2.ArmDragCommand.Request:
            """Use the arm to drag something held in the gripper."""
            pass
        @property
        def params(self) -> global___ArmParams:
            """Any arm parameters to send, common across all arm commands"""
            pass
        def __init__(self,
            *,
            arm_cartesian_command: typing.Optional[global___ArmCartesianCommand.Request] = ...,
            arm_joint_move_command: typing.Optional[global___ArmJointMoveCommand.Request] = ...,
            named_arm_position_command: typing.Optional[global___NamedArmPositionsCommand.Request] = ...,
            arm_velocity_command: typing.Optional[global___ArmVelocityCommand.Request] = ...,
            arm_gaze_command: typing.Optional[global___GazeCommand.Request] = ...,
            arm_stop_command: typing.Optional[global___ArmStopCommand.Request] = ...,
            arm_drag_command: typing.Optional[bosdyn.api.basic_command_pb2.ArmDragCommand.Request] = ...,
            params: typing.Optional[global___ArmParams] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["arm_cartesian_command",b"arm_cartesian_command","arm_drag_command",b"arm_drag_command","arm_gaze_command",b"arm_gaze_command","arm_joint_move_command",b"arm_joint_move_command","arm_stop_command",b"arm_stop_command","arm_velocity_command",b"arm_velocity_command","command",b"command","named_arm_position_command",b"named_arm_position_command","params",b"params"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["arm_cartesian_command",b"arm_cartesian_command","arm_drag_command",b"arm_drag_command","arm_gaze_command",b"arm_gaze_command","arm_joint_move_command",b"arm_joint_move_command","arm_stop_command",b"arm_stop_command","arm_velocity_command",b"arm_velocity_command","command",b"command","named_arm_position_command",b"named_arm_position_command","params",b"params"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["command",b"command"]) -> typing.Optional[typing_extensions.Literal["arm_cartesian_command","arm_joint_move_command","named_arm_position_command","arm_velocity_command","arm_gaze_command","arm_stop_command","arm_drag_command"]]: ...

    class Feedback(google.protobuf.message.Message):
        """The feedback for the arm command that will provide information on the progress
        of the command.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        ARM_CARTESIAN_FEEDBACK_FIELD_NUMBER: builtins.int
        ARM_JOINT_MOVE_FEEDBACK_FIELD_NUMBER: builtins.int
        NAMED_ARM_POSITION_FEEDBACK_FIELD_NUMBER: builtins.int
        ARM_VELOCITY_FEEDBACK_FIELD_NUMBER: builtins.int
        ARM_GAZE_FEEDBACK_FIELD_NUMBER: builtins.int
        ARM_STOP_FEEDBACK_FIELD_NUMBER: builtins.int
        ARM_DRAG_FEEDBACK_FIELD_NUMBER: builtins.int
        STATUS_FIELD_NUMBER: builtins.int
        @property
        def arm_cartesian_feedback(self) -> global___ArmCartesianCommand.Feedback:
            """Feedback for the end-effector Cartesian command."""
            pass
        @property
        def arm_joint_move_feedback(self) -> global___ArmJointMoveCommand.Feedback:
            """Feedback for the joint move command."""
            pass
        @property
        def named_arm_position_feedback(self) -> global___NamedArmPositionsCommand.Feedback:
            """Feedback for the named position move command."""
            pass
        @property
        def arm_velocity_feedback(self) -> global___ArmVelocityCommand.Feedback: ...
        @property
        def arm_gaze_feedback(self) -> global___GazeCommand.Feedback:
            """Feedback for the gaze command."""
            pass
        @property
        def arm_stop_feedback(self) -> global___ArmStopCommand.Feedback: ...
        @property
        def arm_drag_feedback(self) -> bosdyn.api.basic_command_pb2.ArmDragCommand.Feedback:
            """Feedback for the drag command."""
            pass
        status: bosdyn.api.basic_command_pb2.RobotCommandFeedbackStatus.Status.ValueType
        def __init__(self,
            *,
            arm_cartesian_feedback: typing.Optional[global___ArmCartesianCommand.Feedback] = ...,
            arm_joint_move_feedback: typing.Optional[global___ArmJointMoveCommand.Feedback] = ...,
            named_arm_position_feedback: typing.Optional[global___NamedArmPositionsCommand.Feedback] = ...,
            arm_velocity_feedback: typing.Optional[global___ArmVelocityCommand.Feedback] = ...,
            arm_gaze_feedback: typing.Optional[global___GazeCommand.Feedback] = ...,
            arm_stop_feedback: typing.Optional[global___ArmStopCommand.Feedback] = ...,
            arm_drag_feedback: typing.Optional[bosdyn.api.basic_command_pb2.ArmDragCommand.Feedback] = ...,
            status: bosdyn.api.basic_command_pb2.RobotCommandFeedbackStatus.Status.ValueType = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["arm_cartesian_feedback",b"arm_cartesian_feedback","arm_drag_feedback",b"arm_drag_feedback","arm_gaze_feedback",b"arm_gaze_feedback","arm_joint_move_feedback",b"arm_joint_move_feedback","arm_stop_feedback",b"arm_stop_feedback","arm_velocity_feedback",b"arm_velocity_feedback","feedback",b"feedback","named_arm_position_feedback",b"named_arm_position_feedback"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["arm_cartesian_feedback",b"arm_cartesian_feedback","arm_drag_feedback",b"arm_drag_feedback","arm_gaze_feedback",b"arm_gaze_feedback","arm_joint_move_feedback",b"arm_joint_move_feedback","arm_stop_feedback",b"arm_stop_feedback","arm_velocity_feedback",b"arm_velocity_feedback","feedback",b"feedback","named_arm_position_feedback",b"named_arm_position_feedback","status",b"status"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["feedback",b"feedback"]) -> typing.Optional[typing_extensions.Literal["arm_cartesian_feedback","arm_joint_move_feedback","named_arm_position_feedback","arm_velocity_feedback","arm_gaze_feedback","arm_stop_feedback","arm_drag_feedback"]]: ...

    def __init__(self,
        ) -> None: ...
global___ArmCommand = ArmCommand

class ArmParams(google.protobuf.message.Message):
    """Parameters common across arm commands."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DISABLE_BODY_FORCE_LIMITER_FIELD_NUMBER: builtins.int
    @property
    def disable_body_force_limiter(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """/ Whether or not to disable the body force limiter running on the robot. By default, this is
        / on, and the chance that the body falls over because the arm makes contact in the world is
        / low. If this is purposely disabled (by setting disable_body_force_limiter to True), the arm
        / may be able to accelerate faster, and apply more force to the world and to objects than usual,
        / but there is also added risk of the robot falling over.
        """
        pass
    def __init__(self,
        *,
        disable_body_force_limiter: typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["disable_body_force_limiter",b"disable_body_force_limiter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["disable_body_force_limiter",b"disable_body_force_limiter"]) -> None: ...
global___ArmParams = ArmParams

class ArmVelocityCommand(google.protobuf.message.Message):
    """When controlling the arm with a joystick, because of latency it can often be better to send
    velocity commands rather than position commands.  Both linear and angular velocity can be
    specified.  The linear velocity can be specified in a cylindrical frame around the shoulder or
    with a specified frame.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class CylindricalVelocity(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        LINEAR_VELOCITY_FIELD_NUMBER: builtins.int
        MAX_LINEAR_VELOCITY_FIELD_NUMBER: builtins.int
        @property
        def linear_velocity(self) -> bosdyn.api.geometry_pb2.CylindricalCoordinate:
            """/ The linear velocities for the end-effector are specified in unitless cylindrical
            / coordinates. The origin of the cylindrical coordinate system is the base of the arm
            / (shoulder).  The Z-axis is aligned with gravity, and the X-axis is the unit vector from
            / the shoulder to the hand-point. This construction allows for 'Z'-axis velocities to
            / raise/lower the hand, 'R'-axis velocities will cause the hand to move towards/away from
            / the shoulder, and 'theta'-axis velocities will cause the hand to travel
            / clockwise/counter-clockwise around the shoulder. Lastly, the command is unitless, with
            / values for each axis specified in the range [-1, 1].  A value of 0 denotes no velocity
            / and values of +/- 1 denote maximum velocity (see max_linear_velocity).
            """
            pass
        @property
        def max_linear_velocity(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """/ The maximum velocity in meters / second for the hand.
            / If unset and default value of 0 received, will set max_linear_velocity to 0.5 m/s.
            """
            pass
        def __init__(self,
            *,
            linear_velocity: typing.Optional[bosdyn.api.geometry_pb2.CylindricalCoordinate] = ...,
            max_linear_velocity: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["linear_velocity",b"linear_velocity","max_linear_velocity",b"max_linear_velocity"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["linear_velocity",b"linear_velocity","max_linear_velocity",b"max_linear_velocity"]) -> None: ...

    class CartesianVelocity(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        FRAME_NAME_FIELD_NUMBER: builtins.int
        VELOCITY_IN_FRAME_NAME_FIELD_NUMBER: builtins.int
        frame_name: typing.Text
        """The frame to express our velocities in"""

        @property
        def velocity_in_frame_name(self) -> bosdyn.api.geometry_pb2.Vec3:
            """The x-y-z velocity of the hand (m/s) with respect to the frame"""
            pass
        def __init__(self,
            *,
            frame_name: typing.Text = ...,
            velocity_in_frame_name: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["velocity_in_frame_name",b"velocity_in_frame_name"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["frame_name",b"frame_name","velocity_in_frame_name",b"velocity_in_frame_name"]) -> None: ...

    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        CYLINDRICAL_VELOCITY_FIELD_NUMBER: builtins.int
        CARTESIAN_VELOCITY_FIELD_NUMBER: builtins.int
        ANGULAR_VELOCITY_OF_HAND_RT_ODOM_IN_HAND_FIELD_NUMBER: builtins.int
        MAXIMUM_ACCELERATION_FIELD_NUMBER: builtins.int
        END_TIME_FIELD_NUMBER: builtins.int
        @property
        def cylindrical_velocity(self) -> global___ArmVelocityCommand.CylindricalVelocity: ...
        @property
        def cartesian_velocity(self) -> global___ArmVelocityCommand.CartesianVelocity: ...
        @property
        def angular_velocity_of_hand_rt_odom_in_hand(self) -> bosdyn.api.geometry_pb2.Vec3:
            """The angular velocity of the hand frame measured with respect to the odom frame, expressed
            in the hand frame. A 'X' rate will cause the hand to rotate about its x-axis, e.g. the
            final wrist twist joint will rotate. And similarly, 'Y' and 'Z' rates will cause the hand
            to rotate about its y and z axis respectively. \\
            The units should be rad/sec.
            """
            pass
        @property
        def maximum_acceleration(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional maximum acceleration magnitude of the end-effector. (m/s^2)"""
            pass
        @property
        def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The timestamp (in robot time) by which a command must finish executing.
            This is a required field and used to prevent runaway commands.
            """
            pass
        def __init__(self,
            *,
            cylindrical_velocity: typing.Optional[global___ArmVelocityCommand.CylindricalVelocity] = ...,
            cartesian_velocity: typing.Optional[global___ArmVelocityCommand.CartesianVelocity] = ...,
            angular_velocity_of_hand_rt_odom_in_hand: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
            maximum_acceleration: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            end_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["angular_velocity_of_hand_rt_odom_in_hand",b"angular_velocity_of_hand_rt_odom_in_hand","cartesian_velocity",b"cartesian_velocity","command",b"command","cylindrical_velocity",b"cylindrical_velocity","end_time",b"end_time","maximum_acceleration",b"maximum_acceleration"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["angular_velocity_of_hand_rt_odom_in_hand",b"angular_velocity_of_hand_rt_odom_in_hand","cartesian_velocity",b"cartesian_velocity","command",b"command","cylindrical_velocity",b"cylindrical_velocity","end_time",b"end_time","maximum_acceleration",b"maximum_acceleration"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["command",b"command"]) -> typing.Optional[typing_extensions.Literal["cylindrical_velocity","cartesian_velocity"]]: ...

    class Feedback(google.protobuf.message.Message):
        """ArmVelocityCommand provides no feedback"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    def __init__(self,
        ) -> None: ...
global___ArmVelocityCommand = ArmVelocityCommand

class NamedArmPositionsCommand(google.protobuf.message.Message):
    """Command the arm move to a predefined configuration."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Positions:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _PositionsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NamedArmPositionsCommand._Positions.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        POSITIONS_UNKNOWN: NamedArmPositionsCommand._Positions.ValueType  # 0
        """Invalid request; do not use."""

        POSITIONS_CARRY: NamedArmPositionsCommand._Positions.ValueType  # 1
        """The carry position is a damped, force limited position close to stow, with the hand
        slightly in front of the robot.
        """

        POSITIONS_READY: NamedArmPositionsCommand._Positions.ValueType  # 2
        """Move arm to ready position. The ready position is defined with the hand directly in
        front of and slightly above the body, with the hand facing forward in the robot body +X
        direction.
        """

        POSITIONS_STOW: NamedArmPositionsCommand._Positions.ValueType  # 3
        """Stow the arm, safely. If the robot is holding something, it will freeze the arm instead
        of stowing.  Overriding the carry_state to CARRY_STATE_CARRIABLE_AND_STOWABLE, will allow
        the robot to stow the arm while grasping an item.
        """

    class Positions(_Positions, metaclass=_PositionsEnumTypeWrapper):
        pass

    POSITIONS_UNKNOWN: NamedArmPositionsCommand.Positions.ValueType  # 0
    """Invalid request; do not use."""

    POSITIONS_CARRY: NamedArmPositionsCommand.Positions.ValueType  # 1
    """The carry position is a damped, force limited position close to stow, with the hand
    slightly in front of the robot.
    """

    POSITIONS_READY: NamedArmPositionsCommand.Positions.ValueType  # 2
    """Move arm to ready position. The ready position is defined with the hand directly in
    front of and slightly above the body, with the hand facing forward in the robot body +X
    direction.
    """

    POSITIONS_STOW: NamedArmPositionsCommand.Positions.ValueType  # 3
    """Stow the arm, safely. If the robot is holding something, it will freeze the arm instead
    of stowing.  Overriding the carry_state to CARRY_STATE_CARRIABLE_AND_STOWABLE, will allow
    the robot to stow the arm while grasping an item.
    """


    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        POSITION_FIELD_NUMBER: builtins.int
        position: global___NamedArmPositionsCommand.Positions.ValueType
        def __init__(self,
            *,
            position: global___NamedArmPositionsCommand.Positions.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["position",b"position"]) -> None: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NamedArmPositionsCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: NamedArmPositionsCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            STATUS_COMPLETE: NamedArmPositionsCommand.Feedback._Status.ValueType  # 1
            """The arm is at the desired configuration."""

            STATUS_IN_PROGRESS: NamedArmPositionsCommand.Feedback._Status.ValueType  # 2
            """Robot is re-configuring arm to get to desired configuration."""

            STATUS_STALLED_HOLDING_ITEM: NamedArmPositionsCommand.Feedback._Status.ValueType  # 3
            """Some positions may refuse to execute if the gripper is holding an item, for example
            stow.
            """

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: NamedArmPositionsCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        STATUS_COMPLETE: NamedArmPositionsCommand.Feedback.Status.ValueType  # 1
        """The arm is at the desired configuration."""

        STATUS_IN_PROGRESS: NamedArmPositionsCommand.Feedback.Status.ValueType  # 2
        """Robot is re-configuring arm to get to desired configuration."""

        STATUS_STALLED_HOLDING_ITEM: NamedArmPositionsCommand.Feedback.Status.ValueType  # 3
        """Some positions may refuse to execute if the gripper is holding an item, for example
        stow.
        """


        STATUS_FIELD_NUMBER: builtins.int
        status: global___NamedArmPositionsCommand.Feedback.Status.ValueType
        """Current status of the request."""

        def __init__(self,
            *,
            status: global___NamedArmPositionsCommand.Feedback.Status.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___NamedArmPositionsCommand = NamedArmPositionsCommand

class ArmCartesianCommand(google.protobuf.message.Message):
    """Command the end effector of the arm.  Each axis in the task frame is allowed to be set to
    position mode (default) or Force mode.  If the axis is set to position, the desired value is read
    from the pose_trajectory_in_task. If the axis is set to force, the desired value is read from
    the rench_trajectory. This supports hybrid control of the arm where users can specify, for
    example, Z to be in force control with X and Y in position control.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _AxisMode:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _AxisModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ArmCartesianCommand.Request._AxisMode.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            AXIS_MODE_POSITION: ArmCartesianCommand.Request._AxisMode.ValueType  # 0
            AXIS_MODE_FORCE: ArmCartesianCommand.Request._AxisMode.ValueType  # 1
        class AxisMode(_AxisMode, metaclass=_AxisModeEnumTypeWrapper):
            """If an axis is set to position mode (default), read desired from SE3Trajectory trajectory
            command.  If mode is set to Force, read desired from WrenchTrajectory wrench_trajectory
            command.  This supports hybrid control of the arm where users can specify, for example, Z
            to be in force control with X and Y in position control.  The elements are expressed in
            the same task_frame as the trajectories.
            """
            pass

        AXIS_MODE_POSITION: ArmCartesianCommand.Request.AxisMode.ValueType  # 0
        AXIS_MODE_FORCE: ArmCartesianCommand.Request.AxisMode.ValueType  # 1

        ROOT_FRAME_NAME_FIELD_NUMBER: builtins.int
        WRIST_TFORM_TOOL_FIELD_NUMBER: builtins.int
        ROOT_TFORM_TASK_FIELD_NUMBER: builtins.int
        POSE_TRAJECTORY_IN_TASK_FIELD_NUMBER: builtins.int
        MAXIMUM_ACCELERATION_FIELD_NUMBER: builtins.int
        MAX_LINEAR_VELOCITY_FIELD_NUMBER: builtins.int
        MAX_ANGULAR_VELOCITY_FIELD_NUMBER: builtins.int
        MAX_POS_TRACKING_ERROR_FIELD_NUMBER: builtins.int
        MAX_ROT_TRACKING_ERROR_FIELD_NUMBER: builtins.int
        FORCE_REMAIN_NEAR_CURRENT_JOINT_CONFIGURATION_FIELD_NUMBER: builtins.int
        PREFERRED_JOINT_CONFIGURATION_FIELD_NUMBER: builtins.int
        X_AXIS_FIELD_NUMBER: builtins.int
        Y_AXIS_FIELD_NUMBER: builtins.int
        Z_AXIS_FIELD_NUMBER: builtins.int
        RX_AXIS_FIELD_NUMBER: builtins.int
        RY_AXIS_FIELD_NUMBER: builtins.int
        RZ_AXIS_FIELD_NUMBER: builtins.int
        WRENCH_TRAJECTORY_IN_TASK_FIELD_NUMBER: builtins.int
        root_frame_name: typing.Text
        """The root frame is used to set the optional task frame that all trajectories are
        specified with respect to.  If the optional task frame is left un-specified it defaults
        to the identity transform and the root frame becomes the task frame.
        """

        @property
        def wrist_tform_tool(self) -> bosdyn.api.geometry_pb2.SE3Pose:
            """The tool pose relative to the parent link (wrist).
            Defaults to
               [0.19557 0 0]
               [1 0 0 0]
            a frame with it's origin slightly in front of the gripper's palm plate aligned with
            wrist's orientation.
            """
            pass
        @property
        def root_tform_task(self) -> bosdyn.api.geometry_pb2.SE3Pose:
            """The fields below are specified in this optional task frame.  If unset it defaults
            to the identity transform and all quantities are therefore expressed in the
            root_frame_name.
            """
            pass
        @property
        def pose_trajectory_in_task(self) -> bosdyn.api.trajectory_pb2.SE3Trajectory:
            """A 3D pose trajectory for the tool expressed in the task frame, e.g. task_T_tool.
            This pose trajectory is optional if requesting a pure wrench at the end-effector,
            otherwise required for position or mixed force/position end-effector requests.
            """
            pass
        @property
        def maximum_acceleration(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional Maximum acceleration magnitude of the end-effector.
            Valid ranges (0, 20]
            """
            pass
        @property
        def max_linear_velocity(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional Maximum linear velocity magnitude of the end-effector. (m/s)"""
            pass
        @property
        def max_angular_velocity(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional Maximum angular velocity magnitude of the end-effector. (rad/s)"""
            pass
        @property
        def max_pos_tracking_error(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Maximum allowable tracking error of the tool frame from the desired trajectory
            before the arm will stop moving and cancel the rest of the trajectory. When this limit is
            exceeded, the hand will stay at the pose it was at when it exceeded the tracking error,
            and any other part of the trajectory specified in the rest of this message will be
            ignored. max position tracking error in meters
            """
            pass
        @property
        def max_rot_tracking_error(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """max orientation tracking error in radians"""
            pass
        force_remain_near_current_joint_configuration: builtins.bool
        @property
        def preferred_joint_configuration(self) -> global___ArmJointPosition: ...
        x_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType
        y_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType
        z_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType
        rx_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType
        ry_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType
        rz_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType
        @property
        def wrench_trajectory_in_task(self) -> bosdyn.api.trajectory_pb2.WrenchTrajectory:
            """A force/torque trajectory for the tool expressed in the task frame.
            This trajectory is optional if requesting a pure pose at the end-effector,
            otherwise required for force or mixed force/position end-effector requests.
            """
            pass
        def __init__(self,
            *,
            root_frame_name: typing.Text = ...,
            wrist_tform_tool: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
            root_tform_task: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
            pose_trajectory_in_task: typing.Optional[bosdyn.api.trajectory_pb2.SE3Trajectory] = ...,
            maximum_acceleration: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_linear_velocity: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_angular_velocity: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_pos_tracking_error: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_rot_tracking_error: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            force_remain_near_current_joint_configuration: builtins.bool = ...,
            preferred_joint_configuration: typing.Optional[global___ArmJointPosition] = ...,
            x_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType = ...,
            y_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType = ...,
            z_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType = ...,
            rx_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType = ...,
            ry_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType = ...,
            rz_axis: global___ArmCartesianCommand.Request.AxisMode.ValueType = ...,
            wrench_trajectory_in_task: typing.Optional[bosdyn.api.trajectory_pb2.WrenchTrajectory] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["force_remain_near_current_joint_configuration",b"force_remain_near_current_joint_configuration","joint_configuration",b"joint_configuration","max_angular_velocity",b"max_angular_velocity","max_linear_velocity",b"max_linear_velocity","max_pos_tracking_error",b"max_pos_tracking_error","max_rot_tracking_error",b"max_rot_tracking_error","maximum_acceleration",b"maximum_acceleration","pose_trajectory_in_task",b"pose_trajectory_in_task","preferred_joint_configuration",b"preferred_joint_configuration","root_tform_task",b"root_tform_task","wrench_trajectory_in_task",b"wrench_trajectory_in_task","wrist_tform_tool",b"wrist_tform_tool"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["force_remain_near_current_joint_configuration",b"force_remain_near_current_joint_configuration","joint_configuration",b"joint_configuration","max_angular_velocity",b"max_angular_velocity","max_linear_velocity",b"max_linear_velocity","max_pos_tracking_error",b"max_pos_tracking_error","max_rot_tracking_error",b"max_rot_tracking_error","maximum_acceleration",b"maximum_acceleration","pose_trajectory_in_task",b"pose_trajectory_in_task","preferred_joint_configuration",b"preferred_joint_configuration","root_frame_name",b"root_frame_name","root_tform_task",b"root_tform_task","rx_axis",b"rx_axis","ry_axis",b"ry_axis","rz_axis",b"rz_axis","wrench_trajectory_in_task",b"wrench_trajectory_in_task","wrist_tform_tool",b"wrist_tform_tool","x_axis",b"x_axis","y_axis",b"y_axis","z_axis",b"z_axis"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["joint_configuration",b"joint_configuration"]) -> typing.Optional[typing_extensions.Literal["force_remain_near_current_joint_configuration","preferred_joint_configuration"]]: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ArmCartesianCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: ArmCartesianCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            STATUS_TRAJECTORY_COMPLETE: ArmCartesianCommand.Feedback._Status.ValueType  # 1
            """Tool frame has reached the end of the trajectory within tracking error bounds."""

            STATUS_IN_PROGRESS: ArmCartesianCommand.Feedback._Status.ValueType  # 2
            """Robot is attempting to reach the target."""

            STATUS_TRAJECTORY_CANCELLED: ArmCartesianCommand.Feedback._Status.ValueType  # 3
            """Tool frame exceeded maximum allowable tracking error from the desired trajectory."""

            STATUS_TRAJECTORY_STALLED: ArmCartesianCommand.Feedback._Status.ValueType  # 4
            """The arm has stopped making progress to the goal.  Note, this does not cancel the
            trajectory. For example, if the requested goal is too far away, walking the base
            robot closer to the goal will cause the arm to continue along the trajectory once the
            goal point is inside the workspace.
            """

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: ArmCartesianCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        STATUS_TRAJECTORY_COMPLETE: ArmCartesianCommand.Feedback.Status.ValueType  # 1
        """Tool frame has reached the end of the trajectory within tracking error bounds."""

        STATUS_IN_PROGRESS: ArmCartesianCommand.Feedback.Status.ValueType  # 2
        """Robot is attempting to reach the target."""

        STATUS_TRAJECTORY_CANCELLED: ArmCartesianCommand.Feedback.Status.ValueType  # 3
        """Tool frame exceeded maximum allowable tracking error from the desired trajectory."""

        STATUS_TRAJECTORY_STALLED: ArmCartesianCommand.Feedback.Status.ValueType  # 4
        """The arm has stopped making progress to the goal.  Note, this does not cancel the
        trajectory. For example, if the requested goal is too far away, walking the base
        robot closer to the goal will cause the arm to continue along the trajectory once the
        goal point is inside the workspace.
        """


        STATUS_FIELD_NUMBER: builtins.int
        MEASURED_POS_TRACKING_ERROR_FIELD_NUMBER: builtins.int
        MEASURED_ROT_TRACKING_ERROR_FIELD_NUMBER: builtins.int
        MEASURED_POS_DISTANCE_TO_GOAL_FIELD_NUMBER: builtins.int
        MEASURED_ROT_DISTANCE_TO_GOAL_FIELD_NUMBER: builtins.int
        status: global___ArmCartesianCommand.Feedback.Status.ValueType
        """Current status of the pose trajectory."""

        measured_pos_tracking_error: builtins.float
        """Current linear tracking error of the tool frame [meters]."""

        measured_rot_tracking_error: builtins.float
        """Current rotational tracking error of the tool frame [radians]."""

        measured_pos_distance_to_goal: builtins.float
        """Linear distance from the tool to the tool trajectory's end point [meters]."""

        measured_rot_distance_to_goal: builtins.float
        """Rotational distance from the tool to the trajectory's end point [radians]."""

        def __init__(self,
            *,
            status: global___ArmCartesianCommand.Feedback.Status.ValueType = ...,
            measured_pos_tracking_error: builtins.float = ...,
            measured_rot_tracking_error: builtins.float = ...,
            measured_pos_distance_to_goal: builtins.float = ...,
            measured_rot_distance_to_goal: builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["measured_pos_distance_to_goal",b"measured_pos_distance_to_goal","measured_pos_tracking_error",b"measured_pos_tracking_error","measured_rot_distance_to_goal",b"measured_rot_distance_to_goal","measured_rot_tracking_error",b"measured_rot_tracking_error","status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___ArmCartesianCommand = ArmCartesianCommand

class ArmJointMoveCommand(google.protobuf.message.Message):
    """Specify a set of joint angles to move the arm."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TRAJECTORY_FIELD_NUMBER: builtins.int
        @property
        def trajectory(self) -> global___ArmJointTrajectory:
            """Note: Sending a single point empty trajectory will cause the arm to freeze in place. This
            is an easy way to lock the arm in its current configuration.
            """
            pass
        def __init__(self,
            *,
            trajectory: typing.Optional[global___ArmJointTrajectory] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["trajectory",b"trajectory"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["trajectory",b"trajectory"]) -> None: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ArmJointMoveCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: ArmJointMoveCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened"""

            STATUS_COMPLETE: ArmJointMoveCommand.Feedback._Status.ValueType  # 1
            """The arm is at the desired configuration."""

            STATUS_IN_PROGRESS: ArmJointMoveCommand.Feedback._Status.ValueType  # 2
            """Robot is re-configuring arm to get to desired configuration."""

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: ArmJointMoveCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened"""

        STATUS_COMPLETE: ArmJointMoveCommand.Feedback.Status.ValueType  # 1
        """The arm is at the desired configuration."""

        STATUS_IN_PROGRESS: ArmJointMoveCommand.Feedback.Status.ValueType  # 2
        """Robot is re-configuring arm to get to desired configuration."""


        class _PlannerStatus:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _PlannerStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ArmJointMoveCommand.Feedback._PlannerStatus.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            PLANNER_STATUS_UNKNOWN: ArmJointMoveCommand.Feedback._PlannerStatus.ValueType  # 0
            """PLANNER_STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            PLANNER_STATUS_SUCCESS: ArmJointMoveCommand.Feedback._PlannerStatus.ValueType  # 1
            """A solution passing through the desired points and obeying the constraints was found."""

            PLANNER_STATUS_MODIFIED: ArmJointMoveCommand.Feedback._PlannerStatus.ValueType  # 2
            """The planner had to modify the desired points in order to obey the constraints.  For
            example, if you specify a 1 point trajectory, and tell it to get there in a really short
            amount of time, but haven't set a high allowable max velocity / acceleration, the planner
            will do its best to get as close as possible to the final point, but won't reach it. In
            situations where we've modified you last point, we append a minimum time trajectory (that
            obeys the velocity and acceleration limits) from the planner's final point to the requested
            final point.
            """

            PLANNER_STATUS_FAILED: ArmJointMoveCommand.Feedback._PlannerStatus.ValueType  # 3
            """Failed to compute a valid trajectory, will go to first point instead. It is possible
            that our optimizer till fail to solve the problem instead of returning a sub-optimal
            solution.  This is un-likely to occur.
            """

        class PlannerStatus(_PlannerStatus, metaclass=_PlannerStatusEnumTypeWrapper):
            pass

        PLANNER_STATUS_UNKNOWN: ArmJointMoveCommand.Feedback.PlannerStatus.ValueType  # 0
        """PLANNER_STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        PLANNER_STATUS_SUCCESS: ArmJointMoveCommand.Feedback.PlannerStatus.ValueType  # 1
        """A solution passing through the desired points and obeying the constraints was found."""

        PLANNER_STATUS_MODIFIED: ArmJointMoveCommand.Feedback.PlannerStatus.ValueType  # 2
        """The planner had to modify the desired points in order to obey the constraints.  For
        example, if you specify a 1 point trajectory, and tell it to get there in a really short
        amount of time, but haven't set a high allowable max velocity / acceleration, the planner
        will do its best to get as close as possible to the final point, but won't reach it. In
        situations where we've modified you last point, we append a minimum time trajectory (that
        obeys the velocity and acceleration limits) from the planner's final point to the requested
        final point.
        """

        PLANNER_STATUS_FAILED: ArmJointMoveCommand.Feedback.PlannerStatus.ValueType  # 3
        """Failed to compute a valid trajectory, will go to first point instead. It is possible
        that our optimizer till fail to solve the problem instead of returning a sub-optimal
        solution.  This is un-likely to occur.
        """


        STATUS_FIELD_NUMBER: builtins.int
        PLANNER_STATUS_FIELD_NUMBER: builtins.int
        PLANNED_POINTS_FIELD_NUMBER: builtins.int
        TIME_TO_GOAL_FIELD_NUMBER: builtins.int
        status: global___ArmJointMoveCommand.Feedback.Status.ValueType
        """Current status of the request."""

        planner_status: global___ArmJointMoveCommand.Feedback.PlannerStatus.ValueType
        """Current status of the trajectory planner."""

        @property
        def planned_points(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ArmJointTrajectoryPoint]:
            """Based on the user trajectory, the planned knot points that obey acceleration and 
            velocity constraints. If these knot points don't match the requested knot points, 
            consider increasing velocity/acceleration limits, and/or staying further away from 
            joint position limits. In situations where we've modified you last point, we append
            a minimum time trajectory (that obeys the velocity and acceleration limits) from the
            planner's final point to the requested final point. This means that the length of
            planned_points may be one point larger than the requested.
            """
            pass
        @property
        def time_to_goal(self) -> google.protobuf.duration_pb2.Duration:
            """Returns amount of time remaining until the joints are at the goal position.  For
            multiple point trajectories, this is the time remaining to the final point.
            """
            pass
        def __init__(self,
            *,
            status: global___ArmJointMoveCommand.Feedback.Status.ValueType = ...,
            planner_status: global___ArmJointMoveCommand.Feedback.PlannerStatus.ValueType = ...,
            planned_points: typing.Optional[typing.Iterable[global___ArmJointTrajectoryPoint]] = ...,
            time_to_goal: typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["time_to_goal",b"time_to_goal"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["planned_points",b"planned_points","planner_status",b"planner_status","status",b"status","time_to_goal",b"time_to_goal"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___ArmJointMoveCommand = ArmJointMoveCommand

class ArmJointPosition(google.protobuf.message.Message):
    """Position of our 6 arm joints in radians. If a joint angle is not specified,
    we will use the joint position at time the message is received on robot.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SH0_FIELD_NUMBER: builtins.int
    SH1_FIELD_NUMBER: builtins.int
    EL0_FIELD_NUMBER: builtins.int
    EL1_FIELD_NUMBER: builtins.int
    WR0_FIELD_NUMBER: builtins.int
    WR1_FIELD_NUMBER: builtins.int
    @property
    def sh0(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def sh1(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def el0(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def el1(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def wr0(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def wr1(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    def __init__(self,
        *,
        sh0: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        sh1: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        el0: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        el1: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        wr0: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        wr1: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["el0",b"el0","el1",b"el1","sh0",b"sh0","sh1",b"sh1","wr0",b"wr0","wr1",b"wr1"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["el0",b"el0","el1",b"el1","sh0",b"sh0","sh1",b"sh1","wr0",b"wr0","wr1",b"wr1"]) -> None: ...
global___ArmJointPosition = ArmJointPosition

class ArmJointVelocity(google.protobuf.message.Message):
    """Velocity of our 6 arm joints in radians / second. If a velocity
    for a joint is specified, velocities for all joints we are
    trying to move must be specified.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SH0_FIELD_NUMBER: builtins.int
    SH1_FIELD_NUMBER: builtins.int
    EL0_FIELD_NUMBER: builtins.int
    EL1_FIELD_NUMBER: builtins.int
    WR0_FIELD_NUMBER: builtins.int
    WR1_FIELD_NUMBER: builtins.int
    @property
    def sh0(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def sh1(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def el0(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def el1(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def wr0(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    @property
    def wr1(self) -> google.protobuf.wrappers_pb2.DoubleValue: ...
    def __init__(self,
        *,
        sh0: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        sh1: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        el0: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        el1: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        wr0: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        wr1: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["el0",b"el0","el1",b"el1","sh0",b"sh0","sh1",b"sh1","wr0",b"wr0","wr1",b"wr1"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["el0",b"el0","el1",b"el1","sh0",b"sh0","sh1",b"sh1","wr0",b"wr0","wr1",b"wr1"]) -> None: ...
global___ArmJointVelocity = ArmJointVelocity

class ArmJointTrajectoryPoint(google.protobuf.message.Message):
    """A set of joint angles and velocities that can be used as a point within a joint trajectory."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    POSITION_FIELD_NUMBER: builtins.int
    VELOCITY_FIELD_NUMBER: builtins.int
    TIME_SINCE_REFERENCE_FIELD_NUMBER: builtins.int
    @property
    def position(self) -> global___ArmJointPosition:
        """Desired joint angles in radians"""
        pass
    @property
    def velocity(self) -> global___ArmJointVelocity:
        """Optional desired joint velocities in radians / sec"""
        pass
    @property
    def time_since_reference(self) -> google.protobuf.duration_pb2.Duration:
        """The time since reference at which we wish to achieve this position / velocity"""
        pass
    def __init__(self,
        *,
        position: typing.Optional[global___ArmJointPosition] = ...,
        velocity: typing.Optional[global___ArmJointVelocity] = ...,
        time_since_reference: typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["position",b"position","time_since_reference",b"time_since_reference","velocity",b"velocity"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["position",b"position","time_since_reference",b"time_since_reference","velocity",b"velocity"]) -> None: ...
global___ArmJointTrajectoryPoint = ArmJointTrajectoryPoint

class ArmJointTrajectory(google.protobuf.message.Message):
    """This allows a user to move the arm's joints directly. Each of the arm's joints will never move
    faster than maximum_velocity and never accelerate faster than maximum_acceleration. The user can
    specify a trajectory of joint positions and optional velocities for the arm to follow. The
    trajectory will be acted upon as follows. If a single trajectory point with no time is provided,
    the arm will take the joint currently furthest away from the goal pose and plan a minimum time
    trajectory such that the joint accelerates at maximum_acceleration, coasts at maximum_velocity,
    and decelerates at maximum_acceleration. The other joints will accelerate at
    maximum_acceleration, but then coast at a slower speed such that all joints arrive at the goal
    pose simultaneously with zero velocity. If the user provides trajectory times, the robot will fit
    a piece-wise cubic trajectory (continuous position and velocity) to the user's requested
    positions and (optional) velocities. If the requested trajectory is not achievable because it
    will violate position limits or the maximum_velocity or maximum_acceleration, the robot will pick
    a trajectory that is as close as possible to the user requested without violating velocity or
    acceleration limits.

    If the robot is not hitting the desired trajectory, try increasing the time between knot points,
    increasing the max velocity and acceleration, or only specifying joint position goals without a
    velocity
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    POINTS_FIELD_NUMBER: builtins.int
    REFERENCE_TIME_FIELD_NUMBER: builtins.int
    MAXIMUM_VELOCITY_FIELD_NUMBER: builtins.int
    MAXIMUM_ACCELERATION_FIELD_NUMBER: builtins.int
    @property
    def points(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ArmJointTrajectoryPoint]:
        """The points in our trajectory. (positions, (optional) velocity, (optional) time)"""
        pass
    @property
    def reference_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """All trajectory points specify times relative to this reference time. The reference
        time should be in robot clock. If this field is not included, this time will be
        the receive time of the command.
        """
        pass
    @property
    def maximum_velocity(self) -> google.protobuf.wrappers_pb2.DoubleValue:
        """The maximum velocity in rad/s that any joint is allowed to achieve.
        If this field is not set, a default value will be used.
        """
        pass
    @property
    def maximum_acceleration(self) -> google.protobuf.wrappers_pb2.DoubleValue:
        """The maximum acceleration in rad/s^2 that any joint is allowed to
        achieve. If this field is not set, a default value will be used.
        """
        pass
    def __init__(self,
        *,
        points: typing.Optional[typing.Iterable[global___ArmJointTrajectoryPoint]] = ...,
        reference_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        maximum_velocity: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        maximum_acceleration: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["maximum_acceleration",b"maximum_acceleration","maximum_velocity",b"maximum_velocity","reference_time",b"reference_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["maximum_acceleration",b"maximum_acceleration","maximum_velocity",b"maximum_velocity","points",b"points","reference_time",b"reference_time"]) -> None: ...
global___ArmJointTrajectory = ArmJointTrajectory

class GazeCommand(google.protobuf.message.Message):
    """/ Move the hand in such a way to point it at a position in the world."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TARGET_TRAJECTORY_IN_FRAME1_FIELD_NUMBER: builtins.int
        FRAME1_NAME_FIELD_NUMBER: builtins.int
        TOOL_TRAJECTORY_IN_FRAME2_FIELD_NUMBER: builtins.int
        FRAME2_NAME_FIELD_NUMBER: builtins.int
        WRIST_TFORM_TOOL_FIELD_NUMBER: builtins.int
        TARGET_TRAJECTORY_INITIAL_VELOCITY_FIELD_NUMBER: builtins.int
        MAXIMUM_ACCELERATION_FIELD_NUMBER: builtins.int
        MAX_LINEAR_VELOCITY_FIELD_NUMBER: builtins.int
        MAX_ANGULAR_VELOCITY_FIELD_NUMBER: builtins.int
        @property
        def target_trajectory_in_frame1(self) -> bosdyn.api.trajectory_pb2.Vec3Trajectory:
            """Point(s) to look at expressed in frame1."""
            pass
        frame1_name: typing.Text
        @property
        def tool_trajectory_in_frame2(self) -> bosdyn.api.trajectory_pb2.SE3Trajectory:
            """Optional, desired pose of the tool expressed in frame2.  Will be constrained to 'look at'
            the target regardless of the requested orientation.
            """
            pass
        frame2_name: typing.Text
        @property
        def wrist_tform_tool(self) -> bosdyn.api.geometry_pb2.SE3Pose:
            """The transformation of the tool pose relative to the parent link (wrist).
            If the field is left unset, the transform will default to:
                 The position is wrist_tform_hand.position() [20 cm translation in wrist x].
                 The rotation is wrist_tform_hand_camera.rotation() [-9 degree pitch about wrist y].
            """
            pass
        @property
        def target_trajectory_initial_velocity(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional velocity to move the target along the shortest path from the gaze's starting
            position to the first point in the target trajectory.
            """
            pass
        @property
        def maximum_acceleration(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional Maximum acceleration magnitude of the end-effector.
            Valid ranges (0, 20]
            """
            pass
        @property
        def max_linear_velocity(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional Maximum linear velocity magnitude of the end-effector. (m/s)"""
            pass
        @property
        def max_angular_velocity(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Optional Maximum angular velocity magnitude of the end-effector. (rad/s)"""
            pass
        def __init__(self,
            *,
            target_trajectory_in_frame1: typing.Optional[bosdyn.api.trajectory_pb2.Vec3Trajectory] = ...,
            frame1_name: typing.Text = ...,
            tool_trajectory_in_frame2: typing.Optional[bosdyn.api.trajectory_pb2.SE3Trajectory] = ...,
            frame2_name: typing.Text = ...,
            wrist_tform_tool: typing.Optional[bosdyn.api.geometry_pb2.SE3Pose] = ...,
            target_trajectory_initial_velocity: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            maximum_acceleration: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_linear_velocity: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            max_angular_velocity: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["max_angular_velocity",b"max_angular_velocity","max_linear_velocity",b"max_linear_velocity","maximum_acceleration",b"maximum_acceleration","target_trajectory_in_frame1",b"target_trajectory_in_frame1","target_trajectory_initial_velocity",b"target_trajectory_initial_velocity","tool_trajectory_in_frame2",b"tool_trajectory_in_frame2","wrist_tform_tool",b"wrist_tform_tool"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["frame1_name",b"frame1_name","frame2_name",b"frame2_name","max_angular_velocity",b"max_angular_velocity","max_linear_velocity",b"max_linear_velocity","maximum_acceleration",b"maximum_acceleration","target_trajectory_in_frame1",b"target_trajectory_in_frame1","target_trajectory_initial_velocity",b"target_trajectory_initial_velocity","tool_trajectory_in_frame2",b"tool_trajectory_in_frame2","wrist_tform_tool",b"wrist_tform_tool"]) -> None: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[GazeCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: GazeCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            STATUS_TRAJECTORY_COMPLETE: GazeCommand.Feedback._Status.ValueType  # 1
            """Robot is gazing at the target at the end of the trajectory."""

            STATUS_IN_PROGRESS: GazeCommand.Feedback._Status.ValueType  # 2
            """Robot is re-configuring arm to gaze at the target."""

            STATUS_TOOL_TRAJECTORY_STALLED: GazeCommand.Feedback._Status.ValueType  # 3
            """The arm has stopped making progress to the goal pose for the tool.
            Note, this does not cancel the trajectory. For example, if the requested goal is too
            far away, walking the base robot closer to the goal will cause the arm to continue
            along the trajectory once it can continue.
            """

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: GazeCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        STATUS_TRAJECTORY_COMPLETE: GazeCommand.Feedback.Status.ValueType  # 1
        """Robot is gazing at the target at the end of the trajectory."""

        STATUS_IN_PROGRESS: GazeCommand.Feedback.Status.ValueType  # 2
        """Robot is re-configuring arm to gaze at the target."""

        STATUS_TOOL_TRAJECTORY_STALLED: GazeCommand.Feedback.Status.ValueType  # 3
        """The arm has stopped making progress to the goal pose for the tool.
        Note, this does not cancel the trajectory. For example, if the requested goal is too
        far away, walking the base robot closer to the goal will cause the arm to continue
        along the trajectory once it can continue.
        """


        STATUS_FIELD_NUMBER: builtins.int
        GAZING_AT_TARGET_FIELD_NUMBER: builtins.int
        GAZE_TO_TARGET_ROTATION_MEASURED_FIELD_NUMBER: builtins.int
        HAND_POSITION_AT_GOAL_FIELD_NUMBER: builtins.int
        HAND_DISTANCE_TO_GOAL_MEASURED_FIELD_NUMBER: builtins.int
        HAND_ROLL_AT_GOAL_FIELD_NUMBER: builtins.int
        HAND_ROLL_TO_TARGET_ROLL_MEASURED_FIELD_NUMBER: builtins.int
        status: global___GazeCommand.Feedback.Status.ValueType
        """Current status of the command."""

        gazing_at_target: builtins.bool
        """If we are gazing at the target
        Rotation from the current gaze point to the trajectory's end [radians]
        """

        gaze_to_target_rotation_measured: builtins.float
        hand_position_at_goal: builtins.bool
        """If the hand's position is at the goal.
        Distance from the hand's current position to the trajectory's end [meters]
        """

        hand_distance_to_goal_measured: builtins.float
        hand_roll_at_goal: builtins.bool
        """If the hand's roll is at the goal.
        Rotation from the current hand position to the desired roll at the trajectory's end
        [radians]
        """

        hand_roll_to_target_roll_measured: builtins.float
        def __init__(self,
            *,
            status: global___GazeCommand.Feedback.Status.ValueType = ...,
            gazing_at_target: builtins.bool = ...,
            gaze_to_target_rotation_measured: builtins.float = ...,
            hand_position_at_goal: builtins.bool = ...,
            hand_distance_to_goal_measured: builtins.float = ...,
            hand_roll_at_goal: builtins.bool = ...,
            hand_roll_to_target_roll_measured: builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["gaze_to_target_rotation_measured",b"gaze_to_target_rotation_measured","gazing_at_target",b"gazing_at_target","hand_distance_to_goal_measured",b"hand_distance_to_goal_measured","hand_position_at_goal",b"hand_position_at_goal","hand_roll_at_goal",b"hand_roll_at_goal","hand_roll_to_target_roll_measured",b"hand_roll_to_target_roll_measured","status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___GazeCommand = GazeCommand

class ArmStopCommand(google.protobuf.message.Message):
    """Stop the arm applying minimal forces to the world. For example, if the arm is in the  middle of
    opening a heavy door and a stop command is sent, the arm will comply and let the door close.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        """Stop command takes no arguments."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    class Feedback(google.protobuf.message.Message):
        """Stop command provides no feedback"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    def __init__(self,
        ) -> None: ...
global___ArmStopCommand = ArmStopCommand
