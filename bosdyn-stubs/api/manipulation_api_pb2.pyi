"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.geometry_pb2
import bosdyn.api.header_pb2
import bosdyn.api.image_pb2
import bosdyn.api.lease_pb2
import bosdyn.api.robot_state_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _GraspPositionConstraint:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _GraspPositionConstraintEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_GraspPositionConstraint.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    GRASP_POSITION_CONSTRAINT_UNKNOWN: _GraspPositionConstraint.ValueType  # 0
    GRASP_POSITION_CONSTRAINT_NORMAL: _GraspPositionConstraint.ValueType  # 1
    GRASP_POSITION_CONSTRAINT_FIXED_AT_USER_POSITION: _GraspPositionConstraint.ValueType  # 2
class GraspPositionConstraint(_GraspPositionConstraint, metaclass=_GraspPositionConstraintEnumTypeWrapper):
    pass

GRASP_POSITION_CONSTRAINT_UNKNOWN: GraspPositionConstraint.ValueType  # 0
GRASP_POSITION_CONSTRAINT_NORMAL: GraspPositionConstraint.ValueType  # 1
GRASP_POSITION_CONSTRAINT_FIXED_AT_USER_POSITION: GraspPositionConstraint.ValueType  # 2
global___GraspPositionConstraint = GraspPositionConstraint


class _ManipulationFeedbackState:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _ManipulationFeedbackStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ManipulationFeedbackState.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    MANIP_STATE_UNKNOWN: _ManipulationFeedbackState.ValueType  # 0
    MANIP_STATE_DONE: _ManipulationFeedbackState.ValueType  # 1
    MANIP_STATE_SEARCHING_FOR_GRASP: _ManipulationFeedbackState.ValueType  # 2
    MANIP_STATE_MOVING_TO_GRASP: _ManipulationFeedbackState.ValueType  # 3
    MANIP_STATE_GRASPING_OBJECT: _ManipulationFeedbackState.ValueType  # 4
    MANIP_STATE_PLACING_OBJECT: _ManipulationFeedbackState.ValueType  # 5
    MANIP_STATE_GRASP_SUCCEEDED: _ManipulationFeedbackState.ValueType  # 6
    MANIP_STATE_GRASP_FAILED: _ManipulationFeedbackState.ValueType  # 7
    MANIP_STATE_GRASP_PLANNING_SUCCEEDED: _ManipulationFeedbackState.ValueType  # 11
    MANIP_STATE_GRASP_PLANNING_NO_SOLUTION: _ManipulationFeedbackState.ValueType  # 8
    MANIP_STATE_GRASP_FAILED_TO_RAYCAST_INTO_MAP: _ManipulationFeedbackState.ValueType  # 9
    """Note: if you are experiencing raycast failures during grasping, consider using a different
    grasping call that does not require the robot to automatically walk up to the grasp.
    """

    MANIP_STATE_GRASP_PLANNING_WAITING_DATA_AT_EDGE: _ManipulationFeedbackState.ValueType  # 13
    """The grasp planner is waiting for the gaze to have the target object not on the edge of the
    camera view.  If you are seeing this in an automatic mode, the robot will soon retarget the
    grasp for you.  If you are seeing this in a non-auto mode, you'll need to change your gaze
    to have the target object more in the center of the hand-camera's view.
    """

    MANIP_STATE_WALKING_TO_OBJECT: _ManipulationFeedbackState.ValueType  # 10
    MANIP_STATE_ATTEMPTING_RAYCASTING: _ManipulationFeedbackState.ValueType  # 12
    MANIP_STATE_MOVING_TO_PLACE: _ManipulationFeedbackState.ValueType  # 14
    MANIP_STATE_PLACE_FAILED_TO_RAYCAST_INTO_MAP: _ManipulationFeedbackState.ValueType  # 15
    MANIP_STATE_PLACE_SUCCEEDED: _ManipulationFeedbackState.ValueType  # 16
    MANIP_STATE_PLACE_FAILED: _ManipulationFeedbackState.ValueType  # 17
class ManipulationFeedbackState(_ManipulationFeedbackState, metaclass=_ManipulationFeedbackStateEnumTypeWrapper):
    pass

MANIP_STATE_UNKNOWN: ManipulationFeedbackState.ValueType  # 0
MANIP_STATE_DONE: ManipulationFeedbackState.ValueType  # 1
MANIP_STATE_SEARCHING_FOR_GRASP: ManipulationFeedbackState.ValueType  # 2
MANIP_STATE_MOVING_TO_GRASP: ManipulationFeedbackState.ValueType  # 3
MANIP_STATE_GRASPING_OBJECT: ManipulationFeedbackState.ValueType  # 4
MANIP_STATE_PLACING_OBJECT: ManipulationFeedbackState.ValueType  # 5
MANIP_STATE_GRASP_SUCCEEDED: ManipulationFeedbackState.ValueType  # 6
MANIP_STATE_GRASP_FAILED: ManipulationFeedbackState.ValueType  # 7
MANIP_STATE_GRASP_PLANNING_SUCCEEDED: ManipulationFeedbackState.ValueType  # 11
MANIP_STATE_GRASP_PLANNING_NO_SOLUTION: ManipulationFeedbackState.ValueType  # 8
MANIP_STATE_GRASP_FAILED_TO_RAYCAST_INTO_MAP: ManipulationFeedbackState.ValueType  # 9
"""Note: if you are experiencing raycast failures during grasping, consider using a different
grasping call that does not require the robot to automatically walk up to the grasp.
"""

MANIP_STATE_GRASP_PLANNING_WAITING_DATA_AT_EDGE: ManipulationFeedbackState.ValueType  # 13
"""The grasp planner is waiting for the gaze to have the target object not on the edge of the
camera view.  If you are seeing this in an automatic mode, the robot will soon retarget the
grasp for you.  If you are seeing this in a non-auto mode, you'll need to change your gaze
to have the target object more in the center of the hand-camera's view.
"""

MANIP_STATE_WALKING_TO_OBJECT: ManipulationFeedbackState.ValueType  # 10
MANIP_STATE_ATTEMPTING_RAYCASTING: ManipulationFeedbackState.ValueType  # 12
MANIP_STATE_MOVING_TO_PLACE: ManipulationFeedbackState.ValueType  # 14
MANIP_STATE_PLACE_FAILED_TO_RAYCAST_INTO_MAP: ManipulationFeedbackState.ValueType  # 15
MANIP_STATE_PLACE_SUCCEEDED: ManipulationFeedbackState.ValueType  # 16
MANIP_STATE_PLACE_FAILED: ManipulationFeedbackState.ValueType  # 17
global___ManipulationFeedbackState = ManipulationFeedbackState


class _ManipulationCameraSource:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _ManipulationCameraSourceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ManipulationCameraSource.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    MANIPULATION_CAMERA_SOURCE_UNKNOWN: _ManipulationCameraSource.ValueType  # 0
    MANIPULATION_CAMERA_SOURCE_STEREO: _ManipulationCameraSource.ValueType  # 1
    MANIPULATION_CAMERA_SOURCE_HAND: _ManipulationCameraSource.ValueType  # 2
class ManipulationCameraSource(_ManipulationCameraSource, metaclass=_ManipulationCameraSourceEnumTypeWrapper):
    pass

MANIPULATION_CAMERA_SOURCE_UNKNOWN: ManipulationCameraSource.ValueType  # 0
MANIPULATION_CAMERA_SOURCE_STEREO: ManipulationCameraSource.ValueType  # 1
MANIPULATION_CAMERA_SOURCE_HAND: ManipulationCameraSource.ValueType  # 2
global___ManipulationCameraSource = ManipulationCameraSource


class _WalkGazeMode:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _WalkGazeModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_WalkGazeMode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PICK_WALK_GAZE_UNKNOWN: _WalkGazeMode.ValueType  # 0
    PICK_AUTO_WALK_AND_GAZE: _WalkGazeMode.ValueType  # 1
    """Default, walk to the target and gaze at it automatically"""

    PICK_AUTO_GAZE: _WalkGazeMode.ValueType  # 2
    """Don't move the robot base, but automatically look at the grasp target."""

    PICK_NO_AUTO_WALK_OR_GAZE: _WalkGazeMode.ValueType  # 3
    """No automatic gazing or walking. Note: if you choose this option, the target location
    must not be near the edges or off the screen on the hand camera's view.
    """

    PICK_PLAN_ONLY: _WalkGazeMode.ValueType  # 4
    """Only plan for the grasp, don't move the robot.  Since we won't move
    the robot, the target location must not be near the edges or out of
    the hand camera's view.  The robot must be located near the object.
    (Equivalent conditions as for success with PICK_NO_AUTO_WALK_OR_GAZE)
    """

class WalkGazeMode(_WalkGazeMode, metaclass=_WalkGazeModeEnumTypeWrapper):
    """Configure automatic walking and gazing at the target."""
    pass

PICK_WALK_GAZE_UNKNOWN: WalkGazeMode.ValueType  # 0
PICK_AUTO_WALK_AND_GAZE: WalkGazeMode.ValueType  # 1
"""Default, walk to the target and gaze at it automatically"""

PICK_AUTO_GAZE: WalkGazeMode.ValueType  # 2
"""Don't move the robot base, but automatically look at the grasp target."""

PICK_NO_AUTO_WALK_OR_GAZE: WalkGazeMode.ValueType  # 3
"""No automatic gazing or walking. Note: if you choose this option, the target location
must not be near the edges or off the screen on the hand camera's view.
"""

PICK_PLAN_ONLY: WalkGazeMode.ValueType  # 4
"""Only plan for the grasp, don't move the robot.  Since we won't move
the robot, the target location must not be near the edges or out of
the hand camera's view.  The robot must be located near the object.
(Equivalent conditions as for success with PICK_NO_AUTO_WALK_OR_GAZE)
"""

global___WalkGazeMode = WalkGazeMode


class WalkToObjectRayInWorld(google.protobuf.message.Message):
    """Walks the robot up to an object.  Useful to prepare to grasp or manipulate something."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RAY_START_RT_FRAME_FIELD_NUMBER: builtins.int
    RAY_END_RT_FRAME_FIELD_NUMBER: builtins.int
    FRAME_NAME_FIELD_NUMBER: builtins.int
    OFFSET_DISTANCE_FIELD_NUMBER: builtins.int
    @property
    def ray_start_rt_frame(self) -> bosdyn.api.geometry_pb2.Vec3:
        """Position of the start of the ray (see PickObjectRayInWorld for detailed comments.)"""
        pass
    @property
    def ray_end_rt_frame(self) -> bosdyn.api.geometry_pb2.Vec3:
        """Position of the end of the ray."""
        pass
    frame_name: typing.Text
    """Name of the frame that the above parameters are expressed in."""

    @property
    def offset_distance(self) -> google.protobuf.wrappers_pb2.FloatValue:
        """Optional offset distance for the robot to stand from the object's location.  The robot will
        walk forwards or backwards from where it is so that its center of mass is this distance from
        the object. \\
        If unset, we use a reasonable default value.
        """
        pass
    def __init__(self,
        *,
        ray_start_rt_frame: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
        ray_end_rt_frame: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
        frame_name: typing.Text = ...,
        offset_distance: typing.Optional[google.protobuf.wrappers_pb2.FloatValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset_distance",b"offset_distance","ray_end_rt_frame",b"ray_end_rt_frame","ray_start_rt_frame",b"ray_start_rt_frame"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["frame_name",b"frame_name","offset_distance",b"offset_distance","ray_end_rt_frame",b"ray_end_rt_frame","ray_start_rt_frame",b"ray_start_rt_frame"]) -> None: ...
global___WalkToObjectRayInWorld = WalkToObjectRayInWorld

class WalkToObjectInImage(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PIXEL_XY_FIELD_NUMBER: builtins.int
    TRANSFORMS_SNAPSHOT_FOR_CAMERA_FIELD_NUMBER: builtins.int
    FRAME_NAME_IMAGE_SENSOR_FIELD_NUMBER: builtins.int
    CAMERA_MODEL_FIELD_NUMBER: builtins.int
    OFFSET_DISTANCE_FIELD_NUMBER: builtins.int
    @property
    def pixel_xy(self) -> bosdyn.api.geometry_pb2.Vec2:
        """Walk to an object that is at a pixel location in an image."""
        pass
    @property
    def transforms_snapshot_for_camera(self) -> bosdyn.api.geometry_pb2.FrameTreeSnapshot:
        """A tree-based collection of transformations, which will include the transformations to each image's
        sensor in addition to transformations to the common frames ("vision", "body", "odom").
        All transforms within the snapshot are at the acquistion time of the image.
        """
        pass
    frame_name_image_sensor: typing.Text
    """The frame name for the image's sensor source. This will be included in the transform snapshot."""

    @property
    def camera_model(self) -> bosdyn.api.image_pb2.ImageSource.PinholeModel:
        """Camera model."""
        pass
    @property
    def offset_distance(self) -> google.protobuf.wrappers_pb2.FloatValue:
        """Optional offset distance for the robot to stand from the object's location.  The robot will
        walk forwards or backwards from where it is so that its center of mass is this distance from
        the object. \\
        If unset, we use a reasonable default value.
        """
        pass
    def __init__(self,
        *,
        pixel_xy: typing.Optional[bosdyn.api.geometry_pb2.Vec2] = ...,
        transforms_snapshot_for_camera: typing.Optional[bosdyn.api.geometry_pb2.FrameTreeSnapshot] = ...,
        frame_name_image_sensor: typing.Text = ...,
        camera_model: typing.Optional[bosdyn.api.image_pb2.ImageSource.PinholeModel] = ...,
        offset_distance: typing.Optional[google.protobuf.wrappers_pb2.FloatValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["camera_model",b"camera_model","offset_distance",b"offset_distance","pixel_xy",b"pixel_xy","transforms_snapshot_for_camera",b"transforms_snapshot_for_camera"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["camera_model",b"camera_model","frame_name_image_sensor",b"frame_name_image_sensor","offset_distance",b"offset_distance","pixel_xy",b"pixel_xy","transforms_snapshot_for_camera",b"transforms_snapshot_for_camera"]) -> None: ...
global___WalkToObjectInImage = WalkToObjectInImage

class PickObjectRayInWorld(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RAY_START_RT_FRAME_FIELD_NUMBER: builtins.int
    RAY_END_RT_FRAME_FIELD_NUMBER: builtins.int
    FRAME_NAME_FIELD_NUMBER: builtins.int
    GRASP_PARAMS_FIELD_NUMBER: builtins.int
    WALK_GAZE_MODE_FIELD_NUMBER: builtins.int
    @property
    def ray_start_rt_frame(self) -> bosdyn.api.geometry_pb2.Vec3:
        """Cast a ray in the world and pick the first object found along the ray. \\
        This is the lowest-level grasping message; all other grasp options internally use this
        message to trigger a grasp. \\
        Example:
         You see the object you are interested in with the gripper's camera.  To grasp it, you
         cast a ray from the camera out to 4 meters (well past the object). \\
         To do this you'd set: \\
             ray_start_rt_frame: camera's position \\
             ray_end_rt_frame: camera's position + unit vector along ray of interest * 4 meters
        """
        pass
    @property
    def ray_end_rt_frame(self) -> bosdyn.api.geometry_pb2.Vec3: ...
    frame_name: typing.Text
    """Name of the frame the above parameters are represented in."""

    @property
    def grasp_params(self) -> global___GraspParams:
        """Optional parameters for the grasp."""
        pass
    walk_gaze_mode: global___WalkGazeMode.ValueType
    """Configure if the robot should automatically walk and/or gaze at the target object before
    performing the grasp. \\
    1. If you haven't moved the robot or deployed the arm, use PICK_AUTO_WALK_AND_GAZE \\
    2. If you have moved to the location you want to pick from, but haven't yet deployed the arm,
       use PICK_AUTO_GAZE. \\
    3. If you have already moved the robot and have the hand looking at your target object, use
       PICK_NO_AUTO_WALK_OR_GAZE. \\
    If you are seeing issues with "MANIP_STATE_GRASP_FAILED_TO_RAYCAST_INTO_MAP," that means that
    the automatic system cannot find your object when trying to automatically walk to it, so
    consider using PICK_AUTO_GAZE or PICK_NO_AUTO_WALK_OR_GAZE.
    """

    def __init__(self,
        *,
        ray_start_rt_frame: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
        ray_end_rt_frame: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
        frame_name: typing.Text = ...,
        grasp_params: typing.Optional[global___GraspParams] = ...,
        walk_gaze_mode: global___WalkGazeMode.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["grasp_params",b"grasp_params","ray_end_rt_frame",b"ray_end_rt_frame","ray_start_rt_frame",b"ray_start_rt_frame"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["frame_name",b"frame_name","grasp_params",b"grasp_params","ray_end_rt_frame",b"ray_end_rt_frame","ray_start_rt_frame",b"ray_start_rt_frame","walk_gaze_mode",b"walk_gaze_mode"]) -> None: ...
global___PickObjectRayInWorld = PickObjectRayInWorld

class PickObjectExecutePlan(google.protobuf.message.Message):
    """No data"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___PickObjectExecutePlan = PickObjectExecutePlan

class PickObject(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    FRAME_NAME_FIELD_NUMBER: builtins.int
    OBJECT_RT_FRAME_FIELD_NUMBER: builtins.int
    GRASP_PARAMS_FIELD_NUMBER: builtins.int
    frame_name: typing.Text
    """Name of the frame you want to give your input in."""

    @property
    def object_rt_frame(self) -> bosdyn.api.geometry_pb2.Vec3:
        """Pickup an object at the location, given in the frame named above."""
        pass
    @property
    def grasp_params(self) -> global___GraspParams:
        """Optional parameters for the grasp."""
        pass
    def __init__(self,
        *,
        frame_name: typing.Text = ...,
        object_rt_frame: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
        grasp_params: typing.Optional[global___GraspParams] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["grasp_params",b"grasp_params","object_rt_frame",b"object_rt_frame"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["frame_name",b"frame_name","grasp_params",b"grasp_params","object_rt_frame",b"object_rt_frame"]) -> None: ...
global___PickObject = PickObject

class PickObjectInImage(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PIXEL_XY_FIELD_NUMBER: builtins.int
    TRANSFORMS_SNAPSHOT_FOR_CAMERA_FIELD_NUMBER: builtins.int
    FRAME_NAME_IMAGE_SENSOR_FIELD_NUMBER: builtins.int
    CAMERA_MODEL_FIELD_NUMBER: builtins.int
    GRASP_PARAMS_FIELD_NUMBER: builtins.int
    WALK_GAZE_MODE_FIELD_NUMBER: builtins.int
    @property
    def pixel_xy(self) -> bosdyn.api.geometry_pb2.Vec2:
        """Pickup an object that is at a pixel location in an image."""
        pass
    @property
    def transforms_snapshot_for_camera(self) -> bosdyn.api.geometry_pb2.FrameTreeSnapshot:
        """A tree-based collection of transformations, which will include the transformations to each image's
        sensor in addition to transformations to the common frames ("vision", "body", "odom").
        All transforms within the snapshot are at the acquistion time of the image.
        """
        pass
    frame_name_image_sensor: typing.Text
    """The frame name for the image's sensor source. This must be included in the transform snapshot."""

    @property
    def camera_model(self) -> bosdyn.api.image_pb2.ImageSource.PinholeModel:
        """Camera model."""
        pass
    @property
    def grasp_params(self) -> global___GraspParams:
        """Optional parameters for the grasp."""
        pass
    walk_gaze_mode: global___WalkGazeMode.ValueType
    """Automatic walking / gazing configuration.
    See detailed comment in the PickObjectRayInWorld message.
    """

    def __init__(self,
        *,
        pixel_xy: typing.Optional[bosdyn.api.geometry_pb2.Vec2] = ...,
        transforms_snapshot_for_camera: typing.Optional[bosdyn.api.geometry_pb2.FrameTreeSnapshot] = ...,
        frame_name_image_sensor: typing.Text = ...,
        camera_model: typing.Optional[bosdyn.api.image_pb2.ImageSource.PinholeModel] = ...,
        grasp_params: typing.Optional[global___GraspParams] = ...,
        walk_gaze_mode: global___WalkGazeMode.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["camera_model",b"camera_model","grasp_params",b"grasp_params","pixel_xy",b"pixel_xy","transforms_snapshot_for_camera",b"transforms_snapshot_for_camera"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["camera_model",b"camera_model","frame_name_image_sensor",b"frame_name_image_sensor","grasp_params",b"grasp_params","pixel_xy",b"pixel_xy","transforms_snapshot_for_camera",b"transforms_snapshot_for_camera","walk_gaze_mode",b"walk_gaze_mode"]) -> None: ...
global___PickObjectInImage = PickObjectInImage

class GraspParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    GRASP_PALM_TO_FINGERTIP_FIELD_NUMBER: builtins.int
    GRASP_PARAMS_FRAME_NAME_FIELD_NUMBER: builtins.int
    ALLOWABLE_ORIENTATION_FIELD_NUMBER: builtins.int
    POSITION_CONSTRAINT_FIELD_NUMBER: builtins.int
    MANIPULATION_CAMERA_SOURCE_FIELD_NUMBER: builtins.int
    grasp_palm_to_fingertip: builtins.float
    """Where the grasp is on the hand.  Set to 0 to be a (default) palm grasp, where the object will
    be pressed against the gripper's palm plate.  Set to 1.0 to be a fingertip grasp, where the
    robot will try to pick up the target with just the tip of its fingers. \\
    Intermediate values move the grasp location between the two extremes.
    """

    grasp_params_frame_name: typing.Text
    """Frame name for the frame that the constraints in allowable_orientation are expressed in."""

    @property
    def allowable_orientation(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AllowableOrientation]:
        """Optional constraints about the orientation of the grasp.  This field lets you specify things
        like "only do a top down grasp," "grasp only from this direction," or "grasp with the gripper
        upside-down."  If you don't pass anything, the robot will automatically search for a good
        grasp orientation.
        """
        pass
    position_constraint: global___GraspPositionConstraint.ValueType
    """Optional parameter on how much the robot is allowed to move the grasp from where the user
    requested.  Set this to be GRASP_POSITION_CONSTRAINT_FIXED_AT_USER_POSITION to get a grasp
    that is at the exact position you requested, but has less or no automatic grasp selection
    help in position.
    """

    manipulation_camera_source: global___ManipulationCameraSource.ValueType
    """Optional hint about which camera was used to generate the target points.  The robot will
    attempt to correct for calibration error between the arm and the body cameras.
    """

    def __init__(self,
        *,
        grasp_palm_to_fingertip: builtins.float = ...,
        grasp_params_frame_name: typing.Text = ...,
        allowable_orientation: typing.Optional[typing.Iterable[global___AllowableOrientation]] = ...,
        position_constraint: global___GraspPositionConstraint.ValueType = ...,
        manipulation_camera_source: global___ManipulationCameraSource.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["allowable_orientation",b"allowable_orientation","grasp_palm_to_fingertip",b"grasp_palm_to_fingertip","grasp_params_frame_name",b"grasp_params_frame_name","manipulation_camera_source",b"manipulation_camera_source","position_constraint",b"position_constraint"]) -> None: ...
global___GraspParams = GraspParams

class AllowableOrientation(google.protobuf.message.Message):
    """Allowable orientation allow you to specify vectors that the different axes of the robot's
    gripper will be aligned with in the final grasp pose. \\

    Frame: \\
     In stow position, +X is to the front of the gripper, pointing forward. \\
                       +Y is out of the side of the gripper going to the robot's left \\
                       +Z is straight up towards the sky \\

    Here, you can supply vectors that you want the gripper to be aligned with at the final grasp
    position.  For example, if you wanted to grasp a cup, you'd wouldn't want a top-down grasp.
    So you might specify: \\
         frame_name = "vision" (so that Z is gravity aligned) \\
          VectorAlignmentWithTolerance: \\
             axis_to_on_gripper_ewrt_gripper = Vec3(0, 0, 1)  <--- we want to control the
                                                                   gripper's z-axis. \\

             axis_to_align_with_ewrt_frame = Vec3(0, 0, 1)  <--- ...and we want that axis to be
                                                                    straight up \\
             tolerance_z = 0.52  <--- 30 degrees \\
       This will ensure that the z-axis of the gripper is pointed within 30 degrees of vertical
       so that your grasp won't be top-down (which would need the z-axis of the gripper to be
       pointed at the horizon). \\

    You can also specify more than one AllowableOrientation to give the system multiple options.
    For example, you could specify that you're OK with either a z-up or z-down version of the cup
    grasp, allowing the gripper roll 180 from the stow position to grasp the cup.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ROTATION_WITH_TOLERANCE_FIELD_NUMBER: builtins.int
    VECTOR_ALIGNMENT_WITH_TOLERANCE_FIELD_NUMBER: builtins.int
    SQUEEZE_GRASP_FIELD_NUMBER: builtins.int
    @property
    def rotation_with_tolerance(self) -> global___RotationWithTolerance: ...
    @property
    def vector_alignment_with_tolerance(self) -> global___VectorAlignmentWithTolerance: ...
    @property
    def squeeze_grasp(self) -> global___SqueezeGrasp: ...
    def __init__(self,
        *,
        rotation_with_tolerance: typing.Optional[global___RotationWithTolerance] = ...,
        vector_alignment_with_tolerance: typing.Optional[global___VectorAlignmentWithTolerance] = ...,
        squeeze_grasp: typing.Optional[global___SqueezeGrasp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["constraint",b"constraint","rotation_with_tolerance",b"rotation_with_tolerance","squeeze_grasp",b"squeeze_grasp","vector_alignment_with_tolerance",b"vector_alignment_with_tolerance"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["constraint",b"constraint","rotation_with_tolerance",b"rotation_with_tolerance","squeeze_grasp",b"squeeze_grasp","vector_alignment_with_tolerance",b"vector_alignment_with_tolerance"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["constraint",b"constraint"]) -> typing.Optional[typing_extensions.Literal["rotation_with_tolerance","vector_alignment_with_tolerance","squeeze_grasp"]]: ...
global___AllowableOrientation = AllowableOrientation

class RotationWithTolerance(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ROTATION_EWRT_FRAME_FIELD_NUMBER: builtins.int
    THRESHOLD_RADIANS_FIELD_NUMBER: builtins.int
    @property
    def rotation_ewrt_frame(self) -> bosdyn.api.geometry_pb2.Quaternion: ...
    threshold_radians: builtins.float
    def __init__(self,
        *,
        rotation_ewrt_frame: typing.Optional[bosdyn.api.geometry_pb2.Quaternion] = ...,
        threshold_radians: builtins.float = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["rotation_ewrt_frame",b"rotation_ewrt_frame"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["rotation_ewrt_frame",b"rotation_ewrt_frame","threshold_radians",b"threshold_radians"]) -> None: ...
global___RotationWithTolerance = RotationWithTolerance

class VectorAlignmentWithTolerance(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    AXIS_ON_GRIPPER_EWRT_GRIPPER_FIELD_NUMBER: builtins.int
    AXIS_TO_ALIGN_WITH_EWRT_FRAME_FIELD_NUMBER: builtins.int
    THRESHOLD_RADIANS_FIELD_NUMBER: builtins.int
    @property
    def axis_on_gripper_ewrt_gripper(self) -> bosdyn.api.geometry_pb2.Vec3:
        """Axis on the gripper that you want to align.  For example, to align the front of the gripper
        to be straight down, you'd use: \\
             axis_on_gripper_ewrt_gripper = Vec3(1, 0, 0) \\
             axis_to_align_with_ewrt_frame = Vec3(0, 0, -1)   (in the "vision" frame) \\
        """
        pass
    @property
    def axis_to_align_with_ewrt_frame(self) -> bosdyn.api.geometry_pb2.Vec3: ...
    threshold_radians: builtins.float
    def __init__(self,
        *,
        axis_on_gripper_ewrt_gripper: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
        axis_to_align_with_ewrt_frame: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
        threshold_radians: builtins.float = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["axis_on_gripper_ewrt_gripper",b"axis_on_gripper_ewrt_gripper","axis_to_align_with_ewrt_frame",b"axis_to_align_with_ewrt_frame"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["axis_on_gripper_ewrt_gripper",b"axis_on_gripper_ewrt_gripper","axis_to_align_with_ewrt_frame",b"axis_to_align_with_ewrt_frame","threshold_radians",b"threshold_radians"]) -> None: ...
global___VectorAlignmentWithTolerance = VectorAlignmentWithTolerance

class SqueezeGrasp(google.protobuf.message.Message):
    """A "squeeze grasp" is a top-down grasp where we try to keep both jaws of the gripper in
    contact with the ground and bring the jaws together.  This can allow the robot to pick up
    small objects on the ground.

    If you specify a SqueezeGrasp as:
         allowed:
             - with no other allowable orientations:
                 then the robot will perform a squeeze grasp.
             - with at least one other allowable orientation:
                 the robot will attempt to find a normal grasp with that orientation and if it
                 fails, will perform a squeeze grasp.
         disallowed:
             - with no other allowable orientations:
                 the robot will perform an unconstrained grasp search and a grasp if a good grasp
                 is found.  If no grasp is found, the robot will report
                 MANIP_STATE_GRASP_PLANNING_NO_SOLUTION
             - with other allowable orientations:
                 the robot will attempt to find a valid grasp.  If it cannot it will report
                 MANIP_STATE_GRASP_PLANNING_NO_SOLUTION
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SQUEEZE_GRASP_DISALLOWED_FIELD_NUMBER: builtins.int
    squeeze_grasp_disallowed: builtins.bool
    def __init__(self,
        *,
        squeeze_grasp_disallowed: builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["squeeze_grasp_disallowed",b"squeeze_grasp_disallowed"]) -> None: ...
global___SqueezeGrasp = SqueezeGrasp

class ManipulationApiFeedbackRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    MANIPULATION_CMD_ID_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    manipulation_cmd_id: builtins.int
    """Unique identifier for the command, provided by ManipulationApiResponse."""

    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        manipulation_cmd_id: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","manipulation_cmd_id",b"manipulation_cmd_id"]) -> None: ...
global___ManipulationApiFeedbackRequest = ManipulationApiFeedbackRequest

class ManipulationApiFeedbackResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    MANIPULATION_CMD_ID_FIELD_NUMBER: builtins.int
    CURRENT_STATE_FIELD_NUMBER: builtins.int
    TRANSFORMS_SNAPSHOT_MANIPULATION_DATA_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """/ Common response header."""
        pass
    manipulation_cmd_id: builtins.int
    """The unique identifier for the ManipulationApiFeedbackRequest."""

    current_state: global___ManipulationFeedbackState.ValueType
    @property
    def transforms_snapshot_manipulation_data(self) -> bosdyn.api.geometry_pb2.FrameTreeSnapshot:
        """Data from the manipulation system: \\
        "walkto_raycast_intersection": \\
             If you sent a WalkToObject request, we raycast in the world to intersect your pixel/ray
             with the world.  The point of intersection is included in this transform snapshot
             with the name "walkto_raycast_intersection". \\
        "grasp_planning_solution": \\
             If you requested a grasp plan, this frame will contain the planning solution if
             available.  This will be the pose of the "hand" frame at the completion of the grasp. \\
        "gripper_nearest_object": \\
             If the range camera in the hand senses an object, this frame will have the position of
             the nearest object.  This is useful for getting a ballpark range measurement.
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        manipulation_cmd_id: builtins.int = ...,
        current_state: global___ManipulationFeedbackState.ValueType = ...,
        transforms_snapshot_manipulation_data: typing.Optional[bosdyn.api.geometry_pb2.FrameTreeSnapshot] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","transforms_snapshot_manipulation_data",b"transforms_snapshot_manipulation_data"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["current_state",b"current_state","header",b"header","manipulation_cmd_id",b"manipulation_cmd_id","transforms_snapshot_manipulation_data",b"transforms_snapshot_manipulation_data"]) -> None: ...
global___ManipulationApiFeedbackResponse = ManipulationApiFeedbackResponse

class ManipulationApiResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    MANIPULATION_CMD_ID_FIELD_NUMBER: builtins.int
    LEASE_USE_RESULT_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """/ Common response header."""
        pass
    manipulation_cmd_id: builtins.int
    """ID of the manipulation command either just issued or that we are providing feedback for."""

    @property
    def lease_use_result(self) -> bosdyn.api.lease_pb2.LeaseUseResult:
        """Details about how the lease was used."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        manipulation_cmd_id: builtins.int = ...,
        lease_use_result: typing.Optional[bosdyn.api.lease_pb2.LeaseUseResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease_use_result",b"lease_use_result","manipulation_cmd_id",b"manipulation_cmd_id"]) -> None: ...
global___ManipulationApiResponse = ManipulationApiResponse

class ManipulationApiRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    LEASE_FIELD_NUMBER: builtins.int
    WALK_TO_OBJECT_RAY_IN_WORLD_FIELD_NUMBER: builtins.int
    WALK_TO_OBJECT_IN_IMAGE_FIELD_NUMBER: builtins.int
    PICK_OBJECT_FIELD_NUMBER: builtins.int
    PICK_OBJECT_IN_IMAGE_FIELD_NUMBER: builtins.int
    PICK_OBJECT_RAY_IN_WORLD_FIELD_NUMBER: builtins.int
    PICK_OBJECT_EXECUTE_PLAN_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def lease(self) -> bosdyn.api.lease_pb2.Lease:
        """The Lease to show ownership of the robot."""
        pass
    @property
    def walk_to_object_ray_in_world(self) -> global___WalkToObjectRayInWorld:
        """Walk to an object with a raycast in to the world"""
        pass
    @property
    def walk_to_object_in_image(self) -> global___WalkToObjectInImage:
        """Walk to an object at a pixel location in an image."""
        pass
    @property
    def pick_object(self) -> global___PickObject:
        """Pick up an object."""
        pass
    @property
    def pick_object_in_image(self) -> global___PickObjectInImage:
        """Pick up an object at a pixel location in an image."""
        pass
    @property
    def pick_object_ray_in_world(self) -> global___PickObjectRayInWorld:
        """Pick up an object based on a ray in 3D space.  This is the lowest-level, most
        configurable object picking command.
        """
        pass
    @property
    def pick_object_execute_plan(self) -> global___PickObjectExecutePlan:
        """Execute a previously planned pick."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        lease: typing.Optional[bosdyn.api.lease_pb2.Lease] = ...,
        walk_to_object_ray_in_world: typing.Optional[global___WalkToObjectRayInWorld] = ...,
        walk_to_object_in_image: typing.Optional[global___WalkToObjectInImage] = ...,
        pick_object: typing.Optional[global___PickObject] = ...,
        pick_object_in_image: typing.Optional[global___PickObjectInImage] = ...,
        pick_object_ray_in_world: typing.Optional[global___PickObjectRayInWorld] = ...,
        pick_object_execute_plan: typing.Optional[global___PickObjectExecutePlan] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease","manipulation_cmd",b"manipulation_cmd","pick_object",b"pick_object","pick_object_execute_plan",b"pick_object_execute_plan","pick_object_in_image",b"pick_object_in_image","pick_object_ray_in_world",b"pick_object_ray_in_world","walk_to_object_in_image",b"walk_to_object_in_image","walk_to_object_ray_in_world",b"walk_to_object_ray_in_world"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","lease",b"lease","manipulation_cmd",b"manipulation_cmd","pick_object",b"pick_object","pick_object_execute_plan",b"pick_object_execute_plan","pick_object_in_image",b"pick_object_in_image","pick_object_ray_in_world",b"pick_object_ray_in_world","walk_to_object_in_image",b"walk_to_object_in_image","walk_to_object_ray_in_world",b"walk_to_object_ray_in_world"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["manipulation_cmd",b"manipulation_cmd"]) -> typing.Optional[typing_extensions.Literal["walk_to_object_ray_in_world","walk_to_object_in_image","pick_object","pick_object_in_image","pick_object_ray_in_world","pick_object_execute_plan"]]: ...
global___ManipulationApiRequest = ManipulationApiRequest

class ApiGraspOverride(google.protobuf.message.Message):
    """Use this message to assert the ground truth about grasping.
    Grasping is usually detected automatically by the robot. If the client wishes to override the
    robot's determination of grasp status, send an ApiGraspOverride message with either:
    OVERRIDE_HOLDING, indicating the gripper is holding something, or
    OVERRIDE_NOT_HOLDING, indicating the gripper is not holding
    anything.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Override:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _OverrideEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ApiGraspOverride._Override.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        OVERRIDE_UNKNOWN: ApiGraspOverride._Override.ValueType  # 0
        OVERRIDE_HOLDING: ApiGraspOverride._Override.ValueType  # 1
        OVERRIDE_NOT_HOLDING: ApiGraspOverride._Override.ValueType  # 2
    class Override(_Override, metaclass=_OverrideEnumTypeWrapper):
        pass

    OVERRIDE_UNKNOWN: ApiGraspOverride.Override.ValueType  # 0
    OVERRIDE_HOLDING: ApiGraspOverride.Override.ValueType  # 1
    OVERRIDE_NOT_HOLDING: ApiGraspOverride.Override.ValueType  # 2

    OVERRIDE_REQUEST_FIELD_NUMBER: builtins.int
    override_request: global___ApiGraspOverride.Override.ValueType
    def __init__(self,
        *,
        override_request: global___ApiGraspOverride.Override.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["override_request",b"override_request"]) -> None: ...
global___ApiGraspOverride = ApiGraspOverride

class ApiGraspedCarryStateOverride(google.protobuf.message.Message):
    """Use this message to assert properties about the grasped item.
    By default, the robot will assume all grasped items are not carriable.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OVERRIDE_REQUEST_FIELD_NUMBER: builtins.int
    override_request: bosdyn.api.robot_state_pb2.ManipulatorState.CarryState.ValueType
    def __init__(self,
        *,
        override_request: bosdyn.api.robot_state_pb2.ManipulatorState.CarryState.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["override_request",b"override_request"]) -> None: ...
global___ApiGraspedCarryStateOverride = ApiGraspedCarryStateOverride

class ApiGraspOverrideRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    API_GRASP_OVERRIDE_FIELD_NUMBER: builtins.int
    CARRY_STATE_OVERRIDE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.RequestHeader:
        """Common request header."""
        pass
    @property
    def api_grasp_override(self) -> global___ApiGraspOverride: ...
    @property
    def carry_state_override(self) -> global___ApiGraspedCarryStateOverride:
        """If the grasp override is set to NOT_HOLDING, setting a carry_state_override
        message will cause the request to be rejected as malformed.
        """
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.RequestHeader] = ...,
        api_grasp_override: typing.Optional[global___ApiGraspOverride] = ...,
        carry_state_override: typing.Optional[global___ApiGraspedCarryStateOverride] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["api_grasp_override",b"api_grasp_override","carry_state_override",b"carry_state_override","header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["api_grasp_override",b"api_grasp_override","carry_state_override",b"carry_state_override","header",b"header"]) -> None: ...
global___ApiGraspOverrideRequest = ApiGraspOverrideRequest

class ApiGraspOverrideResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> bosdyn.api.header_pb2.ResponseHeader:
        """Common response header."""
        pass
    def __init__(self,
        *,
        header: typing.Optional[bosdyn.api.header_pb2.ResponseHeader] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header"]) -> None: ...
global___ApiGraspOverrideResponse = ApiGraspOverrideResponse
