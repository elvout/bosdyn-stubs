"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import bosdyn.api.geometry_pb2
import bosdyn.api.trajectory_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class RobotCommandFeedbackStatus(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RobotCommandFeedbackStatus._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATUS_UNKNOWN: RobotCommandFeedbackStatus._Status.ValueType  # 0
        """/ Behavior execution is in an unknown / unexpected state."""

        STATUS_PROCESSING: RobotCommandFeedbackStatus._Status.ValueType  # 1
        """/ The robot is actively working on the command"""

        STATUS_COMMAND_OVERRIDDEN: RobotCommandFeedbackStatus._Status.ValueType  # 2
        """/ The command was replaced by a new command"""

        STATUS_COMMAND_TIMED_OUT: RobotCommandFeedbackStatus._Status.ValueType  # 3
        """/ The command expired"""

        STATUS_ROBOT_FROZEN: RobotCommandFeedbackStatus._Status.ValueType  # 4
        """/ The robot is in an unsafe state, and will only respond to known safe commands."""

        STATUS_INCOMPATIBLE_HARDWARE: RobotCommandFeedbackStatus._Status.ValueType  # 5
        """/ The request cannot be executed because the required hardware is missing.
        / For example, an armless robot receiving a synchronized command with an arm_command
        / request will return this value in the arm_command_feedback status.
        """

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        pass

    STATUS_UNKNOWN: RobotCommandFeedbackStatus.Status.ValueType  # 0
    """/ Behavior execution is in an unknown / unexpected state."""

    STATUS_PROCESSING: RobotCommandFeedbackStatus.Status.ValueType  # 1
    """/ The robot is actively working on the command"""

    STATUS_COMMAND_OVERRIDDEN: RobotCommandFeedbackStatus.Status.ValueType  # 2
    """/ The command was replaced by a new command"""

    STATUS_COMMAND_TIMED_OUT: RobotCommandFeedbackStatus.Status.ValueType  # 3
    """/ The command expired"""

    STATUS_ROBOT_FROZEN: RobotCommandFeedbackStatus.Status.ValueType  # 4
    """/ The robot is in an unsafe state, and will only respond to known safe commands."""

    STATUS_INCOMPATIBLE_HARDWARE: RobotCommandFeedbackStatus.Status.ValueType  # 5
    """/ The request cannot be executed because the required hardware is missing.
    / For example, an armless robot receiving a synchronized command with an arm_command
    / request will return this value in the arm_command_feedback status.
    """


    def __init__(self,
        ) -> None: ...
global___RobotCommandFeedbackStatus = RobotCommandFeedbackStatus

class BatteryChangePoseCommand(google.protobuf.message.Message):
    """Get the robot into a convenient pose for changing the battery"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _DirectionHint:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _DirectionHintEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[BatteryChangePoseCommand.Request._DirectionHint.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            HINT_UNKNOWN: BatteryChangePoseCommand.Request._DirectionHint.ValueType  # 0
            """Unknown direction, just hold still"""

            HINT_RIGHT: BatteryChangePoseCommand.Request._DirectionHint.ValueType  # 1
            """Roll over right (right feet end up under the robot)"""

            HINT_LEFT: BatteryChangePoseCommand.Request._DirectionHint.ValueType  # 2
            """Roll over left (left feet end up under the robot)"""

        class DirectionHint(_DirectionHint, metaclass=_DirectionHintEnumTypeWrapper):
            pass

        HINT_UNKNOWN: BatteryChangePoseCommand.Request.DirectionHint.ValueType  # 0
        """Unknown direction, just hold still"""

        HINT_RIGHT: BatteryChangePoseCommand.Request.DirectionHint.ValueType  # 1
        """Roll over right (right feet end up under the robot)"""

        HINT_LEFT: BatteryChangePoseCommand.Request.DirectionHint.ValueType  # 2
        """Roll over left (left feet end up under the robot)"""


        DIRECTION_HINT_FIELD_NUMBER: builtins.int
        direction_hint: global___BatteryChangePoseCommand.Request.DirectionHint.ValueType
        def __init__(self,
            *,
            direction_hint: global___BatteryChangePoseCommand.Request.DirectionHint.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["direction_hint",b"direction_hint"]) -> None: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[BatteryChangePoseCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: BatteryChangePoseCommand.Feedback._Status.ValueType  # 0
            STATUS_COMPLETED: BatteryChangePoseCommand.Feedback._Status.ValueType  # 1
            """Robot is finished rolling"""

            STATUS_IN_PROGRESS: BatteryChangePoseCommand.Feedback._Status.ValueType  # 2
            """Robot still in process of rolling over"""

            STATUS_FAILED: BatteryChangePoseCommand.Feedback._Status.ValueType  # 3
            """Robot has failed to roll onto its side"""

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: BatteryChangePoseCommand.Feedback.Status.ValueType  # 0
        STATUS_COMPLETED: BatteryChangePoseCommand.Feedback.Status.ValueType  # 1
        """Robot is finished rolling"""

        STATUS_IN_PROGRESS: BatteryChangePoseCommand.Feedback.Status.ValueType  # 2
        """Robot still in process of rolling over"""

        STATUS_FAILED: BatteryChangePoseCommand.Feedback.Status.ValueType  # 3
        """Robot has failed to roll onto its side"""


        STATUS_FIELD_NUMBER: builtins.int
        status: global___BatteryChangePoseCommand.Feedback.Status.ValueType
        def __init__(self,
            *,
            status: global___BatteryChangePoseCommand.Feedback.Status.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___BatteryChangePoseCommand = BatteryChangePoseCommand

class SelfRightCommand(google.protobuf.message.Message):
    """Move the robot into a "ready" position from which it can sit or stand up."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        """SelfRight command request takes no additional arguments."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    class Feedback(google.protobuf.message.Message):
        """SelfRight command request provides no feedback."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    def __init__(self,
        ) -> None: ...
global___SelfRightCommand = SelfRightCommand

class StopCommand(google.protobuf.message.Message):
    """Stop the robot in place with minimal motion."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        """Stop command request takes no additional arguments."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    class Feedback(google.protobuf.message.Message):
        """Stop command provides no feedback."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    def __init__(self,
        ) -> None: ...
global___StopCommand = StopCommand

class FreezeCommand(google.protobuf.message.Message):
    """Freeze all joints at their current positions (no balancing control)."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        """Freeze command request takes no additional arguments."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    class Feedback(google.protobuf.message.Message):
        """Freeze command provides no feedback."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    def __init__(self,
        ) -> None: ...
global___FreezeCommand = FreezeCommand

class SafePowerOffCommand(google.protobuf.message.Message):
    """Get robot into a position where it is safe to power down, then power down. If the robot has
    fallen, it will power down directly. If the robot is not in a safe position, it will get to a
    safe position before powering down. The robot will not power down until it is in a safe state.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        """SafePowerOff command request takes no additional arguments."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    class Feedback(google.protobuf.message.Message):
        """The SafePowerOff will provide feedback on whether or not it has succeeded in powering off
        the robot yet.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SafePowerOffCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: SafePowerOffCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            STATUS_POWERED_OFF: SafePowerOffCommand.Feedback._Status.ValueType  # 1
            """Robot has powered off."""

            STATUS_IN_PROGRESS: SafePowerOffCommand.Feedback._Status.ValueType  # 2
            """Robot is trying to safely power off."""

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: SafePowerOffCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        STATUS_POWERED_OFF: SafePowerOffCommand.Feedback.Status.ValueType  # 1
        """Robot has powered off."""

        STATUS_IN_PROGRESS: SafePowerOffCommand.Feedback.Status.ValueType  # 2
        """Robot is trying to safely power off."""


        STATUS_FIELD_NUMBER: builtins.int
        status: global___SafePowerOffCommand.Feedback.Status.ValueType
        """Current status of the command."""

        def __init__(self,
            *,
            status: global___SafePowerOffCommand.Feedback.Status.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___SafePowerOffCommand = SafePowerOffCommand

class SE2TrajectoryCommand(google.protobuf.message.Message):
    """Move along a trajectory in 2D space."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        END_TIME_FIELD_NUMBER: builtins.int
        SE2_FRAME_NAME_FIELD_NUMBER: builtins.int
        TRAJECTORY_FIELD_NUMBER: builtins.int
        @property
        def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The timestamp (in robot time) by which a command must finish executing.
            This is a required field and used to prevent runaway commands.
            """
            pass
        se2_frame_name: typing.Text
        """The name of the frame that trajectory is relative to. The trajectory
        must be expressed in a gravity aligned frame, so either "vision",
        "odom", or "body". Any other provided se2_frame_name will be rejected
        and the trajectory command will not be exectuted.
        """

        @property
        def trajectory(self) -> bosdyn.api.trajectory_pb2.SE2Trajectory:
            """The trajectory that the robot should follow, expressed in the frame
            identified by se2_frame_name.
            """
            pass
        def __init__(self,
            *,
            end_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            se2_frame_name: typing.Text = ...,
            trajectory: typing.Optional[bosdyn.api.trajectory_pb2.SE2Trajectory] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","trajectory",b"trajectory"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["end_time",b"end_time","se2_frame_name",b"se2_frame_name","trajectory",b"trajectory"]) -> None: ...

    class Feedback(google.protobuf.message.Message):
        """The SE2TrajectoryCommand will provide feedback on whether or not the robot has reached the
        final point of the trajectory.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SE2TrajectoryCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: SE2TrajectoryCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            STATUS_AT_GOAL: SE2TrajectoryCommand.Feedback._Status.ValueType  # 1
            """The robot has arrived and is standing at the goal."""

            STATUS_NEAR_GOAL: SE2TrajectoryCommand.Feedback._Status.ValueType  # 3
            """The robot has arrived at the goal and is doing final positioning."""

            STATUS_GOING_TO_GOAL: SE2TrajectoryCommand.Feedback._Status.ValueType  # 2
            """The robot is attempting to go to a goal."""

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: SE2TrajectoryCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        STATUS_AT_GOAL: SE2TrajectoryCommand.Feedback.Status.ValueType  # 1
        """The robot has arrived and is standing at the goal."""

        STATUS_NEAR_GOAL: SE2TrajectoryCommand.Feedback.Status.ValueType  # 3
        """The robot has arrived at the goal and is doing final positioning."""

        STATUS_GOING_TO_GOAL: SE2TrajectoryCommand.Feedback.Status.ValueType  # 2
        """The robot is attempting to go to a goal."""


        class _BodyMovementStatus:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _BodyMovementStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SE2TrajectoryCommand.Feedback._BodyMovementStatus.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            BODY_STATUS_UNKNOWN: SE2TrajectoryCommand.Feedback._BodyMovementStatus.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            BODY_STATUS_MOVING: SE2TrajectoryCommand.Feedback._BodyMovementStatus.ValueType  # 1
            """The robot body is not settled at the goal."""

            BODY_STATUS_SETTLED: SE2TrajectoryCommand.Feedback._BodyMovementStatus.ValueType  # 2
            """The robot is at the goal and the body has stopped moving."""

        class BodyMovementStatus(_BodyMovementStatus, metaclass=_BodyMovementStatusEnumTypeWrapper):
            pass

        BODY_STATUS_UNKNOWN: SE2TrajectoryCommand.Feedback.BodyMovementStatus.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        BODY_STATUS_MOVING: SE2TrajectoryCommand.Feedback.BodyMovementStatus.ValueType  # 1
        """The robot body is not settled at the goal."""

        BODY_STATUS_SETTLED: SE2TrajectoryCommand.Feedback.BodyMovementStatus.ValueType  # 2
        """The robot is at the goal and the body has stopped moving."""


        STATUS_FIELD_NUMBER: builtins.int
        BODY_MOVEMENT_STATUS_FIELD_NUMBER: builtins.int
        status: global___SE2TrajectoryCommand.Feedback.Status.ValueType
        """Current status of the command."""

        body_movement_status: global___SE2TrajectoryCommand.Feedback.BodyMovementStatus.ValueType
        """Current status of how the body is moving"""

        def __init__(self,
            *,
            status: global___SE2TrajectoryCommand.Feedback.Status.ValueType = ...,
            body_movement_status: global___SE2TrajectoryCommand.Feedback.BodyMovementStatus.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["body_movement_status",b"body_movement_status","status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___SE2TrajectoryCommand = SE2TrajectoryCommand

class SE2VelocityCommand(google.protobuf.message.Message):
    """Move the robot at a specific SE2 velocity for a fixed amount of time."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        END_TIME_FIELD_NUMBER: builtins.int
        SE2_FRAME_NAME_FIELD_NUMBER: builtins.int
        VELOCITY_FIELD_NUMBER: builtins.int
        SLEW_RATE_LIMIT_FIELD_NUMBER: builtins.int
        @property
        def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The timestamp (in robot time) by which a command must finish executing. This is a
            required field and used to prevent runaway commands.
            """
            pass
        se2_frame_name: typing.Text
        """The name of the frame that velocity and slew_rate_limit are relative to.
        The trajectory must be expressed in a gravity aligned frame, so either
        "vision", "odom", or "flat_body". Any other provided
        se2_frame_name will be rejected and the velocity command will not be executed.
        """

        @property
        def velocity(self) -> bosdyn.api.geometry_pb2.SE2Velocity:
            """Desired planar velocity of the robot body relative to se2_frame_name."""
            pass
        @property
        def slew_rate_limit(self) -> bosdyn.api.geometry_pb2.SE2Velocity:
            """If set, limits how quickly velocity can change relative to se2_frame_name.
            Otherwise, robot may decide to limit velocities using default settings.
            These values should be non-negative.
            """
            pass
        def __init__(self,
            *,
            end_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            se2_frame_name: typing.Text = ...,
            velocity: typing.Optional[bosdyn.api.geometry_pb2.SE2Velocity] = ...,
            slew_rate_limit: typing.Optional[bosdyn.api.geometry_pb2.SE2Velocity] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","slew_rate_limit",b"slew_rate_limit","velocity",b"velocity"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["end_time",b"end_time","se2_frame_name",b"se2_frame_name","slew_rate_limit",b"slew_rate_limit","velocity",b"velocity"]) -> None: ...

    class Feedback(google.protobuf.message.Message):
        """Planar velocity commands provide no feedback."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    def __init__(self,
        ) -> None: ...
global___SE2VelocityCommand = SE2VelocityCommand

class SitCommand(google.protobuf.message.Message):
    """Sit the robot down in its current position."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        """Sit command request takes no additional arguments."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SitCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: SitCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            STATUS_IS_SITTING: SitCommand.Feedback._Status.ValueType  # 1
            """Robot is currently sitting."""

            STATUS_IN_PROGRESS: SitCommand.Feedback._Status.ValueType  # 2
            """Robot is trying to sit."""

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: SitCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        STATUS_IS_SITTING: SitCommand.Feedback.Status.ValueType  # 1
        """Robot is currently sitting."""

        STATUS_IN_PROGRESS: SitCommand.Feedback.Status.ValueType  # 2
        """Robot is trying to sit."""


        STATUS_FIELD_NUMBER: builtins.int
        status: global___SitCommand.Feedback.Status.ValueType
        """Current status of the command."""

        def __init__(self,
            *,
            status: global___SitCommand.Feedback.Status.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___SitCommand = SitCommand

class StandCommand(google.protobuf.message.Message):
    """The stand the robot up in its current position."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        """Stand command request takes no additional arguments."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    class Feedback(google.protobuf.message.Message):
        """The StandCommand will provide feedback on whether or not the robot has finished
        standing up.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[StandCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: StandCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            STATUS_IS_STANDING: StandCommand.Feedback._Status.ValueType  # 1
            """Robot has finished standing up and has completed desired body trajectory.
            Robot is not attempting to move.
            """

            STATUS_IN_PROGRESS: StandCommand.Feedback._Status.ValueType  # 2
            """Robot is trying to come to a steady stand."""

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: StandCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        STATUS_IS_STANDING: StandCommand.Feedback.Status.ValueType  # 1
        """Robot has finished standing up and has completed desired body trajectory.
        Robot is not attempting to move.
        """

        STATUS_IN_PROGRESS: StandCommand.Feedback.Status.ValueType  # 2
        """Robot is trying to come to a steady stand."""


        STATUS_FIELD_NUMBER: builtins.int
        status: global___StandCommand.Feedback.Status.ValueType
        """Current status of the command."""

        def __init__(self,
            *,
            status: global___StandCommand.Feedback.Status.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___StandCommand = StandCommand

class StanceCommand(google.protobuf.message.Message):
    """Precise foot placement
    This can be used to reposition the robots feet in place.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        END_TIME_FIELD_NUMBER: builtins.int
        STANCE_FIELD_NUMBER: builtins.int
        @property
        def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """/ The timestamp (in robot time) by which a command must finish executing.
            / This is a required field and used to prevent runaway commands.
            """
            pass
        @property
        def stance(self) -> global___Stance: ...
        def __init__(self,
            *,
            end_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            stance: typing.Optional[global___Stance] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","stance",b"stance"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["end_time",b"end_time","stance",b"stance"]) -> None: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[StanceCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: StanceCommand.Feedback._Status.ValueType  # 0
            STATUS_STANCED: StanceCommand.Feedback._Status.ValueType  # 1
            """Robot has finished moving feet and they are at the specified position"""

            STATUS_GOING_TO_STANCE: StanceCommand.Feedback._Status.ValueType  # 2
            """Robot is in the process of moving feet to specified position"""

            STATUS_TOO_FAR_AWAY: StanceCommand.Feedback._Status.ValueType  # 3
            """Robot is not moving, the specified stance was too far away.
            Hint: Try using SE2TrajectoryCommand to safely put the robot at the
                  correct location first.
            """

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: StanceCommand.Feedback.Status.ValueType  # 0
        STATUS_STANCED: StanceCommand.Feedback.Status.ValueType  # 1
        """Robot has finished moving feet and they are at the specified position"""

        STATUS_GOING_TO_STANCE: StanceCommand.Feedback.Status.ValueType  # 2
        """Robot is in the process of moving feet to specified position"""

        STATUS_TOO_FAR_AWAY: StanceCommand.Feedback.Status.ValueType  # 3
        """Robot is not moving, the specified stance was too far away.
        Hint: Try using SE2TrajectoryCommand to safely put the robot at the
              correct location first.
        """


        STATUS_FIELD_NUMBER: builtins.int
        status: global___StanceCommand.Feedback.Status.ValueType
        def __init__(self,
            *,
            status: global___StanceCommand.Feedback.Status.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___StanceCommand = StanceCommand

class Stance(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class FootPositionsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> bosdyn.api.geometry_pb2.Vec2: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[bosdyn.api.geometry_pb2.Vec2] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SE2_FRAME_NAME_FIELD_NUMBER: builtins.int
    FOOT_POSITIONS_FIELD_NUMBER: builtins.int
    ACCURACY_FIELD_NUMBER: builtins.int
    se2_frame_name: typing.Text
    """The frame name which the desired foot_positions are described in."""

    @property
    def foot_positions(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, bosdyn.api.geometry_pb2.Vec2]:
        """Map of foot name to its x,y location in specified frame.
        Required positions for spot: "fl", "fr", "hl", "hr".
        """
        pass
    accuracy: builtins.float
    """Required foot positional accuracy in meters
    Advised = 0.05 ( 5cm)
    Minimum = 0.02 ( 2cm)
    Maximum = 0.10 (10cm)
    """

    def __init__(self,
        *,
        se2_frame_name: typing.Text = ...,
        foot_positions: typing.Optional[typing.Mapping[typing.Text, bosdyn.api.geometry_pb2.Vec2]] = ...,
        accuracy: builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["accuracy",b"accuracy","foot_positions",b"foot_positions","se2_frame_name",b"se2_frame_name"]) -> None: ...
global___Stance = Stance

class FollowArmCommand(google.protobuf.message.Message):
    """The base will move in response to the hand's location, allow the arm to reach beyond
    its current workspace.  If the hand is moved forward, the body will begin walking
    forward to keep the base at the desired offset from the hand.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        BODY_OFFSET_FROM_HAND_FIELD_NUMBER: builtins.int
        DISABLE_WALKING_FIELD_NUMBER: builtins.int
        @property
        def body_offset_from_hand(self) -> bosdyn.api.geometry_pb2.Vec3:
            """Optional body offset from the hand.
            For example, to have the body 0.75 meters behind the hand, use (0.75, 0, 0)
            """
            pass
        disable_walking: builtins.bool
        """Optional. If true, the body will be restricted to body orientation offsets only."""

        def __init__(self,
            *,
            body_offset_from_hand: typing.Optional[bosdyn.api.geometry_pb2.Vec3] = ...,
            disable_walking: builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["body_offset_from_hand",b"body_offset_from_hand"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["body_offset_from_hand",b"body_offset_from_hand","disable_walking",b"disable_walking"]) -> None: ...

    class Feedback(google.protobuf.message.Message):
        """FollowArmCommand commands provide no feedback."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    def __init__(self,
        ) -> None: ...
global___FollowArmCommand = FollowArmCommand

class ArmDragCommand(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ArmDragCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: ArmDragCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            STATUS_DRAGGING: ArmDragCommand.Feedback._Status.ValueType  # 1
            """Robot is dragging."""

            STATUS_GRASP_FAILED: ArmDragCommand.Feedback._Status.ValueType  # 2
            """Robot is not dragging because grasp failed.
            This could be due to a lost grasp during a drag, or because the gripper isn't in a good
            position at the time of request. You'll have to reposition or regrasp and then send a
            new drag request to overcome this type of error.
            Note: When requesting drag, make sure the gripper is positioned in front of the robot (not to the side of or
            above the robot body).
            """

            STATUS_OTHER_FAILURE: ArmDragCommand.Feedback._Status.ValueType  # 3
            """Robot is not dragging for another reason.
            This might be because the gripper isn't holding an item.
            You can continue dragging once you resolve this type of error (i.e. by sending an ApiGraspOverride request).
            Note: When requesting drag, be sure to that the robot knows it's holding something (or use APIGraspOverride to
            OVERRIDE_HOLDING).
            """

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: ArmDragCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        STATUS_DRAGGING: ArmDragCommand.Feedback.Status.ValueType  # 1
        """Robot is dragging."""

        STATUS_GRASP_FAILED: ArmDragCommand.Feedback.Status.ValueType  # 2
        """Robot is not dragging because grasp failed.
        This could be due to a lost grasp during a drag, or because the gripper isn't in a good
        position at the time of request. You'll have to reposition or regrasp and then send a
        new drag request to overcome this type of error.
        Note: When requesting drag, make sure the gripper is positioned in front of the robot (not to the side of or
        above the robot body).
        """

        STATUS_OTHER_FAILURE: ArmDragCommand.Feedback.Status.ValueType  # 3
        """Robot is not dragging for another reason.
        This might be because the gripper isn't holding an item.
        You can continue dragging once you resolve this type of error (i.e. by sending an ApiGraspOverride request).
        Note: When requesting drag, be sure to that the robot knows it's holding something (or use APIGraspOverride to
        OVERRIDE_HOLDING).
        """


        STATUS_FIELD_NUMBER: builtins.int
        status: global___ArmDragCommand.Feedback.Status.ValueType
        def __init__(self,
            *,
            status: global___ArmDragCommand.Feedback.Status.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___ArmDragCommand = ArmDragCommand

class ConstrainedManipulationCommand(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Request(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _TaskType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _TaskTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ConstrainedManipulationCommand.Request._TaskType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            TASK_TYPE_UNKNOWN: ConstrainedManipulationCommand.Request._TaskType.ValueType  # 0
            TASK_TYPE_SE3_CIRCLE_FORCE_TORQUE: ConstrainedManipulationCommand.Request._TaskType.ValueType  # 1
            """This task type corresponds to circular tasks where
            both the end-effector position and orientation rotate about a circle to manipulate.
            The constrained manipulation logic will generate forces and torques in this case.
            Example tasks are: A lever or a ball valve with a solid grasp
            This task type will require an initial force vector specified
            in init_wrench_direction_in_frame_name. A torque vector can be specified
            as well if a good initial guess of the axis of rotation of the task is available.
            """

            TASK_TYPE_R3_CIRCLE_EXTRADOF_FORCE: ConstrainedManipulationCommand.Request._TaskType.ValueType  # 2
            """This task type corresponds to circular tasks that have an extra degree of freedom.
            In these tasks the end-effector position rotates about a circle
            but the orientation does not need to follow a circle (can remain fixed).
            The constrained manipulation logic will generate translational forces in this case.
            Example tasks are: A crank that has a loose handle and moves in a circle
            and the end-effector is free to rotate about the handle in one direction.
            This task type will require an initial force vector specified
            in init_wrench_direction_in_frame_name.
            """

            TASK_TYPE_SE3_ROTATIONAL_TORQUE: ConstrainedManipulationCommand.Request._TaskType.ValueType  # 3
            """This task type corresponds to purely rotational tasks.
            In these tasks the orientation of the end-effector follows a circle,
            and the position remains fixed. The robot will apply a torque at the
            end-effector in these tasks.
            Example tasks are: rotating a knob or valve that does not have a lever arm.
            This task type will require an initial torque vector specified
            in init_wrench_direction_in_frame_name.
            """

            TASK_TYPE_R3_CIRCLE_FORCE: ConstrainedManipulationCommand.Request._TaskType.ValueType  # 4
            """This task type corresponds to circular tasks where
            the end-effector position and orientation rotate about a circle
            but the orientation does always strictly follow the circle due to slips.
            The constrained manipulation logic will generate translational forces in this case.
            Example tasks are: manipulating a cabinet where the grasp on handle is not very rigid
            or can often slip.
            This task type will require an initial force vector specified
            in init_wrench_direction_in_frame_name.
            """

            TASK_TYPE_R3_LINEAR_FORCE: ConstrainedManipulationCommand.Request._TaskType.ValueType  # 5
            """This task type corresponds to linear tasks where
            the end-effector position moves in a line
            but the orientation does not need to change.
            The constrained manipulation logic will generate a force in this case.
            Example tasks are: A crank that has a loose handle, or manipulating
            a cabinet where the grasp of the handle is loose and the end-effector is free
            to rotate about the handle in one direction.
            This task type will require an initial force vector specified
            in init_wrench_direction_in_frame_name.
            """

            TASK_TYPE_HOLD_POSE: ConstrainedManipulationCommand.Request._TaskType.ValueType  # 6
            """This option simply holds the hand in place with stiff impedance control.
            You can use this mode at the beginning of a constrained manipulation task or to
            hold position while transitioning between two different constrained manipulation tasks.
            The target pose to hold will be the measured hand pose upon transitioning to constrained
            manipulation or upon switching to this task type. 
            This mode should only be used during constrained manipulation tasks,
            since it uses impedance control to hold the hand in place.
            This is not intended to stop the arm during position control moves.
            """

        class TaskType(_TaskType, metaclass=_TaskTypeEnumTypeWrapper):
            """Geometrical category of a task. See the constrained_manipulation_helper function
            for examples of each of these categories. For e.g. SE3_CIRCLE_FORCE_TORQUE corresponds
            to lever type objects.
            """
            pass

        TASK_TYPE_UNKNOWN: ConstrainedManipulationCommand.Request.TaskType.ValueType  # 0
        TASK_TYPE_SE3_CIRCLE_FORCE_TORQUE: ConstrainedManipulationCommand.Request.TaskType.ValueType  # 1
        """This task type corresponds to circular tasks where
        both the end-effector position and orientation rotate about a circle to manipulate.
        The constrained manipulation logic will generate forces and torques in this case.
        Example tasks are: A lever or a ball valve with a solid grasp
        This task type will require an initial force vector specified
        in init_wrench_direction_in_frame_name. A torque vector can be specified
        as well if a good initial guess of the axis of rotation of the task is available.
        """

        TASK_TYPE_R3_CIRCLE_EXTRADOF_FORCE: ConstrainedManipulationCommand.Request.TaskType.ValueType  # 2
        """This task type corresponds to circular tasks that have an extra degree of freedom.
        In these tasks the end-effector position rotates about a circle
        but the orientation does not need to follow a circle (can remain fixed).
        The constrained manipulation logic will generate translational forces in this case.
        Example tasks are: A crank that has a loose handle and moves in a circle
        and the end-effector is free to rotate about the handle in one direction.
        This task type will require an initial force vector specified
        in init_wrench_direction_in_frame_name.
        """

        TASK_TYPE_SE3_ROTATIONAL_TORQUE: ConstrainedManipulationCommand.Request.TaskType.ValueType  # 3
        """This task type corresponds to purely rotational tasks.
        In these tasks the orientation of the end-effector follows a circle,
        and the position remains fixed. The robot will apply a torque at the
        end-effector in these tasks.
        Example tasks are: rotating a knob or valve that does not have a lever arm.
        This task type will require an initial torque vector specified
        in init_wrench_direction_in_frame_name.
        """

        TASK_TYPE_R3_CIRCLE_FORCE: ConstrainedManipulationCommand.Request.TaskType.ValueType  # 4
        """This task type corresponds to circular tasks where
        the end-effector position and orientation rotate about a circle
        but the orientation does always strictly follow the circle due to slips.
        The constrained manipulation logic will generate translational forces in this case.
        Example tasks are: manipulating a cabinet where the grasp on handle is not very rigid
        or can often slip.
        This task type will require an initial force vector specified
        in init_wrench_direction_in_frame_name.
        """

        TASK_TYPE_R3_LINEAR_FORCE: ConstrainedManipulationCommand.Request.TaskType.ValueType  # 5
        """This task type corresponds to linear tasks where
        the end-effector position moves in a line
        but the orientation does not need to change.
        The constrained manipulation logic will generate a force in this case.
        Example tasks are: A crank that has a loose handle, or manipulating
        a cabinet where the grasp of the handle is loose and the end-effector is free
        to rotate about the handle in one direction.
        This task type will require an initial force vector specified
        in init_wrench_direction_in_frame_name.
        """

        TASK_TYPE_HOLD_POSE: ConstrainedManipulationCommand.Request.TaskType.ValueType  # 6
        """This option simply holds the hand in place with stiff impedance control.
        You can use this mode at the beginning of a constrained manipulation task or to
        hold position while transitioning between two different constrained manipulation tasks.
        The target pose to hold will be the measured hand pose upon transitioning to constrained
        manipulation or upon switching to this task type. 
        This mode should only be used during constrained manipulation tasks,
        since it uses impedance control to hold the hand in place.
        This is not intended to stop the arm during position control moves.
        """


        FRAME_NAME_FIELD_NUMBER: builtins.int
        INIT_WRENCH_DIRECTION_IN_FRAME_NAME_FIELD_NUMBER: builtins.int
        TANGENTIAL_SPEED_FIELD_NUMBER: builtins.int
        ROTATIONAL_SPEED_FIELD_NUMBER: builtins.int
        FORCE_LIMIT_FIELD_NUMBER: builtins.int
        TORQUE_LIMIT_FIELD_NUMBER: builtins.int
        TASK_TYPE_FIELD_NUMBER: builtins.int
        END_TIME_FIELD_NUMBER: builtins.int
        frame_name: typing.Text
        """Frame that the initial wrench will be expressed in"""

        @property
        def init_wrench_direction_in_frame_name(self) -> bosdyn.api.geometry_pb2.Wrench:
            """Direction of the initial wrench to be applied
            Depending on the task, either the force vector or the
            torque vector are required to be specified. The required
            vector should not have a magnitude of zero and will be
            normalized to 1. For tasks that require the force vector,
            the torque vector can still be specified as a non-zero vector
            if it is a good guess of the axis of rotation of the task.
            (for e.g. TASK_TYPE_SE3_ROTATIONAL_TORQUE task types.)
            Note that if both vectors are non-zero, they have to be perpendicular.
            Once the constrained manipulation system estimates the
            constraint, the init_wrench_direction and frame_name
            will no longer be used.
            """
            pass
        tangential_speed: builtins.float
        """Recommended values are in the range of [-4, 4] m/s"""

        rotational_speed: builtins.float
        """Recommended values are in the range of [-4, 4] rad/s"""

        @property
        def force_limit(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """The limit on the force that is applied on any translation direction
            Value must be positive
            If unspecified, a default value of 40 N will be used.
            """
            pass
        @property
        def torque_limit(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """The limit on the torque that is applied on any rotational direction
            Value must be positive
            If unspecified, a default value of 4 Nm will be used.
            """
            pass
        task_type: global___ConstrainedManipulationCommand.Request.TaskType.ValueType
        @property
        def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The timestamp (in robot time) by which a command must finish executing.
            This is a required field and used to prevent runaway commands.
            """
            pass
        def __init__(self,
            *,
            frame_name: typing.Text = ...,
            init_wrench_direction_in_frame_name: typing.Optional[bosdyn.api.geometry_pb2.Wrench] = ...,
            tangential_speed: builtins.float = ...,
            rotational_speed: builtins.float = ...,
            force_limit: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            torque_limit: typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            task_type: global___ConstrainedManipulationCommand.Request.TaskType.ValueType = ...,
            end_time: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","force_limit",b"force_limit","init_wrench_direction_in_frame_name",b"init_wrench_direction_in_frame_name","rotational_speed",b"rotational_speed","tangential_speed",b"tangential_speed","task_speed",b"task_speed","torque_limit",b"torque_limit"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["end_time",b"end_time","force_limit",b"force_limit","frame_name",b"frame_name","init_wrench_direction_in_frame_name",b"init_wrench_direction_in_frame_name","rotational_speed",b"rotational_speed","tangential_speed",b"tangential_speed","task_speed",b"task_speed","task_type",b"task_type","torque_limit",b"torque_limit"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["task_speed",b"task_speed"]) -> typing.Optional[typing_extensions.Literal["tangential_speed","rotational_speed"]]: ...

    class Feedback(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _Status:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ConstrainedManipulationCommand.Feedback._Status.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            STATUS_UNKNOWN: ConstrainedManipulationCommand.Feedback._Status.ValueType  # 0
            """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

            STATUS_RUNNING: ConstrainedManipulationCommand.Feedback._Status.ValueType  # 1
            """Constrained manipulation is working as expected"""

            STATUS_ARM_IS_STUCK: ConstrainedManipulationCommand.Feedback._Status.ValueType  # 2
            """Arm is stuck, either force is being applied in a direction
            where the affordance can't move or not enough force is applied
            """

            STATUS_GRASP_IS_LOST: ConstrainedManipulationCommand.Feedback._Status.ValueType  # 3
            """The grasp was lost. In this situation, constrained manipulation
            will stop applying force, and will hold the last position.
            """

        class Status(_Status, metaclass=_StatusEnumTypeWrapper):
            pass

        STATUS_UNKNOWN: ConstrainedManipulationCommand.Feedback.Status.ValueType  # 0
        """STATUS_UNKNOWN should never be used. If used, an internal error has happened."""

        STATUS_RUNNING: ConstrainedManipulationCommand.Feedback.Status.ValueType  # 1
        """Constrained manipulation is working as expected"""

        STATUS_ARM_IS_STUCK: ConstrainedManipulationCommand.Feedback.Status.ValueType  # 2
        """Arm is stuck, either force is being applied in a direction
        where the affordance can't move or not enough force is applied
        """

        STATUS_GRASP_IS_LOST: ConstrainedManipulationCommand.Feedback.Status.ValueType  # 3
        """The grasp was lost. In this situation, constrained manipulation
        will stop applying force, and will hold the last position.
        """


        STATUS_FIELD_NUMBER: builtins.int
        DESIRED_WRENCH_ODOM_FRAME_FIELD_NUMBER: builtins.int
        status: global___ConstrainedManipulationCommand.Feedback.Status.ValueType
        @property
        def desired_wrench_odom_frame(self) -> bosdyn.api.geometry_pb2.Wrench:
            """Desired wrench in odom world frame, applied at hand frame origin"""
            pass
        def __init__(self,
            *,
            status: global___ConstrainedManipulationCommand.Feedback.Status.ValueType = ...,
            desired_wrench_odom_frame: typing.Optional[bosdyn.api.geometry_pb2.Wrench] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["desired_wrench_odom_frame",b"desired_wrench_odom_frame"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["desired_wrench_odom_frame",b"desired_wrench_odom_frame","status",b"status"]) -> None: ...

    def __init__(self,
        ) -> None: ...
global___ConstrainedManipulationCommand = ConstrainedManipulationCommand
